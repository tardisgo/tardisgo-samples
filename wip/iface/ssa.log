# Name: main.main
# Package: main
# Location: iface.go:5:6
func main():
0:                                                                entry P:0 S:0
	t0 = *a                                                           []int
	t1 = make interface{} <- []int (t0)                         interface{}
	t2 = printInt(t1)                                                    ()
	return

# Name: main.printInt
# Package: main
# Location: iface.go:9:6
func printInt(i interface{}):
0:                                                                entry P:0 S:0
	t0 = typeassert i.([]int)                                         []int
	t1 = &t0[0:int]                                                    *int
	t2 = *t1                                                            int
	t3 = println(t2)                                                     ()
	return

# Name: main.init
# Package: main
# Synthetic: package initializer
func init():
0:                                                                entry P:0 S:2
	t0 = *init$guard                                                   bool
	if t0 goto 2 else 1
1:                                                           init.start P:1 S:1
	*init$guard = true:bool
	t1 = new [1]int (slicelit)                                      *[1]int
	t2 = &t1[0:int]                                                    *int
	t3 = slice t1[:]                                                  []int
	*t2 = 42:int
	*a = t3
	jump 2
2:                                                            init.done P:2 S:0
	return

# Name: (*runtime.BlockProfileRecord).Stack
# Synthetic: wrapper for func (*runtime.StackRecord).Stack() []uintptr
# Location: /usr/local/go/src/runtime/mprof.go:332:23
func (r *runtime.BlockProfileRecord) Stack() []uintptr:
0:                                                                entry P:0 S:0
	t0 = &r.StackRecord [#2]                           *runtime.StackRecord
	t1 = (*runtime.StackRecord).Stack(t0)                         []uintptr
	return t1

# Name: (*runtime.errorString).Error
# Synthetic: wrapper for func (runtime.errorString).Error() string
# Location: /usr/local/go/src/runtime/error.go:70:22
func (e *runtime.errorString) Error() string:
0:                                                                entry P:0 S:0
	t0 = ssa:wrapnilchk(e, "runtime.errorString":string, "Error":string) *runtime.errorString
	t1 = *t0                                            runtime.errorString
	t2 = (runtime.errorString).Error(t1)                             string
	return t2

# Name: (*runtime.errorString).RuntimeError
# Synthetic: wrapper for func (runtime.errorString).RuntimeError()
# Location: /usr/local/go/src/runtime/error.go:68:22
func (e *runtime.errorString) RuntimeError():
0:                                                                entry P:0 S:0
	t0 = ssa:wrapnilchk(e, "runtime.errorString":string, "RuntimeError":string) *runtime.errorString
	t1 = *t0                                            runtime.errorString
	t2 = (runtime.errorString).RuntimeError(t1)                          ()
	return

# Name: runtime.memhash
# Package: runtime
# Location: /usr/local/go/src/runtime/alg.go:85:6
func memhash(p unsafe.Pointer, s uintptr, h uintptr) uintptr:
0:                                                                entry P:0 S:2
	if false:untyped bool goto 2 else 3
1:                                                              if.then P:1 S:0
	t0 = aeshash(p, s, h)                                           uintptr
	return t0
2:                                                              if.done P:2 S:1
	t1 = h ^ 33054211828000289:uintptr                              uintptr
	jump 6
3:                                                            cond.true P:1 S:2
	t2 = *useAeshash                                                   bool
	if t2 goto 1 else 2
4:                                                             for.body P:1 S:1
	t3 = convert *byte <- unsafe.Pointer (t10)                        *byte
	t4 = *t3                                                           byte
	t5 = convert uintptr <- byte (t4)                               uintptr
	t6 = t12 ^ t5                                                   uintptr
	t7 = t6 * 23344194077549503:uintptr                             uintptr
	t8 = add(t10, 1:uintptr)                                 unsafe.Pointer
	t9 = t11 - 1:uintptr                                            uintptr
	jump 6
5:                                                             for.done P:1 S:0
	return t12
6:                                                             for.loop P:2 S:2
	t10 = phi [2: p, 4: t8] #p                               unsafe.Pointer
	t11 = phi [2: s, 4: t9] #s                                      uintptr
	t12 = phi [2: t1, 4: t7] #h                                     uintptr
	t13 = t11 > 0:uintptr                                              bool
	if t13 goto 4 else 5

# Name: runtime.strhash
# Package: runtime
# Location: /usr/local/go/src/runtime/alg.go:99:6
func strhash(a unsafe.Pointer, s uintptr, h uintptr) uintptr:
0:                                                                entry P:0 S:0
	t0 = convert *stringStruct <- unsafe.Pointer (a)          *stringStruct
	t1 = &t0.str [#0]                                       *unsafe.Pointer
	t2 = *t1                                                 unsafe.Pointer
	t3 = convert *string <- unsafe.Pointer (a)                      *string
	t4 = *t3                                                         string
	t5 = len(t4)                                                        int
	t6 = convert uintptr <- int (t5)                                uintptr
	t7 = memhash(t2, t6, h)                                         uintptr
	return t7

# Name: runtime.f32hash
# Package: runtime
# Location: /usr/local/go/src/runtime/alg.go:108:6
func f32hash(p unsafe.Pointer, s uintptr, h uintptr) uintptr:
0:                                                                entry P:0 S:2
	t0 = convert *float32 <- unsafe.Pointer (p)                    *float32
	t1 = *t0                                                        float32
	t2 = t1 == 0:float32                                               bool
	if t2 goto 1 else 3
1:                                                          switch.body P:1 S:0
	t3 = 33054211828000289:uintptr ^ h                              uintptr
	t4 = 23344194077549503:uintptr * t3                             uintptr
	return t4
2:                                                          switch.body P:1 S:0
	t5 = 33054211828000289:uintptr ^ h                              uintptr
	t6 = fastrand1()                                                 uint32
	t7 = convert uintptr <- uint32 (t6)                             uintptr
	t8 = t5 ^ t7                                                    uintptr
	t9 = 23344194077549503:uintptr * t8                             uintptr
	return t9
3:                                                          switch.next P:1 S:2
	t10 = t1 != t1                                                     bool
	if t10 goto 2 else 4
4:                                                          switch.next P:1 S:0
	t11 = memhash(p, 4:uintptr, h)                                  uintptr
	return t11

# Name: runtime.f64hash
# Package: runtime
# Location: /usr/local/go/src/runtime/alg.go:120:6
func f64hash(p unsafe.Pointer, s uintptr, h uintptr) uintptr:
0:                                                                entry P:0 S:2
	t0 = convert *float64 <- unsafe.Pointer (p)                    *float64
	t1 = *t0                                                        float64
	t2 = t1 == 0:float64                                               bool
	if t2 goto 1 else 3
1:                                                          switch.body P:1 S:0
	t3 = 33054211828000289:uintptr ^ h                              uintptr
	t4 = 23344194077549503:uintptr * t3                             uintptr
	return t4
2:                                                          switch.body P:1 S:0
	t5 = 33054211828000289:uintptr ^ h                              uintptr
	t6 = fastrand1()                                                 uint32
	t7 = convert uintptr <- uint32 (t6)                             uintptr
	t8 = t5 ^ t7                                                    uintptr
	t9 = 23344194077549503:uintptr * t8                             uintptr
	return t9
3:                                                          switch.next P:1 S:2
	t10 = t1 != t1                                                     bool
	if t10 goto 2 else 4
4:                                                          switch.next P:1 S:0
	t11 = memhash(p, 8:uintptr, h)                                  uintptr
	return t11

# Name: runtime.c64hash
# Package: runtime
# Location: /usr/local/go/src/runtime/alg.go:132:6
func c64hash(p unsafe.Pointer, s uintptr, h uintptr) uintptr:
0:                                                                entry P:0 S:0
	t0 = convert *[2]float32 <- unsafe.Pointer (p)              *[2]float32
	t1 = &t0[1:int]                                                *float32
	t2 = convert unsafe.Pointer <- *float32 (t1)             unsafe.Pointer
	t3 = &t0[0:int]                                                *float32
	t4 = convert unsafe.Pointer <- *float32 (t3)             unsafe.Pointer
	t5 = f32hash(t4, 4:uintptr, h)                                  uintptr
	t6 = f32hash(t2, 4:uintptr, t5)                                 uintptr
	return t6

# Name: runtime.c128hash
# Package: runtime
# Location: /usr/local/go/src/runtime/alg.go:137:6
func c128hash(p unsafe.Pointer, s uintptr, h uintptr) uintptr:
0:                                                                entry P:0 S:0
	t0 = convert *[2]float64 <- unsafe.Pointer (p)              *[2]float64
	t1 = &t0[1:int]                                                *float64
	t2 = convert unsafe.Pointer <- *float64 (t1)             unsafe.Pointer
	t3 = &t0[0:int]                                                *float64
	t4 = convert unsafe.Pointer <- *float64 (t3)             unsafe.Pointer
	t5 = f64hash(t4, 8:uintptr, h)                                  uintptr
	t6 = f64hash(t2, 8:uintptr, t5)                                 uintptr
	return t6

# Name: runtime.interhash
# Package: runtime
# Location: /usr/local/go/src/runtime/alg.go:142:6
func interhash(p unsafe.Pointer, s uintptr, h uintptr) uintptr:
0:                                                                entry P:0 S:2
	t0 = convert *iface <- unsafe.Pointer (p)                        *iface
	t1 = &t0.tab [#0]                                                **itab
	t2 = *t1                                                          *itab
	t3 = t2 == nil:*itab                                               bool
	if t3 goto 1 else 2
1:                                                              if.then P:1 S:0
	return h
2:                                                              if.done P:1 S:2
	t4 = &t2._type [#1]                                             **_type
	t5 = *t4                                                         *_type
	t6 = &t5.alg [#6]                                       *unsafe.Pointer
	t7 = *t6                                                 unsafe.Pointer
	t8 = goalg(t7)                                                 *typeAlg
	t9 = &t8.hash [#0]      *func(unsafe.Pointer, uintptr, uintptr) uintptr
	t10 = *t9                func(unsafe.Pointer, uintptr, uintptr) uintptr
	t11 = t10 == nil:func(unsafe.Pointer, uintptr, uintptr) uintptr    bool
	if t11 goto 3 else 4
3:                                                              if.then P:1 S:0
	t12 = &t5._string [#8]                                         **string
	t13 = *t12                                                      *string
	t14 = *t13                                                       string
	t15 = "hash of unhashabl...":string + t14                        string
	t16 = changetype errorString <- string (t15)                errorString
	t17 = make interface{} <- errorString (t16)                 interface{}
	panic t17
4:                                                              if.done P:1 S:2
	t18 = isDirectIface(t5)                                            bool
	if t18 goto 5 else 6
5:                                                              if.then P:1 S:0
	t19 = &t0.data [#1]                                     *unsafe.Pointer
	t20 = convert unsafe.Pointer <- *unsafe.Pointer (t19)    unsafe.Pointer
	t21 = &t5.size [#0]                                            *uintptr
	t22 = *t21                                                      uintptr
	t23 = h ^ 33054211828000289:uintptr                             uintptr
	t24 = t10(t20, t22, t23)                                        uintptr
	t25 = 23344194077549503:uintptr * t24                           uintptr
	return t25
6:                                                              if.else P:1 S:0
	t26 = &t0.data [#1]                                     *unsafe.Pointer
	t27 = *t26                                               unsafe.Pointer
	t28 = &t5.size [#0]                                            *uintptr
	t29 = *t28                                                      uintptr
	t30 = h ^ 33054211828000289:uintptr                             uintptr
	t31 = t10(t27, t29, t30)                                        uintptr
	t32 = 23344194077549503:uintptr * t31                           uintptr
	return t32

# Name: runtime.nilinterhash
# Package: runtime
# Location: /usr/local/go/src/runtime/alg.go:160:6
func nilinterhash(p unsafe.Pointer, s uintptr, h uintptr) uintptr:
0:                                                                entry P:0 S:2
	t0 = convert *eface <- unsafe.Pointer (p)                        *eface
	t1 = &t0._type [#0]                                             **_type
	t2 = *t1                                                         *_type
	t3 = t2 == nil:*_type                                              bool
	if t3 goto 1 else 2
1:                                                              if.then P:1 S:0
	return h
2:                                                              if.done P:1 S:2
	t4 = &t2.alg [#6]                                       *unsafe.Pointer
	t5 = *t4                                                 unsafe.Pointer
	t6 = goalg(t5)                                                 *typeAlg
	t7 = &t6.hash [#0]      *func(unsafe.Pointer, uintptr, uintptr) uintptr
	t8 = *t7                 func(unsafe.Pointer, uintptr, uintptr) uintptr
	t9 = t8 == nil:func(unsafe.Pointer, uintptr, uintptr) uintptr      bool
	if t9 goto 3 else 4
3:                                                              if.then P:1 S:0
	t10 = &t2._string [#8]                                         **string
	t11 = *t10                                                      *string
	t12 = *t11                                                       string
	t13 = "hash of unhashabl...":string + t12                        string
	t14 = changetype errorString <- string (t13)                errorString
	t15 = make interface{} <- errorString (t14)                 interface{}
	panic t15
4:                                                              if.done P:1 S:2
	t16 = isDirectIface(t2)                                            bool
	if t16 goto 5 else 6
5:                                                              if.then P:1 S:0
	t17 = &t0.data [#1]                                     *unsafe.Pointer
	t18 = convert unsafe.Pointer <- *unsafe.Pointer (t17)    unsafe.Pointer
	t19 = &t2.size [#0]                                            *uintptr
	t20 = *t19                                                      uintptr
	t21 = h ^ 33054211828000289:uintptr                             uintptr
	t22 = t8(t18, t20, t21)                                         uintptr
	t23 = 23344194077549503:uintptr * t22                           uintptr
	return t23
6:                                                              if.else P:1 S:0
	t24 = &t0.data [#1]                                     *unsafe.Pointer
	t25 = *t24                                               unsafe.Pointer
	t26 = &t2.size [#0]                                            *uintptr
	t27 = *t26                                                      uintptr
	t28 = h ^ 33054211828000289:uintptr                             uintptr
	t29 = t8(t25, t27, t28)                                         uintptr
	t30 = 23344194077549503:uintptr * t29                           uintptr
	return t30

# Name: runtime.memequal
# Package: runtime
# Location: /usr/local/go/src/runtime/alg.go:177:6
func memequal(p unsafe.Pointer, q unsafe.Pointer, size uintptr) bool:
0:                                                                entry P:0 S:2
	t0 = p == q                                                        bool
	if t0 goto 1 else 2
1:                                                              if.then P:1 S:0
	return true:bool
2:                                                              if.done P:1 S:0
	t1 = memeq(p, q, size)                                             bool
	return t1

# Name: runtime.memequal0
# Package: runtime
# Location: /usr/local/go/src/runtime/alg.go:184:6
func memequal0(p unsafe.Pointer, q unsafe.Pointer, size uintptr) bool:
0:                                                                entry P:0 S:0
	return true:bool

# Name: runtime.memequal8
# Package: runtime
# Location: /usr/local/go/src/runtime/alg.go:187:6
func memequal8(p unsafe.Pointer, q unsafe.Pointer, size uintptr) bool:
0:                                                                entry P:0 S:0
	t0 = convert *int8 <- unsafe.Pointer (p)                          *int8
	t1 = *t0                                                           int8
	t2 = convert *int8 <- unsafe.Pointer (q)                          *int8
	t3 = *t2                                                           int8
	t4 = t1 == t3                                                      bool
	return t4

# Name: runtime.memequal16
# Package: runtime
# Location: /usr/local/go/src/runtime/alg.go:190:6
func memequal16(p unsafe.Pointer, q unsafe.Pointer, size uintptr) bool:
0:                                                                entry P:0 S:0
	t0 = convert *int16 <- unsafe.Pointer (p)                        *int16
	t1 = *t0                                                          int16
	t2 = convert *int16 <- unsafe.Pointer (q)                        *int16
	t3 = *t2                                                          int16
	t4 = t1 == t3                                                      bool
	return t4

# Name: runtime.memequal32
# Package: runtime
# Location: /usr/local/go/src/runtime/alg.go:193:6
func memequal32(p unsafe.Pointer, q unsafe.Pointer, size uintptr) bool:
0:                                                                entry P:0 S:0
	t0 = convert *int32 <- unsafe.Pointer (p)                        *int32
	t1 = *t0                                                          int32
	t2 = convert *int32 <- unsafe.Pointer (q)                        *int32
	t3 = *t2                                                          int32
	t4 = t1 == t3                                                      bool
	return t4

# Name: runtime.memequal64
# Package: runtime
# Location: /usr/local/go/src/runtime/alg.go:196:6
func memequal64(p unsafe.Pointer, q unsafe.Pointer, size uintptr) bool:
0:                                                                entry P:0 S:0
	t0 = convert *int64 <- unsafe.Pointer (p)                        *int64
	t1 = *t0                                                          int64
	t2 = convert *int64 <- unsafe.Pointer (q)                        *int64
	t3 = *t2                                                          int64
	t4 = t1 == t3                                                      bool
	return t4

# Name: runtime.memequal128
# Package: runtime
# Location: /usr/local/go/src/runtime/alg.go:199:6
func memequal128(p unsafe.Pointer, q unsafe.Pointer, size uintptr) bool:
0:                                                                entry P:0 S:0
	t0 = convert *[2]int64 <- unsafe.Pointer (p)                  *[2]int64
	t1 = *t0                                                       [2]int64
	t2 = convert *[2]int64 <- unsafe.Pointer (q)                  *[2]int64
	t3 = *t2                                                       [2]int64
	t4 = t1 == t3                                                      bool
	return t4

# Name: runtime.f32equal
# Package: runtime
# Location: /usr/local/go/src/runtime/alg.go:202:6
func f32equal(p unsafe.Pointer, q unsafe.Pointer, size uintptr) bool:
0:                                                                entry P:0 S:0
	t0 = convert *float32 <- unsafe.Pointer (p)                    *float32
	t1 = *t0                                                        float32
	t2 = convert *float32 <- unsafe.Pointer (q)                    *float32
	t3 = *t2                                                        float32
	t4 = t1 == t3                                                      bool
	return t4

# Name: runtime.f64equal
# Package: runtime
# Location: /usr/local/go/src/runtime/alg.go:205:6
func f64equal(p unsafe.Pointer, q unsafe.Pointer, size uintptr) bool:
0:                                                                entry P:0 S:0
	t0 = convert *float64 <- unsafe.Pointer (p)                    *float64
	t1 = *t0                                                        float64
	t2 = convert *float64 <- unsafe.Pointer (q)                    *float64
	t3 = *t2                                                        float64
	t4 = t1 == t3                                                      bool
	return t4

# Name: runtime.c64equal
# Package: runtime
# Location: /usr/local/go/src/runtime/alg.go:208:6
func c64equal(p unsafe.Pointer, q unsafe.Pointer, size uintptr) bool:
0:                                                                entry P:0 S:0
	t0 = convert *complex64 <- unsafe.Pointer (p)                *complex64
	t1 = *t0                                                      complex64
	t2 = convert *complex64 <- unsafe.Pointer (q)                *complex64
	t3 = *t2                                                      complex64
	t4 = t1 == t3                                                      bool
	return t4

# Name: runtime.c128equal
# Package: runtime
# Location: /usr/local/go/src/runtime/alg.go:211:6
func c128equal(p unsafe.Pointer, q unsafe.Pointer, size uintptr) bool:
0:                                                                entry P:0 S:0
	t0 = convert *complex128 <- unsafe.Pointer (p)              *complex128
	t1 = *t0                                                     complex128
	t2 = convert *complex128 <- unsafe.Pointer (q)              *complex128
	t3 = *t2                                                     complex128
	t4 = t1 == t3                                                      bool
	return t4

# Name: runtime.strequal
# Package: runtime
# Location: /usr/local/go/src/runtime/alg.go:214:6
func strequal(p unsafe.Pointer, q unsafe.Pointer, size uintptr) bool:
0:                                                                entry P:0 S:0
	t0 = convert *string <- unsafe.Pointer (p)                      *string
	t1 = *t0                                                         string
	t2 = convert *string <- unsafe.Pointer (q)                      *string
	t3 = *t2                                                         string
	t4 = t1 == t3                                                      bool
	return t4

# Name: runtime.interequal
# Package: runtime
# Location: /usr/local/go/src/runtime/alg.go:217:6
func interequal(p unsafe.Pointer, q unsafe.Pointer, size uintptr) bool:
0:                                                                entry P:0 S:0
	t0 = convert *interface{f()} <- unsafe.Pointer (p)      *interface{f()}
	t1 = *t0                                                 interface{f()}
	t2 = convert *interface{f()} <- unsafe.Pointer (q)      *interface{f()}
	t3 = *t2                                                 interface{f()}
	t4 = ifaceeq(t1, t3)                                               bool
	return t4

# Name: runtime.nilinterequal
# Package: runtime
# Location: /usr/local/go/src/runtime/alg.go:224:6
func nilinterequal(p unsafe.Pointer, q unsafe.Pointer, size uintptr) bool:
0:                                                                entry P:0 S:0
	t0 = convert *interface{} <- unsafe.Pointer (p)            *interface{}
	t1 = *t0                                                    interface{}
	t2 = convert *interface{} <- unsafe.Pointer (q)            *interface{}
	t3 = *t2                                                    interface{}
	t4 = efaceeq(t1, t3)                                               bool
	return t4

# Name: runtime.efaceeq
# Package: runtime
# Location: /usr/local/go/src/runtime/alg.go:227:6
func efaceeq(p interface{}, q interface{}) bool:
0:                                                                entry P:0 S:2
	t0 = new interface{} (p)                                   *interface{}
	*t0 = p
	t1 = new interface{} (q)                                   *interface{}
	*t1 = q
	t2 = convert unsafe.Pointer <- *interface{} (t0)         unsafe.Pointer
	t3 = convert *eface <- unsafe.Pointer (t2)                       *eface
	t4 = convert unsafe.Pointer <- *interface{} (t1)         unsafe.Pointer
	t5 = convert *eface <- unsafe.Pointer (t4)                       *eface
	t6 = &t3._type [#0]                                             **_type
	t7 = *t6                                                         *_type
	t8 = &t5._type [#0]                                             **_type
	t9 = *t8                                                         *_type
	t10 = t7 != t9                                                     bool
	if t10 goto 1 else 2
1:                                                              if.then P:1 S:0
	return false:bool
2:                                                              if.done P:1 S:2
	t11 = t7 == nil:*_type                                             bool
	if t11 goto 3 else 4
3:                                                              if.then P:1 S:0
	return true:bool
4:                                                              if.done P:1 S:2
	t12 = &t7.alg [#6]                                      *unsafe.Pointer
	t13 = *t12                                               unsafe.Pointer
	t14 = goalg(t13)                                               *typeAlg
	t15 = &t14.equal [#1] *func(unsafe.Pointer, unsafe.Pointer, uintptr) bool
	t16 = *t15           func(unsafe.Pointer, unsafe.Pointer, uintptr) bool
	t17 = t16 == nil:func(unsafe.Pointer, unsafe.Pointer, uintptr) bool bool
	if t17 goto 5 else 6
5:                                                              if.then P:1 S:0
	t18 = &t7._string [#8]                                         **string
	t19 = *t18                                                      *string
	t20 = *t19                                                       string
	t21 = "comparing uncompa...":string + t20                        string
	t22 = changetype errorString <- string (t21)                errorString
	t23 = make interface{} <- errorString (t22)                 interface{}
	panic t23
6:                                                              if.done P:1 S:2
	t24 = isDirectIface(t7)                                            bool
	if t24 goto 7 else 8
7:                                                              if.then P:1 S:0
	t25 = &t3.data [#1]                                     *unsafe.Pointer
	t26 = convert unsafe.Pointer <- *unsafe.Pointer (t25)    unsafe.Pointer
	t27 = noescape(t26)                                      unsafe.Pointer
	t28 = &t5.data [#1]                                     *unsafe.Pointer
	t29 = convert unsafe.Pointer <- *unsafe.Pointer (t28)    unsafe.Pointer
	t30 = noescape(t29)                                      unsafe.Pointer
	t31 = &t7.size [#0]                                            *uintptr
	t32 = *t31                                                      uintptr
	t33 = t16(t27, t30, t32)                                           bool
	return t33
8:                                                              if.done P:1 S:0
	t34 = &t3.data [#1]                                     *unsafe.Pointer
	t35 = *t34                                               unsafe.Pointer
	t36 = &t5.data [#1]                                     *unsafe.Pointer
	t37 = *t36                                               unsafe.Pointer
	t38 = &t7.size [#0]                                            *uintptr
	t39 = *t38                                                      uintptr
	t40 = t16(t35, t37, t39)                                           bool
	return t40

# Name: runtime.ifaceeq
# Package: runtime
# Location: /usr/local/go/src/runtime/alg.go:246:6
func ifaceeq(p interface{f()}, q interface{f()}) bool:
0:                                                                entry P:0 S:2
	t0 = new interface{f()} (p)                             *interface{f()}
	*t0 = p
	t1 = new interface{f()} (q)                             *interface{f()}
	*t1 = q
	t2 = convert unsafe.Pointer <- *interface{f()} (t0)      unsafe.Pointer
	t3 = convert *iface <- unsafe.Pointer (t2)                       *iface
	t4 = convert unsafe.Pointer <- *interface{f()} (t1)      unsafe.Pointer
	t5 = convert *iface <- unsafe.Pointer (t4)                       *iface
	t6 = &t3.tab [#0]                                                **itab
	t7 = *t6                                                          *itab
	t8 = &t5.tab [#0]                                                **itab
	t9 = *t8                                                          *itab
	t10 = t7 != t9                                                     bool
	if t10 goto 1 else 2
1:                                                              if.then P:1 S:0
	return false:bool
2:                                                              if.done P:1 S:2
	t11 = t7 == nil:*itab                                              bool
	if t11 goto 3 else 4
3:                                                              if.then P:1 S:0
	return true:bool
4:                                                              if.done P:1 S:2
	t12 = &t7._type [#1]                                            **_type
	t13 = *t12                                                       *_type
	t14 = &t13.alg [#6]                                     *unsafe.Pointer
	t15 = *t14                                               unsafe.Pointer
	t16 = goalg(t15)                                               *typeAlg
	t17 = &t16.equal [#1] *func(unsafe.Pointer, unsafe.Pointer, uintptr) bool
	t18 = *t17           func(unsafe.Pointer, unsafe.Pointer, uintptr) bool
	t19 = t18 == nil:func(unsafe.Pointer, unsafe.Pointer, uintptr) bool bool
	if t19 goto 5 else 6
5:                                                              if.then P:1 S:0
	t20 = &t13._string [#8]                                        **string
	t21 = *t20                                                      *string
	t22 = *t21                                                       string
	t23 = "comparing uncompa...":string + t22                        string
	t24 = changetype errorString <- string (t23)                errorString
	t25 = make interface{} <- errorString (t24)                 interface{}
	panic t25
6:                                                              if.done P:1 S:2
	t26 = isDirectIface(t13)                                           bool
	if t26 goto 7 else 8
7:                                                              if.then P:1 S:0
	t27 = &t3.data [#1]                                     *unsafe.Pointer
	t28 = convert unsafe.Pointer <- *unsafe.Pointer (t27)    unsafe.Pointer
	t29 = noescape(t28)                                      unsafe.Pointer
	t30 = &t5.data [#1]                                     *unsafe.Pointer
	t31 = convert unsafe.Pointer <- *unsafe.Pointer (t30)    unsafe.Pointer
	t32 = noescape(t31)                                      unsafe.Pointer
	t33 = &t13.size [#0]                                           *uintptr
	t34 = *t33                                                      uintptr
	t35 = t18(t29, t32, t34)                                           bool
	return t35
8:                                                              if.done P:1 S:0
	t36 = &t3.data [#1]                                     *unsafe.Pointer
	t37 = *t36                                               unsafe.Pointer
	t38 = &t5.data [#1]                                     *unsafe.Pointer
	t39 = *t38                                               unsafe.Pointer
	t40 = &t13.size [#0]                                           *uintptr
	t41 = *t40                                                      uintptr
	t42 = t18(t37, t39, t41)                                           bool
	return t42

# Name: runtime.haveGoodHash
# Package: runtime
# Location: /usr/local/go/src/runtime/alg.go:270:6
func haveGoodHash() bool:
0:                                                                entry P:0 S:0
	t0 = *useAeshash                                                   bool
	return t0

# Name: runtime.stringHash
# Package: runtime
# Location: /usr/local/go/src/runtime/alg.go:274:6
func stringHash(s string, seed uintptr) uintptr:
0:                                                                entry P:0 S:0
	t0 = new string (s)                                             *string
	*t0 = s
	t1 = &algarray[14:int]                                         *typeAlg
	t2 = &t1.hash [#0]      *func(unsafe.Pointer, uintptr, uintptr) uintptr
	t3 = *t2                 func(unsafe.Pointer, uintptr, uintptr) uintptr
	t4 = convert unsafe.Pointer <- *string (t0)              unsafe.Pointer
	t5 = noescape(t4)                                        unsafe.Pointer
	t6 = t3(t5, 16:uintptr, seed)                                   uintptr
	return t6

# Name: runtime.bytesHash
# Package: runtime
# Location: /usr/local/go/src/runtime/alg.go:278:6
func bytesHash(b []byte, seed uintptr) uintptr:
0:                                                                entry P:0 S:0
	t0 = new []byte (b)                                             *[]byte
	*t0 = b
	t1 = convert unsafe.Pointer <- *[]byte (t0)              unsafe.Pointer
	t2 = convert *sliceStruct <- unsafe.Pointer (t1)           *sliceStruct
	t3 = &algarray[0:int]                                          *typeAlg
	t4 = &t3.hash [#0]      *func(unsafe.Pointer, uintptr, uintptr) uintptr
	t5 = *t4                 func(unsafe.Pointer, uintptr, uintptr) uintptr
	t6 = &t2.array [#0]                                     *unsafe.Pointer
	t7 = *t6                                                 unsafe.Pointer
	t8 = &t2.len [#1]                                                  *int
	t9 = *t8                                                            int
	t10 = convert uintptr <- int (t9)                               uintptr
	t11 = t5(t7, t10, seed)                                         uintptr
	return t11

# Name: runtime.int32Hash
# Package: runtime
# Location: /usr/local/go/src/runtime/alg.go:283:6
func int32Hash(i uint32, seed uintptr) uintptr:
0:                                                                entry P:0 S:0
	t0 = new uint32 (i)                                             *uint32
	*t0 = i
	t1 = &algarray[4:int]                                          *typeAlg
	t2 = &t1.hash [#0]      *func(unsafe.Pointer, uintptr, uintptr) uintptr
	t3 = *t2                 func(unsafe.Pointer, uintptr, uintptr) uintptr
	t4 = convert unsafe.Pointer <- *uint32 (t0)              unsafe.Pointer
	t5 = noescape(t4)                                        unsafe.Pointer
	t6 = t3(t5, 4:uintptr, seed)                                    uintptr
	return t6

# Name: runtime.int64Hash
# Package: runtime
# Location: /usr/local/go/src/runtime/alg.go:287:6
func int64Hash(i uint64, seed uintptr) uintptr:
0:                                                                entry P:0 S:0
	t0 = new uint64 (i)                                             *uint64
	*t0 = i
	t1 = &algarray[5:int]                                          *typeAlg
	t2 = &t1.hash [#0]      *func(unsafe.Pointer, uintptr, uintptr) uintptr
	t3 = *t2                 func(unsafe.Pointer, uintptr, uintptr) uintptr
	t4 = convert unsafe.Pointer <- *uint64 (t0)              unsafe.Pointer
	t5 = noescape(t4)                                        unsafe.Pointer
	t6 = t3(t5, 8:uintptr, seed)                                    uintptr
	return t6

# Name: runtime.efaceHash
# Package: runtime
# Location: /usr/local/go/src/runtime/alg.go:291:6
func efaceHash(i interface{}, seed uintptr) uintptr:
0:                                                                entry P:0 S:0
	t0 = new interface{} (i)                                   *interface{}
	*t0 = i
	t1 = &algarray[16:int]                                         *typeAlg
	t2 = &t1.hash [#0]      *func(unsafe.Pointer, uintptr, uintptr) uintptr
	t3 = *t2                 func(unsafe.Pointer, uintptr, uintptr) uintptr
	t4 = convert unsafe.Pointer <- *interface{} (t0)         unsafe.Pointer
	t5 = noescape(t4)                                        unsafe.Pointer
	t6 = t3(t5, 16:uintptr, seed)                                   uintptr
	return t6

# Name: runtime.ifaceHash
# Package: runtime
# Location: /usr/local/go/src/runtime/alg.go:295:6
func ifaceHash(i interface{F()}, seed uintptr) uintptr:
0:                                                                entry P:0 S:0
	t0 = new interface{F()} (i)                             *interface{F()}
	*t0 = i
	t1 = &algarray[15:int]                                         *typeAlg
	t2 = &t1.hash [#0]      *func(unsafe.Pointer, uintptr, uintptr) uintptr
	t3 = *t2                 func(unsafe.Pointer, uintptr, uintptr) uintptr
	t4 = convert unsafe.Pointer <- *interface{F()} (t0)      unsafe.Pointer
	t5 = noescape(t4)                                        unsafe.Pointer
	t6 = t3(t5, 16:uintptr, seed)                                   uintptr
	return t6

# Name: runtime.memclrBytes
# Package: runtime
# Location: /usr/local/go/src/runtime/alg.go:302:6
func memclrBytes(b []byte):
0:                                                                entry P:0 S:0
	t0 = new []byte (b)                                             *[]byte
	*t0 = b
	t1 = convert unsafe.Pointer <- *[]byte (t0)              unsafe.Pointer
	t2 = convert *sliceStruct <- unsafe.Pointer (t1)           *sliceStruct
	t3 = &t2.array [#0]                                     *unsafe.Pointer
	t4 = *t3                                                 unsafe.Pointer
	t5 = &t2.len [#1]                                                  *int
	t6 = *t5                                                            int
	t7 = convert uintptr <- int (t6)                                uintptr
	t8 = memclr(t4, t7)                                                  ()
	return

# Name: runtime.goalg
# Package: runtime
# Location: /usr/local/go/src/runtime/alg.go:308:6
func goalg(a unsafe.Pointer) *typeAlg:
0:                                                                entry P:0 S:0
	t0 = convert *typeAlg <- unsafe.Pointer (a)                    *typeAlg
	return t0

# Name: runtime.init#1
# Package: runtime
# Location: /usr/local/go/src/runtime/alg.go:320:6
func init#1():
0:                                                                entry P:0 S:2
	if false:untyped bool goto 1 else 2
1:                                                              if.then P:1 S:0
	return
2:                                                              if.done P:1 S:2
	t0 = *cpuid_ecx                                                  uint32
	t1 = t0 & 33554432:uint32                                        uint32
	t2 = t1 != 0:uint32                                                bool
	if t2 goto 6 else 4
3:                                                              if.then P:1 S:2
	*useAeshash = true:bool
	t3 = &algarray[0:int]                                          *typeAlg
	t4 = &t3.hash [#0]      *func(unsafe.Pointer, uintptr, uintptr) uintptr
	*t4 = aeshash
	t5 = &algarray[2:int]                                          *typeAlg
	t6 = &t5.hash [#0]      *func(unsafe.Pointer, uintptr, uintptr) uintptr
	*t6 = aeshash
	t7 = &algarray[3:int]                                          *typeAlg
	t8 = &t7.hash [#0]      *func(unsafe.Pointer, uintptr, uintptr) uintptr
	*t8 = aeshash
	t9 = &algarray[4:int]                                          *typeAlg
	t10 = &t9.hash [#0]     *func(unsafe.Pointer, uintptr, uintptr) uintptr
	*t10 = aeshash32
	t11 = &algarray[5:int]                                         *typeAlg
	t12 = &t11.hash [#0]    *func(unsafe.Pointer, uintptr, uintptr) uintptr
	*t12 = aeshash64
	t13 = &algarray[6:int]                                         *typeAlg
	t14 = &t13.hash [#0]    *func(unsafe.Pointer, uintptr, uintptr) uintptr
	*t14 = aeshash
	t15 = &algarray[14:int]                                        *typeAlg
	t16 = &t15.hash [#0]    *func(unsafe.Pointer, uintptr, uintptr) uintptr
	*t16 = aeshashstr
	t17 = new unsafe.Pointer (rnd)                          *unsafe.Pointer
	t18 = new int32 (n)                                              *int32
	t19 = get_random_data(t17, t18)                                      ()
	t20 = *t18                                                        int32
	t21 = t20 > 32:int32                                               bool
	if t21 goto 7 else 8
4:                                                              if.done P:5 S:0
	return
5:                                                            cond.true P:1 S:2
	t22 = *cpuid_ecx                                                 uint32
	t23 = t22 & 524288:uint32                                        uint32
	t24 = t23 != 0:uint32                                              bool
	if t24 goto 3 else 4
6:                                                            cond.true P:1 S:2
	t25 = *cpuid_ecx                                                 uint32
	t26 = t25 & 512:uint32                                           uint32
	t27 = t26 != 0:uint32                                              bool
	if t27 goto 5 else 4
7:                                                              if.then P:1 S:1
	*t18 = 32:int32
	jump 8
8:                                                              if.done P:2 S:2
	t28 = &aeskeysched[0:int]                                         *byte
	t29 = convert unsafe.Pointer <- *byte (t28)              unsafe.Pointer
	t30 = *t17                                               unsafe.Pointer
	t31 = *t18                                                        int32
	t32 = convert uintptr <- int32 (t31)                            uintptr
	t33 = memmove(t29, t30, t32)                                         ()
	t34 = *t18                                                        int32
	t35 = t34 < 32:int32                                               bool
	if t35 goto 9 else 4
9:                                                              if.then P:1 S:1
	t36 = nanotime()                                                  int64
	jump 11
10:                                                            for.body P:1 S:1
	t37 = *t18                                                        int32
	t38 = convert int <- int32 (t37)                                    int
	t39 = &aeskeysched[t38]                                           *byte
	t40 = *t18                                                        int32
	t41 = t40 % 8:int32                                               int32
	t42 = 8:int32 * t41                                               int32
	t43 = convert uint <- int32 (t42)                                  uint
	t44 = t36 >> t43                                                  int64
	t45 = convert byte <- int64 (t44)                                  byte
	*t39 = t45
	t46 = *t18                                                        int32
	t47 = t46 + 1:int32                                               int32
	*t18 = t47
	jump 11
11:                                                            for.loop P:2 S:2
	t48 = *t18                                                        int32
	t49 = t48 < 32:int32                                               bool
	if t49 goto 10 else 4

# Name: runtime.cgocall
# Package: runtime
# Location: /usr/local/go/src/runtime/cgocall.go:86:6
func cgocall(fn unsafe.Pointer, arg unsafe.Pointer):
0:                                                                entry P:0 S:0
	t0 = cgocall_errno(fn, arg)                                       int32
	return

# Name: runtime.cgocall_errno
# Package: runtime
# Location: /usr/local/go/src/runtime/cgocall.go:91:6
# Recover: 12
func cgocall_errno(fn unsafe.Pointer, arg unsafe.Pointer) int32:
0:                                                                entry P:0 S:2
	t0 = *iscgo                                                        bool
	if t0 goto 2 else 4
1:                                                              if.then P:1 S:1
	t1 = gothrow("cgocall unavailable":string)                           ()
	jump 2
2:                                                              if.done P:4 S:2
	t2 = fn == nil:unsafe.Pointer                                      bool
	if t2 goto 5 else 6
3:                                                            cond.true P:1 S:2
	if true:bool goto 1 else 2
4:                                                            cond.true P:1 S:2
	if true:bool goto 3 else 2
5:                                                              if.then P:1 S:1
	t3 = gothrow("cgocall nil":string)                                   ()
	jump 6
6:                                                              if.done P:2 S:2
	if false:untyped bool goto 7 else 8
7:                                                              if.then P:1 S:1
	t4 = convert unsafe.Pointer <- *uint64 (racecgosync)     unsafe.Pointer
	t5 = racereleasemerge(t4)                                            ()
	jump 8
8:                                                              if.done P:2 S:2
	t6 = *needextram                                                 uint32
	t7 = t6 == 1:uint32                                                bool
	if t7 goto 11 else 10
9:                                                              if.then P:1 S:1
	t8 = onM(newextram)                                                  ()
	jump 10
10:                                                             if.done P:3 S:0
	t9 = lockOSThread()                                                  ()
	t10 = getg()                                                         *g
	t11 = &t10.m [#21]                                                  **m
	t12 = *t11                                                           *m
	t13 = &t12.ncgocall [#22]                                       *uint64
	t14 = *t13                                                       uint64
	t15 = t14 + 1:uint64                                             uint64
	*t13 = t15
	t16 = &t12.ncgo [#23]                                            *int32
	t17 = *t16                                                        int32
	t18 = t17 + 1:int32                                               int32
	*t16 = t18
	defer endcgo(t12)
	t19 = entersyscall()                                                 ()
	t20 = asmcgocall_errno(fn, arg)                                   int32
	t21 = exitsyscall()                                                  ()
	rundefers
	return t20
11:                                                           cond.true P:1 S:2
	t22 = cas(needextram, 1:uint32, 0:uint32)                          bool
	if t22 goto 9 else 10
12:                                                             recover P:0 S:0
	return 0:int32

# Name: runtime.endcgo
# Package: runtime
# Location: /usr/local/go/src/runtime/cgocall.go:138:6
func endcgo(mp *m):
0:                                                                entry P:0 S:2
	t0 = &mp.ncgo [#23]                                              *int32
	t1 = *t0                                                          int32
	t2 = t1 - 1:int32                                                 int32
	*t0 = t2
	t3 = &mp.ncgo [#23]                                              *int32
	t4 = *t3                                                          int32
	t5 = t4 == 0:int32                                                 bool
	if t5 goto 1 else 2
1:                                                              if.then P:1 S:1
	t6 = &mp.cgomal [#24]                                          **cgomal
	*t6 = nil:*cgomal
	jump 2
2:                                                              if.done P:2 S:2
	if false:untyped bool goto 3 else 4
3:                                                              if.then P:1 S:1
	t7 = convert unsafe.Pointer <- *uint64 (racecgosync)     unsafe.Pointer
	t8 = raceacquire(t7)                                                 ()
	jump 4
4:                                                              if.done P:2 S:0
	t9 = unlockOSThread()                                                ()
	return

# Name: runtime.cmalloc
# Package: runtime
# Location: /usr/local/go/src/runtime/cgocall.go:160:6
func cmalloc(n uintptr) unsafe.Pointer:
0:                                                                entry P:0 S:2
	t0 = new struct{n uint64; ret unsafe.Pointer} (args) *struct{n uint64; ret unsafe.Pointer}
	t1 = &t0.n [#0]                                                 *uint64
	t2 = convert uint64 <- uintptr (n)                               uint64
	*t1 = t2
	t3 = *cgoMalloc                                          unsafe.Pointer
	t4 = convert unsafe.Pointer <- *struct{n uint64; ret unsafe.Pointer} (t0) unsafe.Pointer
	t5 = cgocall(t3, t4)                                                 ()
	t6 = &t0.ret [#1]                                       *unsafe.Pointer
	t7 = *t6                                                 unsafe.Pointer
	t8 = t7 == nil:unsafe.Pointer                                      bool
	if t8 goto 1 else 2
1:                                                              if.then P:1 S:1
	t9 = gothrow("C malloc failed":string)                               ()
	jump 2
2:                                                              if.done P:2 S:0
	t10 = &t0.ret [#1]                                      *unsafe.Pointer
	t11 = *t10                                               unsafe.Pointer
	return t11

# Name: runtime.cfree
# Package: runtime
# Location: /usr/local/go/src/runtime/cgocall.go:173:6
func cfree(p unsafe.Pointer):
0:                                                                entry P:0 S:0
	t0 = *cgoFree                                            unsafe.Pointer
	t1 = cgocall(t0, p)                                                  ()
	return

# Name: runtime.cgocallbackg
# Package: runtime
# Location: /usr/local/go/src/runtime/cgocall.go:179:6
func cgocallbackg():
0:                                                                entry P:0 S:2
	t0 = getg()                                                          *g
	t1 = &t0.m [#21]                                                    **m
	t2 = *t1                                                             *m
	t3 = &t2.curg [#6]                                                  **g
	t4 = *t3                                                             *g
	t5 = t0 != t4                                                      bool
	if t5 goto 1 else 2
1:                                                              if.then P:1 S:1
	t6 = println("runtime: bad g in...":string)                          ()
	t7 = exit(2:int32)                                                   ()
	jump 2
2:                                                              if.done P:2 S:0
	t8 = &t0.syscallsp [#6]                                        *uintptr
	t9 = *t8                                                        uintptr
	t10 = convert unsafe.Pointer <- uintptr (t9)             unsafe.Pointer
	t11 = &t0.syscallpc [#7]                                       *uintptr
	t12 = *t11                                                      uintptr
	t13 = exitsyscall()                                                  ()
	t14 = cgocallbackg1()                                                ()
	t15 = reentersyscall(t12, t10)                                       ()
	return

# Name: runtime.cgocallbackg1
# Package: runtime
# Location: /usr/local/go/src/runtime/cgocall.go:198:6
# Recover: 3
func cgocallbackg1():
0:                                                                entry P:0 S:2
	t0 = getg()                                                          *g
	t1 = &t0.m [#21]                                                    **m
	t2 = *t1                                                             *m
	t3 = &t2.needextram [#41]                                         *bool
	t4 = *t3                                                           bool
	if t4 goto 1 else 2
1:                                                              if.then P:1 S:1
	t5 = &t0.m [#21]                                                    **m
	t6 = *t5                                                             *m
	t7 = &t6.needextram [#41]                                         *bool
	*t7 = false:bool
	t8 = onM(newextram)                                                  ()
	jump 2
2:                                                              if.done P:2 S:2
	t9 = new bool (restore)                                           *bool
	*t9 = true:bool
	defer unwindm(t9)
	if false:untyped bool goto 4 else 5
3:                                                              recover P:0 S:0
	return
4:                                                              if.then P:1 S:1
	t10 = convert unsafe.Pointer <- *uint64 (racecgosync)    unsafe.Pointer
	t11 = raceacquire(t10)                                               ()
	jump 5
5:                                                              if.done P:2 S:2
	t12 = &t0.m [#21]                                                   **m
	t13 = *t12                                                           *m
	t14 = &t13.g0 [#0]                                                  **g
	t15 = *t14                                                           *g
	t16 = &t15.sched [#5]                                            *gobuf
	t17 = &t16.sp [#0]                                             *uintptr
	t18 = *t17                                                      uintptr
	t19 = "amd64":string == "arm":string                               bool
	if t19 goto 7 else 9
6:                                                          switch.done P:4 S:2
	t20 = phi [7: t32, 8: t35, 10: t39, 12: nil:*args] #cb            *args
	t21 = &t20.fn [#0]                                            **funcval
	t22 = *t21                                                     *funcval
	t23 = convert unsafe.Pointer <- *funcval (t22)           unsafe.Pointer
	t24 = &t20.arg [#1]                                     *unsafe.Pointer
	t25 = *t24                                               unsafe.Pointer
	t26 = &t20.argsize [#2]                                        *uintptr
	t27 = *t26                                                      uintptr
	t28 = convert uint32 <- uintptr (t27)                            uint32
	t29 = reflectcall(t23, t25, t28, 0:uint32)                           ()
	if false:untyped bool goto 13 else 14
7:                                                          switch.body P:1 S:1
	t30 = t18 + 32:uintptr                                          uintptr
	t31 = convert unsafe.Pointer <- uintptr (t30)            unsafe.Pointer
	t32 = convert *args <- unsafe.Pointer (t31)                       *args
	jump 6
8:                                                          switch.body P:1 S:1
	t33 = t18 + 16:uintptr                                          uintptr
	t34 = convert unsafe.Pointer <- uintptr (t33)            unsafe.Pointer
	t35 = convert *args <- unsafe.Pointer (t34)                       *args
	jump 6
9:                                                          switch.next P:1 S:2
	t36 = "amd64":string == "amd64":string                             bool
	if t36 goto 8 else 11
10:                                                         switch.body P:1 S:1
	t37 = t18 + 32:uintptr                                          uintptr
	t38 = convert unsafe.Pointer <- uintptr (t37)            unsafe.Pointer
	t39 = convert *args <- unsafe.Pointer (t38)                       *args
	jump 6
11:                                                         switch.next P:1 S:2
	t40 = "amd64":string == "386":string                               bool
	if t40 goto 10 else 12
12:                                                         switch.next P:1 S:1
	t41 = gothrow("cgocallbackg is u...":string)                         ()
	jump 6
13:                                                             if.then P:1 S:1
	t42 = convert unsafe.Pointer <- *uint64 (racecgosync)    unsafe.Pointer
	t43 = racereleasemerge(t42)                                          ()
	jump 14
14:                                                             if.done P:2 S:0
	*t9 = false:bool
	rundefers
	return

# Name: runtime.unwindm
# Package: runtime
# Location: /usr/local/go/src/runtime/cgocall.go:250:6
func unwindm(restore *bool):
0:                                                                entry P:0 S:2
	t0 = *restore                                                      bool
	if t0 goto 2 else 1
1:                                                              if.then P:1 S:0
	return
2:                                                              if.done P:1 S:2
	t1 = acquirem()                                                      *m
	t2 = &t1.g0 [#0]                                                    **g
	t3 = *t2                                                             *g
	t4 = &t3.sched [#5]                                              *gobuf
	t5 = "amd64":string == "386":string                                bool
	if t5 goto 4 else 6
3:                                                          switch.done P:3 S:0
	t6 = releasem(t1)                                                    ()
	return
4:                                                          switch.body P:2 S:1
	t7 = &t4.sp [#0]                                               *uintptr
	t8 = &t4.sp [#0]                                               *uintptr
	t9 = *t8                                                        uintptr
	t10 = convert unsafe.Pointer <- uintptr (t9)             unsafe.Pointer
	t11 = convert *uintptr <- unsafe.Pointer (t10)                 *uintptr
	t12 = *t11                                                      uintptr
	*t7 = t12
	jump 3
5:                                                          switch.body P:1 S:1
	t13 = &t4.sp [#0]                                              *uintptr
	t14 = &t4.sp [#0]                                              *uintptr
	t15 = *t14                                                      uintptr
	t16 = t15 + 4:uintptr                                           uintptr
	t17 = convert unsafe.Pointer <- uintptr (t16)            unsafe.Pointer
	t18 = convert *uintptr <- unsafe.Pointer (t17)                 *uintptr
	t19 = *t18                                                      uintptr
	*t13 = t19
	jump 3
6:                                                          switch.next P:1 S:2
	t20 = "amd64":string == "amd64":string                             bool
	if t20 goto 4 else 7
7:                                                          switch.next P:1 S:2
	t21 = "amd64":string == "arm":string                               bool
	if t21 goto 5 else 8
8:                                                          switch.next P:1 S:1
	t22 = gothrow("unwindm not imple...":string)                         ()
	jump 3

# Name: runtime.badcgocallback
# Package: runtime
# Location: /usr/local/go/src/runtime/cgocall.go:270:6
func badcgocallback():
0:                                                                entry P:0 S:0
	t0 = gothrow("misaligned stack ...":string)                          ()
	return

# Name: runtime.cgounimpl
# Package: runtime
# Location: /usr/local/go/src/runtime/cgocall.go:275:6
func cgounimpl():
0:                                                                entry P:0 S:0
	t0 = gothrow("cgo not implemented":string)                           ()
	return

# Name: runtime._cgo_allocate_internal
# Package: runtime
# Location: /usr/local/go/src/runtime/cgocallback.go:23:6
func _cgo_allocate_internal(len uintptr) unsafe.Pointer:
0:                                                                entry P:0 S:2
	t0 = len == 0:uintptr                                              bool
	if t0 goto 1 else 2
1:                                                              if.then P:1 S:1
	jump 2
2:                                                              if.done P:2 S:0
	t1 = phi [0: len, 1: 1:uintptr] #len                            uintptr
	t2 = t1 + 8:uintptr                                             uintptr
	t3 = t2 - 1:uintptr                                             uintptr
	t4 = t3 / 8:uintptr                                             uintptr
	t5 = make []unsafe.Pointer t4 t4                       []unsafe.Pointer
	t6 = &t5[0:int]                                         *unsafe.Pointer
	t7 = convert unsafe.Pointer <- *unsafe.Pointer (t6)      unsafe.Pointer
	t8 = new cgomal (new)                                           *cgomal
	t9 = &t8.alloc [#1]                                     *unsafe.Pointer
	*t9 = t7
	t10 = getg()                                                         *g
	t11 = &t8.next [#0]                                            **cgomal
	t12 = &t10.m [#21]                                                  **m
	t13 = *t12                                                           *m
	t14 = &t13.cgomal [#24]                                        **cgomal
	t15 = *t14                                                      *cgomal
	*t11 = t15
	t16 = &t10.m [#21]                                                  **m
	t17 = *t16                                                           *m
	t18 = &t17.cgomal [#24]                                        **cgomal
	*t18 = t8
	return t7

# Name: runtime._cgo_panic_internal
# Package: runtime
# Location: /usr/local/go/src/runtime/cgocallback.go:38:6
func _cgo_panic_internal(p *byte):
0:                                                                entry P:0 S:0
	t0 = gostringnocopy(p)                                           string
	t1 = make interface{} <- string (t0)                        interface{}
	panic t1

# Name: runtime.makechan
# Package: runtime
# Location: /usr/local/go/src/runtime/chan.go:19:6
func makechan(t *chantype, size int64) *hchan:
0:                                                                entry P:0 S:2
	t0 = &t.elem [#1]                                               **_type
	t1 = *t0                                                         *_type
	t2 = &t1.size [#0]                                             *uintptr
	t3 = *t2                                                        uintptr
	t4 = t3 >= 65536:uintptr                                           bool
	if t4 goto 1 else 2
1:                                                              if.then P:1 S:1
	t5 = gothrow("makechan: invalid...":string)                          ()
	jump 2
2:                                                              if.done P:2 S:2
	if false:untyped bool goto 3 else 5
3:                                                              if.then P:2 S:1
	t6 = gothrow("makechan: bad ali...":string)                          ()
	jump 4
4:                                                              if.done P:2 S:2
	t7 = size < 0:int64                                                bool
	if t7 goto 6 else 9
5:                                                           cond.false P:1 S:2
	t8 = &t1.align [#3]                                              *uint8
	t9 = *t8                                                          uint8
	t10 = t9 > 8:uint8                                                 bool
	if t10 goto 3 else 4
6:                                                              if.then P:3 S:0
	t11 = make interface{} <- string ("makechan: size ou...":string) interface{}
	panic t11
7:                                                              if.done P:2 S:2
	t12 = &t1.kind [#5]                                              *uint8
	t13 = *t12                                                        uint8
	t14 = t13 & 128:uint8                                             uint8
	t15 = t14 != 0:uint8                                               bool
	if t15 goto 11 else 14
8:                                                           cond.false P:1 S:2
	t16 = &t1.size [#0]                                            *uintptr
	t17 = *t16                                                      uintptr
	t18 = t17 > 0:uintptr                                              bool
	if t18 goto 10 else 7
9:                                                           cond.false P:1 S:2
	t19 = convert uintptr <- int64 (size)                           uintptr
	t20 = convert int64 <- uintptr (t19)                              int64
	t21 = t20 != size                                                  bool
	if t21 goto 6 else 8
10:                                                           cond.true P:1 S:2
	t22 = convert uintptr <- int64 (size)                           uintptr
	t23 = *maxmem                                                   uintptr
	t24 = t23 - 96:uintptr                                          uintptr
	t25 = &t1.size [#0]                                            *uintptr
	t26 = *t25                                                      uintptr
	t27 = t24 / t26                                                 uintptr
	t28 = t22 > t27                                                    bool
	if t28 goto 6 else 7
11:                                                             if.then P:2 S:2
	t29 = convert uintptr <- int64 (size)                           uintptr
	t30 = &t1.size [#0]                                            *uintptr
	t31 = *t30                                                      uintptr
	t32 = t29 * t31                                                 uintptr
	t33 = 96:uintptr + t32                                          uintptr
	t34 = mallocgc(t33, nil:*_type, 1:uint32)                unsafe.Pointer
	t35 = convert *hchan <- unsafe.Pointer (t34)                     *hchan
	t36 = size > 0:int64                                               bool
	if t36 goto 17 else 16
12:                                                             if.done P:3 S:2
	t37 = phi [15: t35, 13: t45, 16: t35] #c                         *hchan
	t38 = &t37.elemsize [#3]                                        *uint16
	t39 = &t1.size [#0]                                            *uintptr
	t40 = *t39                                                      uintptr
	t41 = convert uint16 <- uintptr (t40)                            uint16
	*t38 = t41
	t42 = &t37.elemtype [#5]                                        **_type
	*t42 = t1
	t43 = &t37.dataqsiz [#1]                                          *uint
	t44 = convert uint <- int64 (size)                                 uint
	*t43 = t44
	if false:untyped bool goto 18 else 19
13:                                                             if.else P:1 S:1
	t45 = new hchan (new)                                            *hchan
	t46 = &t45.buf [#2]                                              **byte
	t47 = convert uintptr <- int64 (size)                           uintptr
	t48 = newarray(t1, t47)                                  unsafe.Pointer
	t49 = convert *uint8 <- unsafe.Pointer (t48)                     *uint8
	*t46 = t49
	jump 12
14:                                                          cond.false P:1 S:2
	t50 = size == 0:int64                                              bool
	if t50 goto 11 else 13
15:                                                             if.then P:1 S:1
	t51 = &t35.buf [#2]                                              **byte
	t52 = convert unsafe.Pointer <- *hchan (t35)             unsafe.Pointer
	t53 = add(t52, 96:uintptr)                               unsafe.Pointer
	t54 = convert *uint8 <- unsafe.Pointer (t53)                     *uint8
	*t51 = t54
	jump 12
16:                                                             if.else P:2 S:1
	t55 = &t35.buf [#2]                                              **byte
	t56 = convert unsafe.Pointer <- *hchan (t35)             unsafe.Pointer
	t57 = convert *uint8 <- unsafe.Pointer (t56)                     *uint8
	*t55 = t57
	jump 12
17:                                                           cond.true P:1 S:2
	t58 = &t1.size [#0]                                            *uintptr
	t59 = *t58                                                      uintptr
	t60 = t59 != 0:uintptr                                             bool
	if t60 goto 15 else 16
18:                                                             if.then P:1 S:1
	t61 = &t1.size [#0]                                            *uintptr
	t62 = *t61                                                      uintptr
	t63 = &t1.alg [#6]                                      *unsafe.Pointer
	t64 = *t63                                               unsafe.Pointer
	t65 = print("makechan: chan=":string, t37, "; elemsize=":string, t62, "; elemalg=":string, t64, "; dataqsiz=":string, size, "\n":string) ()
	jump 19
19:                                                             if.done P:2 S:0
	return t37

# Name: runtime.chanbuf
# Package: runtime
# Location: /usr/local/go/src/runtime/chan.go:61:6
func chanbuf(c *hchan, i uint) unsafe.Pointer:
0:                                                                entry P:0 S:0
	t0 = &c.buf [#2]                                                 **byte
	t1 = *t0                                                          *byte
	t2 = convert unsafe.Pointer <- *byte (t1)                unsafe.Pointer
	t3 = convert uintptr <- uint (i)                                uintptr
	t4 = &c.elemsize [#3]                                           *uint16
	t5 = *t4                                                         uint16
	t6 = convert uintptr <- uint16 (t5)                             uintptr
	t7 = t3 * t6                                                    uintptr
	t8 = add(t2, t7)                                         unsafe.Pointer
	return t8

# Name: runtime.chansend1
# Package: runtime
# Location: /usr/local/go/src/runtime/chan.go:67:6
func chansend1(t *chantype, c *hchan, elem unsafe.Pointer):
0:                                                                entry P:0 S:0
	t0 = new *chantype (t)                                       **chantype
	*t0 = t
	t1 = *t0                                                      *chantype
	t2 = convert unsafe.Pointer <- **chantype (t0)           unsafe.Pointer
	t3 = getcallerpc(t2)                                            uintptr
	t4 = chansend(t1, c, elem, true:bool, t3)                          bool
	return

# Name: runtime.chansend
# Package: runtime
# Location: /usr/local/go/src/runtime/chan.go:83:6
func chansend(t *chantype, c *hchan, ep unsafe.Pointer, block bool, callerpc uintptr) bool:
0:                                                                entry P:0 S:2
	if false:untyped bool goto 1 else 2
1:                                                              if.then P:1 S:1
	t0 = &t.elem [#1]                                               **_type
	t1 = *t0                                                         *_type
	t2 = make interface{} <- func(t *chantype, c *hchan, ep unsafe.Pointer, block bool, callerpc uintptr) bool (chansend) interface{}
	t3 = funcPC(t2)                                                 uintptr
	t4 = raceReadObjectPC(t1, ep, callerpc, t3)                          ()
	jump 2
2:                                                              if.done P:2 S:2
	t5 = c == nil:*hchan                                               bool
	if t5 goto 3 else 4
3:                                                              if.then P:1 S:2
	if block goto 6 else 5
4:                                                              if.done P:2 S:2
	if false:untyped bool goto 7 else 8
5:                                                              if.then P:1 S:0
	return false:bool
6:                                                              if.done P:1 S:1
	t6 = gopark(nil:unsafe.Pointer, nil:unsafe.Pointer, "chan send (nil chan)":string) ()
	t7 = gothrow("unreachable":string)                                   ()
	jump 4
7:                                                              if.then P:1 S:1
	t8 = print("chansend: chan=":string, c, "\n":string)                 ()
	jump 8
8:                                                              if.done P:2 S:2
	if false:untyped bool goto 9 else 10
9:                                                              if.then P:1 S:1
	t9 = convert unsafe.Pointer <- *hchan (c)                unsafe.Pointer
	t10 = make interface{} <- func(t *chantype, c *hchan, ep unsafe.Pointer, block bool, callerpc uintptr) bool (chansend) interface{}
	t11 = funcPC(t10)                                               uintptr
	t12 = racereadpc(t9, callerpc, t11)                                  ()
	jump 10
10:                                                             if.done P:2 S:2
	if block goto 12 else 14
11:                                                             if.then P:2 S:0
	return false:bool
12:                                                             if.done P:4 S:2
	t13 = *blockprofilerate                                          uint64
	t14 = t13 > 0:uint64                                               bool
	if t14 goto 18 else 19
13:                                                           cond.true P:1 S:2
	t15 = &c.dataqsiz [#1]                                            *uint
	t16 = *t15                                                         uint
	t17 = t16 == 0:uint                                                bool
	if t17 goto 16 else 15
14:                                                           cond.true P:1 S:2
	t18 = &c.closed [#4]                                            *uint32
	t19 = *t18                                                       uint32
	t20 = t19 == 0:uint32                                              bool
	if t20 goto 13 else 12
15:                                                          cond.false P:2 S:2
	t21 = &c.dataqsiz [#1]                                            *uint
	t22 = *t21                                                         uint
	t23 = t22 > 0:uint                                                 bool
	if t23 goto 17 else 12
16:                                                           cond.true P:1 S:2
	t24 = &c.recvq [#8]                                              *waitq
	t25 = &t24.first [#0]                                           **sudog
	t26 = *t25                                                       *sudog
	t27 = t26 == nil:*sudog                                            bool
	if t27 goto 11 else 15
17:                                                           cond.true P:1 S:2
	t28 = &c.qcount [#0]                                              *uint
	t29 = *t28                                                         uint
	t30 = &c.dataqsiz [#1]                                            *uint
	t31 = *t30                                                         uint
	t32 = t29 == t31                                                   bool
	if t32 goto 11 else 12
18:                                                             if.then P:1 S:1
	t33 = cputicks()                                                  int64
	jump 19
19:                                                             if.done P:2 S:2
	t34 = phi [12: 0:int64, 18: t33] #t0                              int64
	t35 = &c.lock [#10]                                              *mutex
	t36 = lock(t35)                                                      ()
	t37 = &c.closed [#4]                                            *uint32
	t38 = *t37                                                       uint32
	t39 = t38 != 0:uint32                                              bool
	if t39 goto 20 else 21
20:                                                             if.then P:1 S:0
	t40 = &c.lock [#10]                                              *mutex
	t41 = unlock(t40)                                                    ()
	t42 = make interface{} <- string ("send on closed ch...":string) interface{}
	panic t42
21:                                                             if.done P:1 S:2
	t43 = &c.dataqsiz [#1]                                            *uint
	t44 = *t43                                                         uint
	t45 = t44 == 0:uint                                                bool
	if t45 goto 22 else 23
22:                                                             if.then P:1 S:2
	t46 = &c.recvq [#8]                                              *waitq
	t47 = (*waitq).dequeue(t46)                                      *sudog
	t48 = t47 != nil:*sudog                                            bool
	if t48 goto 24 else 25
23:                                                             if.done P:1 S:1
	jump 46
24:                                                             if.then P:1 S:2
	if false:untyped bool goto 26 else 27
25:                                                             if.done P:1 S:2
	if block goto 33 else 32
26:                                                             if.then P:1 S:1
	t49 = racesync(c, t47)                                               ()
	jump 27
27:                                                             if.done P:2 S:2
	t50 = &c.lock [#10]                                              *mutex
	t51 = unlock(t50)                                                    ()
	t52 = &t47.g [#0]                                                   **g
	t53 = *t52                                                           *g
	t54 = &t47.elem [#4]                                    *unsafe.Pointer
	t55 = *t54                                               unsafe.Pointer
	t56 = t55 != nil:unsafe.Pointer                                    bool
	if t56 goto 28 else 29
28:                                                             if.then P:1 S:1
	t57 = &t47.elem [#4]                                    *unsafe.Pointer
	t58 = *t57                                               unsafe.Pointer
	t59 = &c.elemsize [#3]                                          *uint16
	t60 = *t59                                                       uint16
	t61 = convert uintptr <- uint16 (t60)                           uintptr
	t62 = memmove(t58, ep, t61)                                          ()
	t63 = &t47.elem [#4]                                    *unsafe.Pointer
	*t63 = nil:unsafe.Pointer
	jump 29
29:                                                             if.done P:2 S:2
	t64 = &t53.param [#8]                                   *unsafe.Pointer
	t65 = convert unsafe.Pointer <- *sudog (t47)             unsafe.Pointer
	*t64 = t65
	t66 = &t47.releasetime [#5]                                      *int64
	t67 = *t66                                                        int64
	t68 = t67 != 0:int64                                               bool
	if t68 goto 30 else 31
30:                                                             if.then P:1 S:1
	t69 = &t47.releasetime [#5]                                      *int64
	t70 = cputicks()                                                  int64
	*t69 = t70
	jump 31
31:                                                             if.done P:2 S:0
	t71 = goready(t53)                                                   ()
	return true:bool
32:                                                             if.then P:1 S:0
	t72 = &c.lock [#10]                                              *mutex
	t73 = unlock(t72)                                                    ()
	return false:bool
33:                                                             if.done P:1 S:2
	t74 = getg()                                                         *g
	t75 = acquireSudog()                                             *sudog
	t76 = &t75.releasetime [#5]                                      *int64
	*t76 = 0:int64
	t77 = t34 != 0:int64                                               bool
	if t77 goto 34 else 35
34:                                                             if.then P:1 S:1
	t78 = &t75.releasetime [#5]                                      *int64
	*t78 = -1:int64
	jump 35
35:                                                             if.done P:2 S:2
	t79 = &t75.elem [#4]                                    *unsafe.Pointer
	*t79 = ep
	t80 = &t75.waitlink [#7]                                        **sudog
	*t80 = nil:*sudog
	t81 = &t74.waiting [#30]                                        **sudog
	*t81 = t75
	t82 = &t75.g [#0]                                                   **g
	*t82 = t74
	t83 = &t75.selectdone [#1]                                     **uint32
	*t83 = nil:*uint32
	t84 = &t74.param [#8]                                   *unsafe.Pointer
	*t84 = nil:unsafe.Pointer
	t85 = &c.sendq [#9]                                              *waitq
	t86 = (*waitq).enqueue(t85, t75)                                     ()
	t87 = &c.lock [#10]                                              *mutex
	t88 = goparkunlock(t87, "chan send":string)                          ()
	t89 = &t74.waiting [#30]                                        **sudog
	t90 = *t89                                                       *sudog
	t91 = t75 != t90                                                   bool
	if t91 goto 36 else 37
36:                                                             if.then P:1 S:1
	t92 = gothrow("G waiting list is...":string)                         ()
	jump 37
37:                                                             if.done P:2 S:2
	t93 = &t74.waiting [#30]                                        **sudog
	*t93 = nil:*sudog
	t94 = &t74.param [#8]                                   *unsafe.Pointer
	t95 = *t94                                               unsafe.Pointer
	t96 = t95 == nil:unsafe.Pointer                                    bool
	if t96 goto 38 else 39
38:                                                             if.then P:1 S:2
	t97 = &c.closed [#4]                                            *uint32
	t98 = *t97                                                       uint32
	t99 = t98 == 0:uint32                                              bool
	if t99 goto 40 else 41
39:                                                             if.done P:1 S:2
	t100 = &t74.param [#8]                                  *unsafe.Pointer
	*t100 = nil:unsafe.Pointer
	t101 = &t75.releasetime [#5]                                     *int64
	t102 = *t101                                                      int64
	t103 = t102 > 0:int64                                              bool
	if t103 goto 42 else 43
40:                                                             if.then P:1 S:1
	t104 = gothrow("chansend: spuriou...":string)                        ()
	jump 41
41:                                                             if.done P:2 S:0
	t105 = make interface{} <- string ("send on closed ch...":string) interface{}
	panic t105
42:                                                             if.then P:1 S:1
	t106 = &t75.releasetime [#5]                                     *int64
	t107 = *t106                                                      int64
	t108 = t107 - t34                                                 int64
	t109 = blockevent(t108, 2:int)                                       ()
	jump 43
43:                                                             if.done P:2 S:0
	t110 = releaseSudog(t75)                                             ()
	return true:bool
44:                                                            for.body P:1 S:2
	if block goto 48 else 47
45:                                                            for.done P:1 S:2
	if false:untyped bool goto 54 else 55
46:                                                            for.loop P:2 S:2
	t111 = phi [23: 0:int64, 52: t136] #t1                            int64
	t112 = &c.qcount [#0]                                             *uint
	t113 = *t112                                                       uint
	t114 = &c.dataqsiz [#1]                                           *uint
	t115 = *t114                                                       uint
	t116 = t113 >= t115                                                bool
	if t116 goto 44 else 45
47:                                                             if.then P:1 S:0
	t117 = &c.lock [#10]                                             *mutex
	t118 = unlock(t117)                                                  ()
	return false:bool
48:                                                             if.done P:1 S:2
	t119 = getg()                                                        *g
	t120 = acquireSudog()                                            *sudog
	t121 = &t120.releasetime [#5]                                    *int64
	*t121 = 0:int64
	t122 = t34 != 0:int64                                              bool
	if t122 goto 49 else 50
49:                                                             if.then P:1 S:1
	t123 = &t120.releasetime [#5]                                    *int64
	*t123 = -1:int64
	jump 50
50:                                                             if.done P:2 S:2
	t124 = &t120.g [#0]                                                 **g
	*t124 = t119
	t125 = &t120.elem [#4]                                  *unsafe.Pointer
	*t125 = nil:unsafe.Pointer
	t126 = &t120.selectdone [#1]                                   **uint32
	*t126 = nil:*uint32
	t127 = &c.sendq [#9]                                             *waitq
	t128 = (*waitq).enqueue(t127, t120)                                  ()
	t129 = &c.lock [#10]                                             *mutex
	t130 = goparkunlock(t129, "chan send":string)                        ()
	t131 = &t120.releasetime [#5]                                    *int64
	t132 = *t131                                                      int64
	t133 = t132 > 0:int64                                              bool
	if t133 goto 51 else 52
51:                                                             if.then P:1 S:1
	t134 = &t120.releasetime [#5]                                    *int64
	t135 = *t134                                                      int64
	jump 52
52:                                                             if.done P:2 S:2
	t136 = phi [50: t111, 51: t135] #t1                               int64
	t137 = releaseSudog(t120)                                            ()
	t138 = &c.lock [#10]                                             *mutex
	t139 = lock(t138)                                                    ()
	t140 = &c.closed [#4]                                           *uint32
	t141 = *t140                                                     uint32
	t142 = t141 != 0:uint32                                            bool
	if t142 goto 53 else 46
53:                                                             if.then P:1 S:0
	t143 = &c.lock [#10]                                             *mutex
	t144 = unlock(t143)                                                  ()
	t145 = make interface{} <- string ("send on closed ch...":string) interface{}
	panic t145
54:                                                             if.then P:1 S:1
	t146 = &c.sendx [#6]                                              *uint
	t147 = *t146                                                       uint
	t148 = chanbuf(c, t147)                                  unsafe.Pointer
	t149 = raceacquire(t148)                                             ()
	t150 = &c.sendx [#6]                                              *uint
	t151 = *t150                                                       uint
	t152 = chanbuf(c, t151)                                  unsafe.Pointer
	t153 = racerelease(t152)                                             ()
	jump 55
55:                                                             if.done P:2 S:2
	t154 = &c.sendx [#6]                                              *uint
	t155 = *t154                                                       uint
	t156 = chanbuf(c, t155)                                  unsafe.Pointer
	t157 = &c.elemsize [#3]                                         *uint16
	t158 = *t157                                                     uint16
	t159 = convert uintptr <- uint16 (t158)                         uintptr
	t160 = memmove(t156, ep, t159)                                       ()
	t161 = &c.sendx [#6]                                              *uint
	t162 = *t161                                                       uint
	t163 = t162 + 1:uint                                               uint
	*t161 = t163
	t164 = &c.sendx [#6]                                              *uint
	t165 = *t164                                                       uint
	t166 = &c.dataqsiz [#1]                                           *uint
	t167 = *t166                                                       uint
	t168 = t165 == t167                                                bool
	if t168 goto 56 else 57
56:                                                             if.then P:1 S:1
	t169 = &c.sendx [#6]                                              *uint
	*t169 = 0:uint
	jump 57
57:                                                             if.done P:2 S:2
	t170 = &c.qcount [#0]                                             *uint
	t171 = *t170                                                       uint
	t172 = t171 + 1:uint                                               uint
	*t170 = t172
	t173 = &c.recvq [#8]                                             *waitq
	t174 = (*waitq).dequeue(t173)                                    *sudog
	t175 = t174 != nil:*sudog                                          bool
	if t175 goto 58 else 60
58:                                                             if.then P:1 S:2
	t176 = &t174.g [#0]                                                 **g
	t177 = *t176                                                         *g
	t178 = &c.lock [#10]                                             *mutex
	t179 = unlock(t178)                                                  ()
	t180 = &t174.releasetime [#5]                                    *int64
	t181 = *t180                                                      int64
	t182 = t181 != 0:int64                                             bool
	if t182 goto 61 else 62
59:                                                             if.done P:2 S:2
	t183 = t111 > 0:int64                                              bool
	if t183 goto 63 else 64
60:                                                             if.else P:1 S:1
	t184 = &c.lock [#10]                                             *mutex
	t185 = unlock(t184)                                                  ()
	jump 59
61:                                                             if.then P:1 S:1
	t186 = &t174.releasetime [#5]                                    *int64
	t187 = cputicks()                                                 int64
	*t186 = t187
	jump 62
62:                                                             if.done P:2 S:1
	t188 = goready(t177)                                                 ()
	jump 59
63:                                                             if.then P:1 S:1
	t189 = t111 - t34                                                 int64
	t190 = blockevent(t189, 2:int)                                       ()
	jump 64
64:                                                             if.done P:2 S:0
	return true:bool

# Name: runtime.closechan
# Package: runtime
# Location: /usr/local/go/src/runtime/chan.go:257:6
func closechan(c *hchan):
0:                                                                entry P:0 S:2
	t0 = new *hchan (c)                                             **hchan
	*t0 = c
	t1 = *t0                                                         *hchan
	t2 = t1 == nil:*hchan                                              bool
	if t2 goto 1 else 2
1:                                                              if.then P:1 S:0
	t3 = make interface{} <- string ("close of nil channel":string) interface{}
	panic t3
2:                                                              if.done P:1 S:2
	t4 = *t0                                                         *hchan
	t5 = &t4.lock [#10]                                              *mutex
	t6 = lock(t5)                                                        ()
	t7 = *t0                                                         *hchan
	t8 = &t7.closed [#4]                                            *uint32
	t9 = *t8                                                         uint32
	t10 = t9 != 0:uint32                                               bool
	if t10 goto 3 else 4
3:                                                              if.then P:1 S:0
	t11 = *t0                                                        *hchan
	t12 = &t11.lock [#10]                                            *mutex
	t13 = unlock(t12)                                                    ()
	t14 = make interface{} <- string ("close of closed c...":string) interface{}
	panic t14
4:                                                              if.done P:1 S:2
	if false:untyped bool goto 5 else 6
5:                                                              if.then P:1 S:1
	t15 = convert unsafe.Pointer <- **hchan (t0)             unsafe.Pointer
	t16 = getcallerpc(t15)                                          uintptr
	t17 = *t0                                                        *hchan
	t18 = convert unsafe.Pointer <- *hchan (t17)             unsafe.Pointer
	t19 = make interface{} <- func(c *hchan) (closechan)        interface{}
	t20 = funcPC(t19)                                               uintptr
	t21 = racewritepc(t18, t16, t20)                                     ()
	t22 = *t0                                                        *hchan
	t23 = convert unsafe.Pointer <- *hchan (t22)             unsafe.Pointer
	t24 = racerelease(t23)                                               ()
	jump 6
6:                                                              if.done P:2 S:1
	t25 = *t0                                                        *hchan
	t26 = &t25.closed [#4]                                          *uint32
	*t26 = 1:uint32
	jump 7
7:                                                             for.body P:2 S:2
	t27 = *t0                                                        *hchan
	t28 = &t27.recvq [#8]                                            *waitq
	t29 = (*waitq).dequeue(t28)                                      *sudog
	t30 = t29 == nil:*sudog                                            bool
	if t30 goto 11 else 8
8:                                                              if.done P:1 S:2
	t31 = &t29.g [#0]                                                   **g
	t32 = *t31                                                           *g
	t33 = &t29.elem [#4]                                    *unsafe.Pointer
	*t33 = nil:unsafe.Pointer
	t34 = &t32.param [#8]                                   *unsafe.Pointer
	*t34 = nil:unsafe.Pointer
	t35 = &t29.releasetime [#5]                                      *int64
	t36 = *t35                                                        int64
	t37 = t36 != 0:int64                                               bool
	if t37 goto 9 else 10
9:                                                              if.then P:1 S:1
	t38 = &t29.releasetime [#5]                                      *int64
	t39 = cputicks()                                                  int64
	*t38 = t39
	jump 10
10:                                                             if.done P:2 S:1
	t40 = goready(t32)                                                   ()
	jump 7
11:                                                            for.body P:2 S:2
	t41 = *t0                                                        *hchan
	t42 = &t41.sendq [#9]                                            *waitq
	t43 = (*waitq).dequeue(t42)                                      *sudog
	t44 = t43 == nil:*sudog                                            bool
	if t44 goto 12 else 13
12:                                                             if.then P:1 S:0
	t45 = *t0                                                        *hchan
	t46 = &t45.lock [#10]                                            *mutex
	t47 = unlock(t46)                                                    ()
	return
13:                                                             if.done P:1 S:2
	t48 = &t43.g [#0]                                                   **g
	t49 = *t48                                                           *g
	t50 = &t43.elem [#4]                                    *unsafe.Pointer
	*t50 = nil:unsafe.Pointer
	t51 = &t49.param [#8]                                   *unsafe.Pointer
	*t51 = nil:unsafe.Pointer
	t52 = &t43.releasetime [#5]                                      *int64
	t53 = *t52                                                        int64
	t54 = t53 != 0:int64                                               bool
	if t54 goto 14 else 15
14:                                                             if.then P:1 S:1
	t55 = &t43.releasetime [#5]                                      *int64
	t56 = cputicks()                                                  int64
	*t55 = t56
	jump 15
15:                                                             if.done P:2 S:1
	t57 = goready(t49)                                                   ()
	jump 11

# Name: runtime.chanrecv1
# Package: runtime
# Location: /usr/local/go/src/runtime/chan.go:310:6
func chanrecv1(t *chantype, c *hchan, elem unsafe.Pointer):
0:                                                                entry P:0 S:0
	t0 = chanrecv(t, c, elem, true:bool)     (selected bool, received bool)
	return

# Name: runtime.chanrecv2
# Package: runtime
# Location: /usr/local/go/src/runtime/chan.go:315:6
func chanrecv2(t *chantype, c *hchan, elem unsafe.Pointer) (received bool):
0:                                                                entry P:0 S:0
	t0 = chanrecv(t, c, elem, true:bool)     (selected bool, received bool)
	t1 = extract t0 #0                                                 bool
	t2 = extract t0 #1                                                 bool
	return t2

# Name: runtime.chanrecv
# Package: runtime
# Location: /usr/local/go/src/runtime/chan.go:325:6
func chanrecv(t *chantype, c *hchan, ep unsafe.Pointer, block bool) (selected bool, received bool):
0:                                                                entry P:0 S:2
	if false:untyped bool goto 1 else 2
1:                                                              if.then P:1 S:1
	t0 = print("chanrecv: chan=":string, c, "\n":string)                 ()
	jump 2
2:                                                              if.done P:2 S:2
	t1 = c == nil:*hchan                                               bool
	if t1 goto 3 else 4
3:                                                              if.then P:1 S:2
	if block goto 6 else 5
4:                                                              if.done P:2 S:2
	if block goto 8 else 10
5:                                                              if.then P:1 S:0
	return false:bool, false:bool
6:                                                              if.done P:1 S:1
	t2 = gopark(nil:unsafe.Pointer, nil:unsafe.Pointer, "chan receive (nil...":string) ()
	t3 = gothrow("unreachable":string)                                   ()
	jump 4
7:                                                              if.then P:1 S:0
	return false:bool, false:bool
8:                                                              if.done P:4 S:2
	t4 = *blockprofilerate                                           uint64
	t5 = t4 > 0:uint64                                                 bool
	if t5 goto 14 else 15
9:                                                            cond.true P:2 S:2
	t6 = &c.closed [#4]                                             *uint32
	t7 = atomicload(t6)                                              uint32
	t8 = t7 == 0:uint32                                                bool
	if t8 goto 7 else 8
10:                                                           cond.true P:1 S:2
	t9 = &c.dataqsiz [#1]                                             *uint
	t10 = *t9                                                          uint
	t11 = t10 == 0:uint                                                bool
	if t11 goto 12 else 11
11:                                                          cond.false P:2 S:2
	t12 = &c.dataqsiz [#1]                                            *uint
	t13 = *t12                                                         uint
	t14 = t13 > 0:uint                                                 bool
	if t14 goto 13 else 8
12:                                                           cond.true P:1 S:2
	t15 = &c.sendq [#9]                                              *waitq
	t16 = &t15.first [#0]                                           **sudog
	t17 = *t16                                                       *sudog
	t18 = t17 == nil:*sudog                                            bool
	if t18 goto 9 else 11
13:                                                           cond.true P:1 S:2
	t19 = &c.qcount [#0]                                              *uint
	t20 = atomicloaduint(t19)                                          uint
	t21 = t20 == 0:uint                                                bool
	if t21 goto 9 else 8
14:                                                             if.then P:1 S:1
	t22 = cputicks()                                                  int64
	jump 15
15:                                                             if.done P:2 S:2
	t23 = phi [8: 0:int64, 14: t22] #t0                               int64
	t24 = &c.lock [#10]                                              *mutex
	t25 = lock(t24)                                                      ()
	t26 = &c.dataqsiz [#1]                                            *uint
	t27 = *t26                                                         uint
	t28 = t27 == 0:uint                                                bool
	if t28 goto 16 else 17
16:                                                             if.then P:1 S:2
	t29 = &c.closed [#4]                                            *uint32
	t30 = *t29                                                       uint32
	t31 = t30 != 0:uint32                                              bool
	if t31 goto 18 else 19
17:                                                             if.done P:1 S:1
	jump 42
18:                                                             if.then P:1 S:0
	t32 = recvclosed(c, ep)                  (selected bool, recevied bool)
	t33 = extract t32 #0                                               bool
	t34 = extract t32 #1                                               bool
	return t33, t34
19:                                                             if.done P:1 S:2
	t35 = &c.sendq [#9]                                              *waitq
	t36 = (*waitq).dequeue(t35)                                      *sudog
	t37 = t36 != nil:*sudog                                            bool
	if t37 goto 20 else 21
20:                                                             if.then P:1 S:2
	if false:untyped bool goto 22 else 23
21:                                                             if.done P:1 S:2
	if block goto 29 else 28
22:                                                             if.then P:1 S:1
	t38 = racesync(c, t36)                                               ()
	jump 23
23:                                                             if.done P:2 S:2
	t39 = &c.lock [#10]                                              *mutex
	t40 = unlock(t39)                                                    ()
	t41 = ep != nil:unsafe.Pointer                                     bool
	if t41 goto 24 else 25
24:                                                             if.then P:1 S:1
	t42 = &t36.elem [#4]                                    *unsafe.Pointer
	t43 = *t42                                               unsafe.Pointer
	t44 = &c.elemsize [#3]                                          *uint16
	t45 = *t44                                                       uint16
	t46 = convert uintptr <- uint16 (t45)                           uintptr
	t47 = memmove(ep, t43, t46)                                          ()
	jump 25
25:                                                             if.done P:2 S:2
	t48 = &t36.elem [#4]                                    *unsafe.Pointer
	*t48 = nil:unsafe.Pointer
	t49 = &t36.g [#0]                                                   **g
	t50 = *t49                                                           *g
	t51 = &t50.param [#8]                                   *unsafe.Pointer
	t52 = convert unsafe.Pointer <- *sudog (t36)             unsafe.Pointer
	*t51 = t52
	t53 = &t36.releasetime [#5]                                      *int64
	t54 = *t53                                                        int64
	t55 = t54 != 0:int64                                               bool
	if t55 goto 26 else 27
26:                                                             if.then P:1 S:1
	t56 = &t36.releasetime [#5]                                      *int64
	t57 = cputicks()                                                  int64
	*t56 = t57
	jump 27
27:                                                             if.done P:2 S:0
	t58 = goready(t50)                                                   ()
	return true:bool, true:bool
28:                                                             if.then P:1 S:0
	t59 = &c.lock [#10]                                              *mutex
	t60 = unlock(t59)                                                    ()
	return false:bool, false:bool
29:                                                             if.done P:1 S:2
	t61 = getg()                                                         *g
	t62 = acquireSudog()                                             *sudog
	t63 = &t62.releasetime [#5]                                      *int64
	*t63 = 0:int64
	t64 = t23 != 0:int64                                               bool
	if t64 goto 30 else 31
30:                                                             if.then P:1 S:1
	t65 = &t62.releasetime [#5]                                      *int64
	*t65 = -1:int64
	jump 31
31:                                                             if.done P:2 S:2
	t66 = &t62.elem [#4]                                    *unsafe.Pointer
	*t66 = ep
	t67 = &t62.waitlink [#7]                                        **sudog
	*t67 = nil:*sudog
	t68 = &t61.waiting [#30]                                        **sudog
	*t68 = t62
	t69 = &t62.g [#0]                                                   **g
	*t69 = t61
	t70 = &t62.selectdone [#1]                                     **uint32
	*t70 = nil:*uint32
	t71 = &t61.param [#8]                                   *unsafe.Pointer
	*t71 = nil:unsafe.Pointer
	t72 = &c.recvq [#8]                                              *waitq
	t73 = (*waitq).enqueue(t72, t62)                                     ()
	t74 = &c.lock [#10]                                              *mutex
	t75 = goparkunlock(t74, "chan receive":string)                       ()
	t76 = &t61.waiting [#30]                                        **sudog
	t77 = *t76                                                       *sudog
	t78 = t62 != t77                                                   bool
	if t78 goto 32 else 33
32:                                                             if.then P:1 S:1
	t79 = gothrow("G waiting list is...":string)                         ()
	jump 33
33:                                                             if.done P:2 S:2
	t80 = &t61.waiting [#30]                                        **sudog
	*t80 = nil:*sudog
	t81 = &t62.releasetime [#5]                                      *int64
	t82 = *t81                                                        int64
	t83 = t82 > 0:int64                                                bool
	if t83 goto 34 else 35
34:                                                             if.then P:1 S:1
	t84 = &t62.releasetime [#5]                                      *int64
	t85 = *t84                                                        int64
	t86 = t85 - t23                                                   int64
	t87 = blockevent(t86, 2:int)                                         ()
	jump 35
35:                                                             if.done P:2 S:2
	t88 = &t61.param [#8]                                   *unsafe.Pointer
	t89 = *t88                                               unsafe.Pointer
	t90 = t89 != nil:unsafe.Pointer                                    bool
	t91 = &t61.param [#8]                                   *unsafe.Pointer
	*t91 = nil:unsafe.Pointer
	t92 = releaseSudog(t62)                                              ()
	if t90 goto 36 else 37
36:                                                             if.then P:1 S:0
	return true:bool, true:bool
37:                                                             if.done P:1 S:2
	t93 = &c.lock [#10]                                              *mutex
	t94 = lock(t93)                                                      ()
	t95 = &c.closed [#4]                                            *uint32
	t96 = *t95                                                       uint32
	t97 = t96 == 0:uint32                                              bool
	if t97 goto 38 else 39
38:                                                             if.then P:1 S:1
	t98 = gothrow("chanrecv: spuriou...":string)                         ()
	jump 39
39:                                                             if.done P:2 S:0
	t99 = recvclosed(c, ep)                  (selected bool, recevied bool)
	t100 = extract t99 #0                                              bool
	t101 = extract t99 #1                                              bool
	return t100, t101
40:                                                            for.body P:1 S:2
	t102 = &c.closed [#4]                                           *uint32
	t103 = *t102                                                     uint32
	t104 = t103 != 0:uint32                                            bool
	if t104 goto 43 else 44
41:                                                            for.done P:1 S:2
	if false:untyped bool goto 53 else 54
42:                                                            for.loop P:2 S:2
	t105 = phi [17: 0:int64, 52: t134] #t1                            int64
	t106 = &c.qcount [#0]                                             *uint
	t107 = *t106                                                       uint
	t108 = t107 <= 0:uint                                              bool
	if t108 goto 40 else 41
43:                                                             if.then P:1 S:2
	t109 = recvclosed(c, ep)                 (selected bool, recevied bool)
	t110 = extract t109 #0                                             bool
	t111 = extract t109 #1                                             bool
	t112 = t105 > 0:int64                                              bool
	if t112 goto 45 else 46
44:                                                             if.done P:1 S:2
	if block goto 48 else 47
45:                                                             if.then P:1 S:1
	t113 = t105 - t23                                                 int64
	t114 = blockevent(t113, 2:int)                                       ()
	jump 46
46:                                                             if.done P:2 S:0
	return t110, t111
47:                                                             if.then P:1 S:0
	t115 = &c.lock [#10]                                             *mutex
	t116 = unlock(t115)                                                  ()
	return false:bool, false:bool
48:                                                             if.done P:1 S:2
	t117 = getg()                                                        *g
	t118 = acquireSudog()                                            *sudog
	t119 = &t118.releasetime [#5]                                    *int64
	*t119 = 0:int64
	t120 = t23 != 0:int64                                              bool
	if t120 goto 49 else 50
49:                                                             if.then P:1 S:1
	t121 = &t118.releasetime [#5]                                    *int64
	*t121 = -1:int64
	jump 50
50:                                                             if.done P:2 S:2
	t122 = &t118.elem [#4]                                  *unsafe.Pointer
	*t122 = nil:unsafe.Pointer
	t123 = &t118.g [#0]                                                 **g
	*t123 = t117
	t124 = &t118.selectdone [#1]                                   **uint32
	*t124 = nil:*uint32
	t125 = &c.recvq [#8]                                             *waitq
	t126 = (*waitq).enqueue(t125, t118)                                  ()
	t127 = &c.lock [#10]                                             *mutex
	t128 = goparkunlock(t127, "chan receive":string)                     ()
	t129 = &t118.releasetime [#5]                                    *int64
	t130 = *t129                                                      int64
	t131 = t130 > 0:int64                                              bool
	if t131 goto 51 else 52
51:                                                             if.then P:1 S:1
	t132 = &t118.releasetime [#5]                                    *int64
	t133 = *t132                                                      int64
	jump 52
52:                                                             if.done P:2 S:1
	t134 = phi [50: t105, 51: t133] #t1                               int64
	t135 = releaseSudog(t118)                                            ()
	t136 = &c.lock [#10]                                             *mutex
	t137 = lock(t136)                                                    ()
	jump 42
53:                                                             if.then P:1 S:1
	t138 = &c.recvx [#7]                                              *uint
	t139 = *t138                                                       uint
	t140 = chanbuf(c, t139)                                  unsafe.Pointer
	t141 = raceacquire(t140)                                             ()
	t142 = &c.recvx [#7]                                              *uint
	t143 = *t142                                                       uint
	t144 = chanbuf(c, t143)                                  unsafe.Pointer
	t145 = racerelease(t144)                                             ()
	jump 54
54:                                                             if.done P:2 S:2
	t146 = ep != nil:unsafe.Pointer                                    bool
	if t146 goto 55 else 56
55:                                                             if.then P:1 S:1
	t147 = &c.recvx [#7]                                              *uint
	t148 = *t147                                                       uint
	t149 = chanbuf(c, t148)                                  unsafe.Pointer
	t150 = &c.elemsize [#3]                                         *uint16
	t151 = *t150                                                     uint16
	t152 = convert uintptr <- uint16 (t151)                         uintptr
	t153 = memmove(ep, t149, t152)                                       ()
	jump 56
56:                                                             if.done P:2 S:2
	t154 = &c.recvx [#7]                                              *uint
	t155 = *t154                                                       uint
	t156 = chanbuf(c, t155)                                  unsafe.Pointer
	t157 = &c.elemsize [#3]                                         *uint16
	t158 = *t157                                                     uint16
	t159 = convert uintptr <- uint16 (t158)                         uintptr
	t160 = memclr(t156, t159)                                            ()
	t161 = &c.recvx [#7]                                              *uint
	t162 = *t161                                                       uint
	t163 = t162 + 1:uint                                               uint
	*t161 = t163
	t164 = &c.recvx [#7]                                              *uint
	t165 = *t164                                                       uint
	t166 = &c.dataqsiz [#1]                                           *uint
	t167 = *t166                                                       uint
	t168 = t165 == t167                                                bool
	if t168 goto 57 else 58
57:                                                             if.then P:1 S:1
	t169 = &c.recvx [#7]                                              *uint
	*t169 = 0:uint
	jump 58
58:                                                             if.done P:2 S:2
	t170 = &c.qcount [#0]                                             *uint
	t171 = *t170                                                       uint
	t172 = t171 - 1:uint                                               uint
	*t170 = t172
	t173 = &c.sendq [#9]                                             *waitq
	t174 = (*waitq).dequeue(t173)                                    *sudog
	t175 = t174 != nil:*sudog                                          bool
	if t175 goto 59 else 61
59:                                                             if.then P:1 S:2
	t176 = &t174.g [#0]                                                 **g
	t177 = *t176                                                         *g
	t178 = &c.lock [#10]                                             *mutex
	t179 = unlock(t178)                                                  ()
	t180 = &t174.releasetime [#5]                                    *int64
	t181 = *t180                                                      int64
	t182 = t181 != 0:int64                                             bool
	if t182 goto 62 else 63
60:                                                             if.done P:2 S:2
	t183 = t105 > 0:int64                                              bool
	if t183 goto 64 else 65
61:                                                             if.else P:1 S:1
	t184 = &c.lock [#10]                                             *mutex
	t185 = unlock(t184)                                                  ()
	jump 60
62:                                                             if.then P:1 S:1
	t186 = &t174.releasetime [#5]                                    *int64
	t187 = cputicks()                                                 int64
	*t186 = t187
	jump 63
63:                                                             if.done P:2 S:1
	t188 = goready(t177)                                                 ()
	jump 60
64:                                                             if.then P:1 S:1
	t189 = t105 - t23                                                 int64
	t190 = blockevent(t189, 2:int)                                       ()
	jump 65
65:                                                             if.done P:2 S:0
	return true:bool, true:bool

# Name: runtime.recvclosed
# Package: runtime
# Location: /usr/local/go/src/runtime/chan.go:516:6
func recvclosed(c *hchan, ep unsafe.Pointer) (selected bool, recevied bool):
0:                                                                entry P:0 S:2
	if false:untyped bool goto 1 else 2
1:                                                              if.then P:1 S:1
	t0 = convert unsafe.Pointer <- *hchan (c)                unsafe.Pointer
	t1 = raceacquire(t0)                                                 ()
	jump 2
2:                                                              if.done P:2 S:2
	t2 = &c.lock [#10]                                               *mutex
	t3 = unlock(t2)                                                      ()
	t4 = ep != nil:unsafe.Pointer                                      bool
	if t4 goto 3 else 4
3:                                                              if.then P:1 S:1
	t5 = &c.elemsize [#3]                                           *uint16
	t6 = *t5                                                         uint16
	t7 = convert uintptr <- uint16 (t6)                             uintptr
	t8 = memclr(ep, t7)                                                  ()
	jump 4
4:                                                              if.done P:2 S:0
	return true:bool, false:bool

# Name: runtime.selectnbsend
# Package: runtime
# Location: /usr/local/go/src/runtime/chan.go:544:6
func selectnbsend(t *chantype, c *hchan, elem unsafe.Pointer) (selected bool):
0:                                                                entry P:0 S:0
	t0 = new *chantype (t)                                       **chantype
	*t0 = t
	t1 = *t0                                                      *chantype
	t2 = convert unsafe.Pointer <- **chantype (t0)           unsafe.Pointer
	t3 = getcallerpc(t2)                                            uintptr
	t4 = chansend(t1, c, elem, false:bool, t3)                         bool
	return t4

# Name: runtime.selectnbrecv
# Package: runtime
# Location: /usr/local/go/src/runtime/chan.go:565:6
func selectnbrecv(t *chantype, elem unsafe.Pointer, c *hchan) (selected bool):
0:                                                                entry P:0 S:0
	t0 = chanrecv(t, c, elem, false:bool)    (selected bool, received bool)
	t1 = extract t0 #0                                                 bool
	t2 = extract t0 #1                                                 bool
	return t1

# Name: runtime.selectnbrecv2
# Package: runtime
# Location: /usr/local/go/src/runtime/chan.go:587:6
func selectnbrecv2(t *chantype, elem unsafe.Pointer, received *bool, c *hchan) (selected bool):
0:                                                                entry P:0 S:0
	t0 = chanrecv(t, c, elem, false:bool)    (selected bool, received bool)
	t1 = extract t0 #0                                                 bool
	t2 = extract t0 #1                                                 bool
	*received = t2
	return t1

# Name: runtime.reflect_chansend
# Package: runtime
# Location: /usr/local/go/src/runtime/chan.go:593:6
func reflect_chansend(t *chantype, c *hchan, elem unsafe.Pointer, nb bool) (selected bool):
0:                                                                entry P:0 S:0
	t0 = new *chantype (t)                                       **chantype
	*t0 = t
	t1 = *t0                                                      *chantype
	t2 = !nb                                                           bool
	t3 = convert unsafe.Pointer <- **chantype (t0)           unsafe.Pointer
	t4 = getcallerpc(t3)                                            uintptr
	t5 = chansend(t1, c, elem, t2, t4)                                 bool
	return t5

# Name: runtime.reflect_chanrecv
# Package: runtime
# Location: /usr/local/go/src/runtime/chan.go:597:6
func reflect_chanrecv(t *chantype, c *hchan, nb bool, elem unsafe.Pointer) (selected bool, received bool):
0:                                                                entry P:0 S:0
	t0 = !nb                                                           bool
	t1 = chanrecv(t, c, elem, t0)            (selected bool, received bool)
	t2 = extract t1 #0                                                 bool
	t3 = extract t1 #1                                                 bool
	return t2, t3

# Name: runtime.reflect_chanlen
# Package: runtime
# Location: /usr/local/go/src/runtime/chan.go:601:6
func reflect_chanlen(c *hchan) int:
0:                                                                entry P:0 S:2
	t0 = c == nil:*hchan                                               bool
	if t0 goto 1 else 2
1:                                                              if.then P:1 S:0
	return 0:int
2:                                                              if.done P:1 S:0
	t1 = &c.qcount [#0]                                               *uint
	t2 = *t1                                                           uint
	t3 = convert int <- uint (t2)                                       int
	return t3

# Name: runtime.reflect_chancap
# Package: runtime
# Location: /usr/local/go/src/runtime/chan.go:608:6
func reflect_chancap(c *hchan) int:
0:                                                                entry P:0 S:2
	t0 = c == nil:*hchan                                               bool
	if t0 goto 1 else 2
1:                                                              if.then P:1 S:0
	return 0:int
2:                                                              if.done P:1 S:0
	t1 = &c.dataqsiz [#1]                                             *uint
	t2 = *t1                                                           uint
	t3 = convert int <- uint (t2)                                       int
	return t3

# Name: (*runtime.waitq).enqueue
# Package: runtime
# Location: /usr/local/go/src/runtime/chan.go:615:17
func (q *waitq) enqueue(sgp *sudog):
0:                                                                entry P:0 S:2
	t0 = &sgp.next [#2]                                             **sudog
	*t0 = nil:*sudog
	t1 = &q.first [#0]                                              **sudog
	t2 = *t1                                                         *sudog
	t3 = t2 == nil:*sudog                                              bool
	if t3 goto 1 else 2
1:                                                              if.then P:1 S:0
	t4 = &q.first [#0]                                              **sudog
	*t4 = sgp
	t5 = &q.last [#1]                                               **sudog
	*t5 = sgp
	return
2:                                                              if.done P:1 S:0
	t6 = &q.last [#1]                                               **sudog
	t7 = *t6                                                         *sudog
	t8 = &t7.next [#2]                                              **sudog
	*t8 = sgp
	t9 = &q.last [#1]                                               **sudog
	*t9 = sgp
	return

# Name: (*runtime.waitq).dequeue
# Package: runtime
# Location: /usr/local/go/src/runtime/chan.go:626:17
func (q *waitq) dequeue() *sudog:
0:                                                                entry P:0 S:1
	jump 1
1:                                                             for.body P:3 S:2
	t0 = &q.first [#0]                                              **sudog
	t1 = *t0                                                         *sudog
	t2 = t1 == nil:*sudog                                              bool
	if t2 goto 2 else 3
2:                                                              if.then P:1 S:0
	return nil:*sudog
3:                                                              if.done P:1 S:2
	t3 = &q.first [#0]                                              **sudog
	t4 = &t1.next [#2]                                              **sudog
	t5 = *t4                                                         *sudog
	*t3 = t5
	t6 = &t1.next [#2]                                              **sudog
	*t6 = nil:*sudog
	t7 = &q.last [#1]                                               **sudog
	t8 = *t7                                                         *sudog
	t9 = t8 == t1                                                      bool
	if t9 goto 4 else 5
4:                                                              if.then P:1 S:1
	t10 = &q.last [#1]                                              **sudog
	*t10 = nil:*sudog
	jump 5
5:                                                              if.done P:2 S:2
	t11 = &t1.selectdone [#1]                                      **uint32
	t12 = *t11                                                      *uint32
	t13 = t12 != nil:*uint32                                           bool
	if t13 goto 6 else 7
6:                                                              if.then P:1 S:2
	t14 = &t1.selectdone [#1]                                      **uint32
	t15 = *t14                                                      *uint32
	t16 = *t15                                                       uint32
	t17 = t16 != 0:uint32                                              bool
	if t17 goto 1 else 8
7:                                                              if.done P:2 S:0
	return t1
8:                                                           cond.false P:1 S:2
	t18 = &t1.selectdone [#1]                                      **uint32
	t19 = *t18                                                      *uint32
	t20 = cas(t19, 0:uint32, 1:uint32)                                 bool
	if t20 goto 7 else 1

# Name: runtime.racesync
# Package: runtime
# Location: /usr/local/go/src/runtime/chan.go:650:6
func racesync(c *hchan, sg *sudog):
0:                                                                entry P:0 S:0
	t0 = chanbuf(c, 0:uint)                                  unsafe.Pointer
	t1 = racerelease(t0)                                                 ()
	t2 = &sg.g [#0]                                                     **g
	t3 = *t2                                                             *g
	t4 = chanbuf(c, 0:uint)                                  unsafe.Pointer
	t5 = raceacquireg(t3, t4)                                            ()
	t6 = &sg.g [#0]                                                     **g
	t7 = *t6                                                             *g
	t8 = chanbuf(c, 0:uint)                                  unsafe.Pointer
	t9 = racereleaseg(t7, t8)                                            ()
	t10 = chanbuf(c, 0:uint)                                 unsafe.Pointer
	t11 = raceacquire(t10)                                               ()
	return

# Name: runtime.complex128div
# Package: runtime
# Location: /usr/local/go/src/runtime/complex.go:7:6
func complex128div(n complex128, d complex128) complex128:
0:                                                                entry P:0 S:2
	t0 = real(n)                                                    float64
	t1 = *posinf                                                    float64
	t2 = t0 == t1                                                      bool
	if t2 goto 2 else 4
1:                                                            binop.rhs P:1 S:1
	t3 = imag(n)                                                    float64
	t4 = *neginf                                                    float64
	t5 = t3 == t4                                                      bool
	jump 2
2:                                                           binop.done P:4 S:2
	t6 = phi [0: true:bool, 4: true:bool, 3: true:bool, 1: t5] #||     bool
	t7 = real(d)                                                    float64
	t8 = *posinf                                                    float64
	t9 = t7 == t8                                                      bool
	if t9 goto 6 else 8
3:                                                           cond.false P:1 S:2
	t10 = imag(n)                                                   float64
	t11 = *posinf                                                   float64
	t12 = t10 == t11                                                   bool
	if t12 goto 2 else 1
4:                                                           cond.false P:1 S:2
	t13 = real(n)                                                   float64
	t14 = *neginf                                                   float64
	t15 = t13 == t14                                                   bool
	if t15 goto 2 else 3
5:                                                            binop.rhs P:1 S:1
	t16 = imag(d)                                                   float64
	t17 = *neginf                                                   float64
	t18 = t16 == t17                                                   bool
	jump 6
6:                                                           binop.done P:4 S:2
	t19 = phi [2: true:bool, 8: true:bool, 7: true:bool, 5: t18] #||   bool
	if t6 goto 10 else 9
7:                                                           cond.false P:1 S:2
	t20 = imag(d)                                                   float64
	t21 = *posinf                                                   float64
	t22 = t20 == t21                                                   bool
	if t22 goto 6 else 5
8:                                                           cond.false P:1 S:2
	t23 = real(d)                                                   float64
	t24 = *neginf                                                   float64
	t25 = t23 == t24                                                   bool
	if t25 goto 6 else 7
9:                                                            binop.rhs P:1 S:2
	t26 = real(n)                                                   float64
	t27 = real(n)                                                   float64
	t28 = t26 != t27                                                   bool
	if t28 goto 12 else 11
10:                                                          binop.done P:2 S:2
	t29 = phi [6: false:bool, 12: t33] #&&                             bool
	if t19 goto 14 else 13
11:                                                           binop.rhs P:1 S:1
	t30 = imag(n)                                                   float64
	t31 = imag(n)                                                   float64
	t32 = t30 != t31                                                   bool
	jump 12
12:                                                          binop.done P:2 S:1
	t33 = phi [9: true:bool, 11: t32] #||                              bool
	jump 10
13:                                                           binop.rhs P:1 S:2
	t34 = real(d)                                                   float64
	t35 = real(d)                                                   float64
	t36 = t34 != t35                                                   bool
	if t36 goto 16 else 15
14:                                                          binop.done P:2 S:2
	t37 = phi [10: false:bool, 16: t41] #&&                            bool
	if t29 goto 21 else 20
15:                                                           binop.rhs P:1 S:1
	t38 = imag(d)                                                   float64
	t39 = imag(d)                                                   float64
	t40 = t38 != t39                                                   bool
	jump 16
16:                                                          binop.done P:2 S:1
	t41 = phi [13: true:bool, 15: t40] #||                             bool
	jump 14
17:                                                         switch.body P:1 S:0
	t42 = *nan                                                      float64
	t43 = *nan                                                      float64
	t44 = complex(t42, t43)                                      complex128
	return t44
18:                                                         switch.body P:1 S:0
	t45 = *posinf                                                   float64
	t46 = *posinf                                                   float64
	t47 = complex(t45, t46)                                      complex128
	return t47
19:                                                         switch.next P:1 S:2
	if t6 goto 24 else 25
20:                                                           binop.rhs P:1 S:1
	jump 21
21:                                                          binop.done P:2 S:2
	t48 = phi [14: true:bool, 20: t37] #||                             bool
	if t48 goto 17 else 19
22:                                                         switch.body P:1 S:0
	return 0:complex128
23:                                                         switch.next P:1 S:2
	if t6 goto 29 else 28
24:                                                           binop.rhs P:1 S:1
	t49 = !t19                                                         bool
	jump 25
25:                                                          binop.done P:2 S:2
	t50 = phi [19: false:bool, 24: t49] #&&                            bool
	if t50 goto 18 else 23
26:                                                         switch.body P:1 S:2
	t51 = real(n)                                                   float64
	t52 = t51 == 0:float64                                             bool
	if t52 goto 35 else 34
27:                                                         switch.next P:1 S:2
	t53 = real(d)                                                   float64
	t54 = t53 == 0:float64                                             bool
	if t54 goto 31 else 32
28:                                                           binop.rhs P:1 S:1
	jump 29
29:                                                          binop.done P:2 S:2
	t55 = phi [23: false:bool, 28: t19] #&&                            bool
	if t55 goto 22 else 27
30:                                                         switch.next P:1 S:2
	t56 = real(d)                                                   float64
	t57 = t56 < 0:float64                                              bool
	if t57 goto 36 else 37
31:                                                           binop.rhs P:1 S:1
	t58 = imag(d)                                                   float64
	t59 = t58 == 0:float64                                             bool
	jump 32
32:                                                          binop.done P:2 S:2
	t60 = phi [27: false:bool, 31: t59] #&&                            bool
	if t60 goto 26 else 30
33:                                                             if.then P:1 S:0
	t61 = *nan                                                      float64
	t62 = *nan                                                      float64
	t63 = complex(t61, t62)                                      complex128
	return t63
34:                                                             if.else P:2 S:0
	t64 = *posinf                                                   float64
	t65 = *posinf                                                   float64
	t66 = complex(t64, t65)                                      complex128
	return t66
35:                                                           cond.true P:1 S:2
	t67 = imag(n)                                                   float64
	t68 = t67 == 0:float64                                             bool
	if t68 goto 33 else 34
36:                                                             if.then P:1 S:1
	t69 = -t56                                                      float64
	jump 37
37:                                                             if.done P:2 S:2
	t70 = phi [30: t56, 36: t69] #a                                 float64
	t71 = imag(d)                                                   float64
	t72 = t71 < 0:float64                                              bool
	if t72 goto 38 else 39
38:                                                             if.then P:1 S:1
	t73 = -t71                                                      float64
	jump 39
39:                                                             if.done P:2 S:2
	t74 = phi [37: t71, 38: t73] #b                                 float64
	t75 = t70 <= t74                                                   bool
	if t75 goto 40 else 41
40:                                                             if.then P:1 S:0
	t76 = real(d)                                                   float64
	t77 = imag(d)                                                   float64
	t78 = t76 / t77                                                 float64
	t79 = real(d)                                                   float64
	t80 = t79 * t78                                                 float64
	t81 = imag(d)                                                   float64
	t82 = t80 + t81                                                 float64
	t83 = real(n)                                                   float64
	t84 = t83 * t78                                                 float64
	t85 = imag(n)                                                   float64
	t86 = t84 + t85                                                 float64
	t87 = t86 / t82                                                 float64
	t88 = imag(n)                                                   float64
	t89 = t88 * t78                                                 float64
	t90 = real(n)                                                   float64
	t91 = t89 - t90                                                 float64
	t92 = t91 / t82                                                 float64
	t93 = complex(t87, t92)                                      complex128
	return t93
41:                                                             if.else P:1 S:0
	t94 = imag(d)                                                   float64
	t95 = real(d)                                                   float64
	t96 = t94 / t95                                                 float64
	t97 = imag(d)                                                   float64
	t98 = t97 * t96                                                 float64
	t99 = real(d)                                                   float64
	t100 = t98 + t99                                                float64
	t101 = imag(n)                                                  float64
	t102 = t101 * t96                                               float64
	t103 = real(n)                                                  float64
	t104 = t102 + t103                                              float64
	t105 = t104 / t100                                              float64
	t106 = imag(n)                                                  float64
	t107 = real(n)                                                  float64
	t108 = t107 * t96                                               float64
	t109 = t106 - t108                                              float64
	t110 = t109 / t100                                              float64
	t111 = complex(t105, t110)                                   complex128
	return t111

# Name: runtime.setcpuprofilerate
# Package: runtime
# Location: /usr/local/go/src/runtime/cpuprof.go:106:6
func setcpuprofilerate(hz int32):
0:                                                                entry P:0 S:0
	t0 = getg()                                                          *g
	t1 = &t0.m [#21]                                                    **m
	t2 = *t1                                                             *m
	t3 = &t2.scalararg [#45]                                    *[4]uintptr
	t4 = &t3[0:int]                                                *uintptr
	t5 = convert uintptr <- int32 (hz)                              uintptr
	*t4 = t5
	t6 = onM(setcpuprofilerate_m)                                        ()
	return

# Name: runtime.lostProfileData
# Package: runtime
# Location: /usr/local/go/src/runtime/cpuprof.go:115:6
func lostProfileData():
0:                                                                entry P:0 S:0
	return

# Name: runtime.SetCPUProfileRate
# Package: runtime
# Location: /usr/local/go/src/runtime/cpuprof.go:124:6
func SetCPUProfileRate(hz int):
0:                                                                entry P:0 S:2
	t0 = hz < 0:int                                                    bool
	if t0 goto 1 else 2
1:                                                              if.then P:1 S:1
	jump 2
2:                                                              if.done P:2 S:2
	t1 = phi [0: hz, 1: 0:int] #hz                                      int
	t2 = t1 > 1000000:int                                              bool
	if t2 goto 3 else 4
3:                                                              if.then P:1 S:1
	jump 4
4:                                                              if.done P:2 S:2
	t3 = phi [2: t1, 3: 1000000:int] #hz                                int
	t4 = lock(cpuprofLock)                                               ()
	t5 = t3 > 0:int                                                    bool
	if t5 goto 5 else 7
5:                                                              if.then P:1 S:2
	t6 = *cpuprof                                               *cpuProfile
	t7 = t6 == nil:*cpuProfile                                         bool
	if t7 goto 8 else 9
6:                                                              if.done P:5 S:0
	t8 = unlock(cpuprofLock)                                             ()
	return
7:                                                              if.else P:1 S:2
	t9 = *cpuprof                                               *cpuProfile
	t10 = t9 != nil:*cpuProfile                                        bool
	if t10 goto 15 else 6
8:                                                              if.then P:1 S:2
	t11 = &memstats.other_sys [#20]                                 *uint64
	t12 = sysAlloc(3211327:uintptr, t11)                     unsafe.Pointer
	t13 = convert *cpuProfile <- unsafe.Pointer (t12)           *cpuProfile
	*cpuprof = t13
	t14 = *cpuprof                                              *cpuProfile
	t15 = t14 == nil:*cpuProfile                                       bool
	if t15 goto 10 else 9
9:                                                              if.done P:2 S:2
	t16 = *cpuprof                                              *cpuProfile
	t17 = &t16.on [#0]                                                *bool
	t18 = *t17                                                         bool
	if t18 goto 11 else 13
10:                                                             if.then P:1 S:0
	t19 = print("runtime: cpu prof...":string)                           ()
	t20 = unlock(cpuprofLock)                                            ()
	return
11:                                                             if.then P:2 S:0
	t21 = print("runtime: cannot s...":string)                           ()
	t22 = unlock(cpuprofLock)                                            ()
	return
12:                                                             if.done P:1 S:1
	t23 = *cpuprof                                              *cpuProfile
	t24 = &t23.on [#0]                                                *bool
	*t24 = true:bool
	t25 = *cpuprof                                              *cpuProfile
	t26 = &t25.log [#6]                                  *[2][65536]uintptr
	t27 = &t26[0:int]                                       *[65536]uintptr
	t28 = &t27[0:int]                                              *uintptr
	*t28 = 0:uintptr
	t29 = &t27[1:int]                                              *uintptr
	*t29 = 3:uintptr
	t30 = &t27[2:int]                                              *uintptr
	*t30 = 0:uintptr
	t31 = &t27[3:int]                                              *uintptr
	t32 = 1000000:int / t3                                              int
	t33 = convert uintptr <- int (t32)                              uintptr
	*t31 = t33
	t34 = &t27[4:int]                                              *uintptr
	*t34 = 0:uintptr
	t35 = *cpuprof                                              *cpuProfile
	t36 = &t35.nlog [#7]                                           *uintptr
	*t36 = 5:uintptr
	t37 = *cpuprof                                              *cpuProfile
	t38 = &t37.toggle [#8]                                           *int32
	*t38 = 0:int32
	t39 = *cpuprof                                              *cpuProfile
	t40 = &t39.wholding [#11]                                         *bool
	*t40 = false:bool
	t41 = *cpuprof                                              *cpuProfile
	t42 = &t41.wtoggle [#10]                                        *uint32
	*t42 = 0:uint32
	t43 = *cpuprof                                              *cpuProfile
	t44 = &t43.flushing [#12]                                         *bool
	*t44 = false:bool
	t45 = *cpuprof                                              *cpuProfile
	t46 = &t45.eodSent [#13]                                          *bool
	*t46 = false:bool
	t47 = *cpuprof                                              *cpuProfile
	t48 = &t47.wait [#1]                                              *note
	t49 = noteclear(t48)                                                 ()
	t50 = convert int32 <- int (t3)                                   int32
	t51 = setcpuprofilerate(t50)                                         ()
	jump 6
13:                                                          cond.false P:1 S:2
	t52 = *cpuprof                                              *cpuProfile
	t53 = &t52.handoff [#9]                                         *uint32
	t54 = *t53                                                       uint32
	t55 = t54 != 0:uint32                                              bool
	if t55 goto 11 else 12
14:                                                             if.then P:1 S:1
	t56 = setcpuprofilerate(0:int32)                                     ()
	t57 = *cpuprof                                              *cpuProfile
	t58 = &t57.on [#0]                                                *bool
	*t58 = false:bool
	jump 16
15:                                                           cond.true P:1 S:2
	t59 = *cpuprof                                              *cpuProfile
	t60 = &t59.on [#0]                                                *bool
	t61 = *t60                                                         bool
	if t61 goto 14 else 6
16:                                                            for.body P:2 S:2
	t62 = *cpuprof                                              *cpuProfile
	t63 = &t62.handoff [#9]                                         *uint32
	t64 = *t63                                                       uint32
	t65 = t64 & 2147483648:uint32                                    uint32
	t66 = t65 != 0:uint32                                              bool
	if t66 goto 17 else 18
17:                                                             if.then P:1 S:1
	t67 = print("runtime: setcpupr...":string)                           ()
	jump 18
18:                                                             if.done P:2 S:2
	t68 = *cpuprof                                              *cpuProfile
	t69 = &t68.handoff [#9]                                         *uint32
	t70 = t64 | 2147483648:uint32                                    uint32
	t71 = cas(t69, t64, t70)                                           bool
	if t71 goto 19 else 16
19:                                                             if.then P:1 S:2
	t72 = t64 == 0:uint32                                              bool
	if t72 goto 20 else 6
20:                                                             if.then P:1 S:1
	t73 = *cpuprof                                              *cpuProfile
	t74 = &t73.wait [#1]                                              *note
	t75 = notewakeup(t74)                                                ()
	jump 6

# Name: runtime.cpuproftick
# Package: runtime
# Location: /usr/local/go/src/runtime/cpuprof.go:190:6
func cpuproftick(pc *uintptr, n int32):
0:                                                                entry P:0 S:2
	t0 = n > 64:int32                                                  bool
	if t0 goto 1 else 2
1:                                                              if.then P:1 S:1
	jump 2
2:                                                              if.done P:2 S:0
	t1 = phi [0: n, 1: 64:int32] #n                                   int32
	t2 = convert unsafe.Pointer <- *uintptr (pc)             unsafe.Pointer
	t3 = convert *[64]uintptr <- unsafe.Pointer (t2)           *[64]uintptr
	t4 = slice t3[:t1]                                            []uintptr
	t5 = *cpuprof                                               *cpuProfile
	t6 = (*cpuProfile).add(t5, t4)                                       ()
	return

# Name: (*runtime.cpuProfile).add
# Package: runtime
# Location: /usr/local/go/src/runtime/cpuprof.go:203:22
func (p *cpuProfile) add(pc []uintptr):
0:                                                                entry P:0 S:1
	t0 = len(pc)                                                        int
	jump 1
1:                                                      rangeindex.loop P:2 S:2
	t1 = phi [0: 0:uintptr, 2: t15] #h                              uintptr
	t2 = phi [0: -1:int, 2: t3]                                         int
	t3 = t2 + 1:int                                                     int
	t4 = t3 < t0                                                       bool
	if t4 goto 2 else 3
2:                                                      rangeindex.body P:1 S:1
	t5 = &pc[t3]                                                   *uintptr
	t6 = *t5                                                        uintptr
	t7 = t1 << 8:uint64                                             uintptr
	t8 = t1 >> 56:uintptr                                           uintptr
	t9 = t7 | t8                                                    uintptr
	t10 = t6 * 31:uintptr                                           uintptr
	t11 = t6 * 7:uintptr                                            uintptr
	t12 = t10 + t11                                                 uintptr
	t13 = t6 * 3:uintptr                                            uintptr
	t14 = t12 + t13                                                 uintptr
	t15 = t9 + t14                                                  uintptr
	jump 1
3:                                                      rangeindex.done P:1 S:1
	t16 = &p.count [#2]                                            *uintptr
	t17 = *t16                                                      uintptr
	t18 = t17 + 1:uintptr                                           uintptr
	*t16 = t18
	t19 = &p.hash [#5]                 *[1024]struct{entry [4]cpuprofEntry}
	t20 = t1 % 1024:uintptr                                         uintptr
	t21 = convert int <- uintptr (t20)                                  int
	t22 = &t19[t21]                          *struct{entry [4]cpuprofEntry}
	t23 = &t22.entry [#0]                                  *[4]cpuprofEntry
	t24 = *t23                                              [4]cpuprofEntry
	jump 4
4:                                                      rangeindex.loop P:3 S:2
	t25 = phi [3: -1:int, 5: t26, 9: t26]                               int
	t26 = t25 + 1:int                                                   int
	t27 = t26 < 4:int                                                  bool
	if t27 goto 5 else 6
5:                                                      rangeindex.body P:1 S:2
	t28 = &t22.entry [#0]                                  *[4]cpuprofEntry
	t29 = &t28[t26]                                           *cpuprofEntry
	t30 = &t29.depth [#1]                                          *uintptr
	t31 = *t30                                                      uintptr
	t32 = len(pc)                                                       int
	t33 = convert uintptr <- int (t32)                              uintptr
	t34 = t31 != t33                                                   bool
	if t34 goto 4 else 7
6:                                                      rangeindex.done P:1 S:1
	t35 = &t22.entry [#0]                                  *[4]cpuprofEntry
	t36 = *t35                                              [4]cpuprofEntry
	jump 11
7:                                                              if.done P:1 S:1
	t37 = len(pc)                                                       int
	jump 8
8:                                                      rangeindex.loop P:2 S:2
	t38 = phi [7: -1:int, 9: t39]                                       int
	t39 = t38 + 1:int                                                   int
	t40 = t39 < t37                                                    bool
	if t40 goto 9 else 10
9:                                                      rangeindex.body P:1 S:2
	t41 = &t29.stack [#2]                                      *[64]uintptr
	t42 = &t41[t39]                                                *uintptr
	t43 = *t42                                                      uintptr
	t44 = &pc[t39]                                                 *uintptr
	t45 = *t44                                                      uintptr
	t46 = t43 != t45                                                   bool
	if t46 goto 4 else 8
10:                                                     rangeindex.done P:1 S:0
	t47 = &t29.count [#0]                                          *uintptr
	t48 = *t47                                                      uintptr
	t49 = t48 + 1:uintptr                                           uintptr
	*t47 = t49
	return
11:                                                     rangeindex.loop P:3 S:2
	t50 = phi [6: nil:*cpuprofEntry, 15: t50, 14: t59] #e     *cpuprofEntry
	t51 = phi [6: -1:int, 15: t52, 14: t52]                             int
	t52 = t51 + 1:int                                                   int
	t53 = t52 < 4:int                                                  bool
	if t53 goto 12 else 13
12:                                                     rangeindex.body P:1 S:2
	t54 = t50 == nil:*cpuprofEntry                                     bool
	if t54 goto 14 else 15
13:                                                     rangeindex.done P:1 S:2
	t55 = &t50.count [#0]                                          *uintptr
	t56 = *t55                                                      uintptr
	t57 = t56 > 0:uintptr                                              bool
	if t57 goto 16 else 17
14:                                                             if.then P:2 S:1
	t58 = &t22.entry [#0]                                  *[4]cpuprofEntry
	t59 = &t58[t52]                                           *cpuprofEntry
	jump 11
15:                                                          cond.false P:1 S:2
	t60 = &t22.entry [#0]                                  *[4]cpuprofEntry
	t61 = &t60[t52]                                           *cpuprofEntry
	t62 = &t61.count [#0]                                          *uintptr
	t63 = *t62                                                      uintptr
	t64 = &t50.count [#0]                                          *uintptr
	t65 = *t64                                                      uintptr
	t66 = t63 < t65                                                    bool
	if t66 goto 14 else 11
16:                                                             if.then P:1 S:2
	t67 = (*cpuProfile).evict(p, t50)                                  bool
	if t67 goto 19 else 18
17:                                                             if.done P:2 S:0
	t68 = &t50.depth [#1]                                          *uintptr
	t69 = len(pc)                                                       int
	t70 = convert uintptr <- int (t69)                              uintptr
	*t68 = t70
	t71 = &t50.count [#0]                                          *uintptr
	*t71 = 1:uintptr
	t72 = &t50.stack [#2]                                      *[64]uintptr
	t73 = slice t72[:]                                            []uintptr
	t74 = copy(t73, pc)                                                 int
	return
18:                                                             if.then P:1 S:0
	t75 = &p.lost [#4]                                             *uintptr
	t76 = *t75                                                      uintptr
	t77 = t76 + 1:uintptr                                           uintptr
	*t75 = t77
	return
19:                                                             if.done P:1 S:1
	t78 = &p.evicts [#3]                                           *uintptr
	t79 = *t78                                                      uintptr
	t80 = t79 + 1:uintptr                                           uintptr
	*t78 = t80
	jump 17

# Name: (*runtime.cpuProfile).evict
# Package: runtime
# Location: /usr/local/go/src/runtime/cpuprof.go:257:22
func (p *cpuProfile) evict(e *cpuprofEntry) bool:
0:                                                                entry P:0 S:2
	t0 = &e.depth [#1]                                             *uintptr
	t1 = *t0                                                        uintptr
	t2 = t1 + 2:uintptr                                             uintptr
	t3 = &p.log [#6]                                     *[2][65536]uintptr
	t4 = &p.toggle [#8]                                              *int32
	t5 = *t4                                                          int32
	t6 = convert int <- int32 (t5)                                      int
	t7 = &t3[t6]                                            *[65536]uintptr
	t8 = &p.nlog [#7]                                              *uintptr
	t9 = *t8                                                        uintptr
	t10 = t9 + t2                                                   uintptr
	t11 = t10 > 65536:uintptr                                          bool
	if t11 goto 1 else 2
1:                                                              if.then P:1 S:2
	t12 = (*cpuProfile).flushlog(p)                                    bool
	if t12 goto 4 else 3
2:                                                              if.done P:2 S:0
	t13 = phi [0: t7, 4: t35] #log                          *[65536]uintptr
	t14 = &p.nlog [#7]                                             *uintptr
	t15 = *t14                                                      uintptr
	t16 = convert int <- uintptr (t15)                                  int
	t17 = &t13[t16]                                                *uintptr
	t18 = &e.count [#0]                                            *uintptr
	t19 = *t18                                                      uintptr
	*t17 = t19
	t20 = t15 + 1:uintptr                                           uintptr
	t21 = convert int <- uintptr (t20)                                  int
	t22 = &t13[t21]                                                *uintptr
	*t22 = t1
	t23 = t20 + 1:uintptr                                           uintptr
	t24 = slice t13[t23:]                                         []uintptr
	t25 = &e.stack [#2]                                        *[64]uintptr
	t26 = slice t25[:t1]                                          []uintptr
	t27 = copy(t24, t26)                                                int
	t28 = t23 + t1                                                  uintptr
	t29 = &p.nlog [#7]                                             *uintptr
	*t29 = t28
	t30 = &e.count [#0]                                            *uintptr
	*t30 = 0:uintptr
	return true:bool
3:                                                              if.then P:1 S:0
	return false:bool
4:                                                              if.done P:1 S:1
	t31 = &p.log [#6]                                    *[2][65536]uintptr
	t32 = &p.toggle [#8]                                             *int32
	t33 = *t32                                                        int32
	t34 = convert int <- int32 (t33)                                    int
	t35 = &t31[t34]                                         *[65536]uintptr
	jump 2

# Name: (*runtime.cpuProfile).flushlog
# Package: runtime
# Location: /usr/local/go/src/runtime/cpuprof.go:284:22
func (p *cpuProfile) flushlog() bool:
0:                                                                entry P:0 S:2
	t0 = &p.handoff [#9]                                            *uint32
	t1 = &p.nlog [#7]                                              *uintptr
	t2 = *t1                                                        uintptr
	t3 = convert uint32 <- uintptr (t2)                              uint32
	t4 = cas(t0, 0:uint32, t3)                                         bool
	if t4 goto 2 else 1
1:                                                              if.then P:1 S:0
	return false:bool
2:                                                              if.done P:1 S:2
	t5 = &p.wait [#1]                                                 *note
	t6 = notewakeup(t5)                                                  ()
	t7 = &p.toggle [#8]                                              *int32
	t8 = &p.toggle [#8]                                              *int32
	t9 = *t8                                                          int32
	t10 = 1:int32 - t9                                                int32
	*t7 = t10
	t11 = &p.log [#6]                                    *[2][65536]uintptr
	t12 = &p.toggle [#8]                                             *int32
	t13 = *t12                                                        int32
	t14 = convert int <- int32 (t13)                                    int
	t15 = &t11[t14]                                         *[65536]uintptr
	t16 = &p.lost [#4]                                             *uintptr
	t17 = *t16                                                      uintptr
	t18 = t17 > 0:uintptr                                              bool
	if t18 goto 3 else 4
3:                                                              if.then P:1 S:1
	t19 = make interface{} <- func() (lostProfileData)          interface{}
	t20 = funcPC(t19)                                               uintptr
	t21 = &t15[0:int]                                              *uintptr
	t22 = &p.lost [#4]                                             *uintptr
	t23 = *t22                                                      uintptr
	*t21 = t23
	t24 = &t15[1:int]                                              *uintptr
	*t24 = 1:uintptr
	t25 = &t15[2:int]                                              *uintptr
	*t25 = t20
	t26 = &p.lost [#4]                                             *uintptr
	*t26 = 0:uintptr
	jump 4
4:                                                              if.done P:2 S:0
	t27 = phi [2: 0:uintptr, 3: 3:uintptr] #q                       uintptr
	t28 = &p.nlog [#7]                                             *uintptr
	*t28 = t27
	return true:bool

# Name: (*runtime.cpuProfile).getprofile
# Package: runtime
# Location: /usr/local/go/src/runtime/cpuprof.go:307:22
func (p *cpuProfile) getprofile() []byte:
0:                                                                entry P:0 S:2
	t0 = p == nil:*cpuProfile                                          bool
	if t0 goto 1 else 2
1:                                                              if.then P:1 S:0
	return nil:[]byte
2:                                                              if.done P:1 S:2
	t1 = &p.wholding [#11]                                            *bool
	t2 = *t1                                                           bool
	if t2 goto 4 else 3
3:                                                              if.done P:2 S:2
	t3 = phi [2: 0:uint32, 10: t7] #n                                uint32
	t4 = &p.flushing [#12]                                            *bool
	t5 = *t4                                                           bool
	if t5 goto 9 else 11
4:                                                             for.body P:2 S:2
	t6 = &p.handoff [#9]                                            *uint32
	t7 = *t6                                                         uint32
	t8 = t7 == 0:uint32                                                bool
	if t8 goto 5 else 6
5:                                                              if.then P:1 S:0
	t9 = print("runtime: phase er...":string)                            ()
	return nil:[]byte
6:                                                              if.done P:1 S:2
	t10 = t7 & 2147483648:uint32                                     uint32
	t11 = t10 != 0:uint32                                              bool
	if t11 goto 7 else 8
7:                                                              if.then P:1 S:1
	t12 = &p.wtoggle [#10]                                          *uint32
	t13 = &p.wtoggle [#10]                                          *uint32
	t14 = *t13                                                       uint32
	t15 = 1:uint32 - t14                                             uint32
	*t12 = t15
	t16 = &p.wholding [#11]                                           *bool
	*t16 = false:bool
	t17 = &p.flushing [#12]                                           *bool
	*t17 = true:bool
	jump 9
8:                                                              if.done P:1 S:2
	t18 = &p.handoff [#9]                                           *uint32
	t19 = cas(t18, t7, 0:uint32)                                       bool
	if t19 goto 10 else 4
9:                                                                Flush P:3 S:1
	t20 = &p.hash [#5]                 *[1024]struct{entry [4]cpuprofEntry}
	t21 = *t20                          [1024]struct{entry [4]cpuprofEntry}
	jump 19
10:                                                             if.then P:1 S:1
	t22 = &p.wtoggle [#10]                                          *uint32
	t23 = &p.wtoggle [#10]                                          *uint32
	t24 = *t23                                                       uint32
	t25 = 1:uint32 - t24                                             uint32
	*t22 = t25
	t26 = &p.wholding [#11]                                           *bool
	*t26 = false:bool
	jump 3
11:                                                             if.done P:1 S:2
	t27 = &p.on [#0]                                                  *bool
	t28 = *t27                                                         bool
	if t28 goto 13 else 14
12:                                                             if.then P:1 S:0
	return nil:[]byte
13:                                                             if.done P:2 S:2
	t29 = &p.wait [#1]                                                *note
	t30 = notetsleepg(t29, -1:int64)                                   bool
	t31 = &p.wait [#1]                                                *note
	t32 = noteclear(t31)                                                 ()
	t33 = &p.handoff [#9]                                           *uint32
	t34 = *t33                                                       uint32
	t35 = t34 == 0:uint32                                              bool
	if t35 goto 15 else 17
14:                                                           cond.true P:1 S:2
	t36 = &p.handoff [#9]                                           *uint32
	t37 = *t36                                                       uint32
	t38 = t37 == 0:uint32                                              bool
	if t38 goto 12 else 13
15:                                                         switch.body P:1 S:0
	t39 = print("runtime: phase er...":string)                           ()
	return nil:[]byte
16:                                                         switch.body P:1 S:1
	t40 = &p.flushing [#12]                                           *bool
	*t40 = true:bool
	jump 9
17:                                                         switch.next P:1 S:2
	t41 = t34 == 2147483648:uint32                                     bool
	if t41 goto 16 else 18
18:                                                         switch.next P:1 S:0
	t42 = t34 &^ 2147483648:uint32                                   uint32
	t43 = &p.wholding [#11]                                           *bool
	*t43 = true:bool
	t44 = &p.log [#6]                                    *[2][65536]uintptr
	t45 = &p.wtoggle [#10]                                          *uint32
	t46 = *t45                                                       uint32
	t47 = convert int <- uint32 (t46)                                   int
	t48 = &t44[t47]                                         *[65536]uintptr
	t49 = slice t48[:t42]                                         []uintptr
	t50 = uintptrBytes(t49)                                          []byte
	return t50
19:                                                     rangeindex.loop P:2 S:2
	t51 = phi [9: 0:int, 22: t57] #i                                    int
	t52 = phi [9: -1:int, 22: t57]                                      int
	t53 = phi [9: nil:*struct{entry [4]cpuprofEntry}, 22: t60] #b *struct{entry [4]cpuprofEntry}
	t54 = phi [9: 0:int, 22: t66] #j                                    int
	t55 = phi [9: 0:int, 22: t69]                                       int
	t56 = phi [9: nil:*cpuprofEntry, 22: t68] #e              *cpuprofEntry
	t57 = t52 + 1:int                                                   int
	t58 = t57 < 1024:int                                               bool
	if t58 goto 20 else 21
20:                                                     rangeindex.body P:1 S:1
	t59 = &p.hash [#5]                 *[1024]struct{entry [4]cpuprofEntry}
	t60 = &t59[t57]                          *struct{entry [4]cpuprofEntry}
	t61 = &t60.entry [#0]                                  *[4]cpuprofEntry
	t62 = *t61                                              [4]cpuprofEntry
	jump 22
21:                                                     rangeindex.done P:2 S:2
	t63 = &p.nlog [#7]                                             *uintptr
	t64 = *t63                                                      uintptr
	t65 = t64 > 0:uintptr                                              bool
	if t65 goto 25 else 26
22:                                                     rangeindex.loop P:3 S:2
	t66 = phi [20: 0:int, 23: t69, 24: t69] #j                          int
	t67 = phi [20: -1:int, 23: t69, 24: t69]                            int
	t68 = phi [20: t56, 23: t72, 24: t72] #e                  *cpuprofEntry
	t69 = t67 + 1:int                                                   int
	t70 = t69 < 4:int                                                  bool
	if t70 goto 23 else 19
23:                                                     rangeindex.body P:1 S:2
	t71 = &t60.entry [#0]                                  *[4]cpuprofEntry
	t72 = &t71[t69]                                           *cpuprofEntry
	t73 = &t72.count [#0]                                          *uintptr
	t74 = *t73                                                      uintptr
	t75 = t74 > 0:uintptr                                              bool
	if t75 goto 24 else 22
24:                                                           cond.true P:1 S:2
	t76 = (*cpuProfile).evict(p, t72)                                  bool
	if t76 goto 22 else 21
25:                                                             if.then P:1 S:0
	t77 = &p.nlog [#7]                                             *uintptr
	t78 = *t77                                                      uintptr
	t79 = &p.nlog [#7]                                             *uintptr
	*t79 = 0:uintptr
	t80 = &p.log [#6]                                    *[2][65536]uintptr
	t81 = &p.toggle [#8]                                             *int32
	t82 = *t81                                                        int32
	t83 = convert int <- int32 (t82)                                    int
	t84 = &t80[t83]                                         *[65536]uintptr
	t85 = slice t84[:t78]                                         []uintptr
	t86 = uintptrBytes(t85)                                          []byte
	return t86
26:                                                             if.done P:1 S:2
	t87 = &p.eodSent [#13]                                            *bool
	t88 = *t87                                                         bool
	if t88 goto 28 else 27
27:                                                             if.then P:1 S:0
	t89 = &p.eodSent [#13]                                            *bool
	*t89 = true:bool
	t90 = slice eod[:]                                            []uintptr
	t91 = uintptrBytes(t90)                                          []byte
	return t91
28:                                                             if.done P:1 S:2
	t92 = &p.flushing [#12]                                           *bool
	*t92 = false:bool
	t93 = &p.handoff [#9]                                           *uint32
	t94 = &p.handoff [#9]                                           *uint32
	t95 = *t94                                                       uint32
	t96 = cas(t93, t95, 0:uint32)                                      bool
	if t96 goto 30 else 29
29:                                                             if.then P:1 S:1
	t97 = print("runtime: profile ...":string)                           ()
	jump 30
30:                                                             if.done P:2 S:0
	return nil:[]byte

# Name: runtime.uintptrBytes
# Package: runtime
# Location: /usr/local/go/src/runtime/cpuprof.go:404:6
func uintptrBytes(p []uintptr) (ret []byte):
0:                                                                entry P:0 S:0
	t0 = new []uintptr (p)                                       *[]uintptr
	*t0 = p
	t1 = new []byte (ret)                                           *[]byte
	t2 = convert unsafe.Pointer <- *[]uintptr (t0)           unsafe.Pointer
	t3 = convert *sliceStruct <- unsafe.Pointer (t2)           *sliceStruct
	t4 = convert unsafe.Pointer <- *[]byte (t1)              unsafe.Pointer
	t5 = convert *sliceStruct <- unsafe.Pointer (t4)           *sliceStruct
	t6 = &t5.array [#0]                                     *unsafe.Pointer
	t7 = &t3.array [#0]                                     *unsafe.Pointer
	t8 = *t7                                                 unsafe.Pointer
	*t6 = t8
	t9 = &t5.len [#1]                                                  *int
	t10 = &t3.len [#1]                                                 *int
	t11 = *t10                                                          int
	t12 = t11 * 8:int                                                   int
	*t9 = t12
	t13 = &t5.cap [#2]                                                 *int
	t14 = &t5.len [#1]                                                 *int
	t15 = *t14                                                          int
	*t13 = t15
	t16 = *t1                                                        []byte
	return t16

# Name: runtime.CPUProfile
# Package: runtime
# Location: /usr/local/go/src/runtime/cpuprof.go:423:6
func CPUProfile() []byte:
0:                                                                entry P:0 S:0
	t0 = *cpuprof                                               *cpuProfile
	t1 = (*cpuProfile).getprofile(t0)                                []byte
	return t1

# Name: runtime.GOMAXPROCS
# Package: runtime
# Location: /usr/local/go/src/runtime/debug.go:26:6
func GOMAXPROCS(n int) int:
0:                                                                entry P:0 S:2
	t0 = n > 256:int                                                   bool
	if t0 goto 1 else 2
1:                                                              if.then P:1 S:1
	jump 2
2:                                                              if.done P:2 S:2
	t1 = phi [0: n, 1: 256:int] #n                                      int
	t2 = &sched.lock [#0]                                            *mutex
	t3 = lock(t2)                                                        ()
	t4 = *gomaxprocs                                                  int32
	t5 = convert int <- int32 (t4)                                      int
	t6 = &sched.lock [#0]                                            *mutex
	t7 = unlock(t6)                                                      ()
	t8 = t1 <= 0:int                                                   bool
	if t8 goto 3 else 5
3:                                                              if.then P:2 S:0
	return t5
4:                                                              if.done P:1 S:0
	t9 = semacquire(worldsema, false:bool)                               ()
	t10 = getg()                                                         *g
	t11 = &t10.m [#21]                                                  **m
	t12 = *t11                                                           *m
	t13 = &t12.gcing [#13]                                           *int32
	*t13 = 1:int32
	t14 = onM(stoptheworld)                                              ()
	t15 = convert int32 <- int (t1)                                   int32
	*newprocs = t15
	t16 = &t10.m [#21]                                                  **m
	t17 = *t16                                                           *m
	t18 = &t17.gcing [#13]                                           *int32
	*t18 = 0:int32
	t19 = semrelease(worldsema)                                          ()
	t20 = onM(starttheworld)                                             ()
	return t5
5:                                                           cond.false P:1 S:2
	t21 = t1 == t5                                                     bool
	if t21 goto 3 else 4

# Name: runtime.NumCPU
# Package: runtime
# Location: /usr/local/go/src/runtime/debug.go:52:6
func NumCPU() int:
0:                                                                entry P:0 S:0
	t0 = *ncpu                                                        int32
	t1 = convert int <- int32 (t0)                                      int
	return t1

# Name: runtime.NumCgoCall
# Package: runtime
# Location: /usr/local/go/src/runtime/debug.go:57:6
func NumCgoCall() int64:
0:                                                                entry P:0 S:1
	t0 = convert unsafe.Pointer <- **m (allm)                unsafe.Pointer
	t1 = atomicloadp(t0)                                     unsafe.Pointer
	t2 = convert *m <- unsafe.Pointer (t1)                               *m
	jump 3
1:                                                             for.body P:1 S:1
	t3 = &t10.ncgocall [#22]                                        *uint64
	t4 = *t3                                                         uint64
	t5 = convert int64 <- uint64 (t4)                                 int64
	t6 = t9 + t5                                                      int64
	t7 = &t10.alllink [#26]                                             **m
	t8 = *t7                                                             *m
	jump 3
2:                                                             for.done P:1 S:0
	return t9
3:                                                             for.loop P:2 S:2
	t9 = phi [0: 0:int64, 1: t6] #n                                   int64
	t10 = phi [0: t2, 1: t8] #mp                                         *m
	t11 = t10 != nil:*m                                                bool
	if t11 goto 1 else 2

# Name: runtime.NumGoroutine
# Package: runtime
# Location: /usr/local/go/src/runtime/debug.go:66:6
func NumGoroutine() int:
0:                                                                entry P:0 S:0
	t0 = gcount()                                                     int32
	t1 = convert int <- int32 (t0)                                      int
	return t1

# Name: runtime.getenv
# Package: runtime
# Location: /usr/local/go/src/runtime/env_posix.go:13:6
func getenv(s *byte) *byte:
0:                                                                entry P:0 S:2
	t0 = gostringnocopy(s)                                           string
	t1 = gogetenv(t0)                                                string
	t2 = t1 == "":string                                               bool
	if t2 goto 1 else 2
1:                                                              if.then P:1 S:0
	return nil:*byte
2:                                                              if.done P:1 S:0
	t3 = bytes(t1)                                                   []byte
	t4 = &t3[0:int]                                                   *byte
	return t4

# Name: runtime.gogetenv
# Package: runtime
# Location: /usr/local/go/src/runtime/env_posix.go:22:6
func gogetenv(key string) string:
0:                                                                entry P:0 S:2
	t0 = environ()                                                 []string
	t1 = t0 == nil:[]string                                            bool
	if t1 goto 1 else 2
1:                                                              if.then P:1 S:1
	t2 = gothrow("getenv before env...":string)                          ()
	jump 2
2:                                                              if.done P:2 S:1
	t3 = environ()                                                 []string
	t4 = len(t3)                                                        int
	jump 3
3:                                                      rangeindex.loop P:4 S:2
	t5 = phi [2: -1:int, 4: t6, 8: t6, 7: t6]                           int
	t6 = t5 + 1:int                                                     int
	t7 = t6 < t4                                                       bool
	if t7 goto 4 else 5
4:                                                      rangeindex.body P:1 S:2
	t8 = &t3[t6]                                                    *string
	t9 = *t8                                                         string
	t10 = len(t9)                                                       int
	t11 = len(key)                                                      int
	t12 = t10 > t11                                                    bool
	if t12 goto 8 else 3
5:                                                      rangeindex.done P:1 S:0
	return "":string
6:                                                              if.then P:1 S:0
	t13 = len(key)                                                      int
	t14 = t13 + 1:int                                                   int
	t15 = slice t9[t14:]                                             string
	return t15
7:                                                            cond.true P:1 S:2
	t16 = len(key)                                                      int
	t17 = slice t9[:t16]                                             string
	t18 = t17 == key                                                   bool
	if t18 goto 6 else 3
8:                                                            cond.true P:1 S:2
	t19 = len(key)                                                      int
	t20 = t9[t19]                                                     uint8
	t21 = t20 == 61:byte                                               bool
	if t21 goto 7 else 3

# Name: runtime.syscall_setenv_c
# Package: runtime
# Location: /usr/local/go/src/runtime/env_posix.go:40:6
func syscall_setenv_c(k string, v string):
0:                                                                entry P:0 S:2
	t0 = *_cgo_setenv                                               uintptr
	t1 = t0 == 0:uintptr                                               bool
	if t1 goto 1 else 2
1:                                                              if.then P:1 S:0
	return
2:                                                              if.done P:1 S:0
	t2 = new [2]unsafe.Pointer (arg)                     *[2]unsafe.Pointer
	t3 = &t2[0:int]                                         *unsafe.Pointer
	t4 = cstring(k)                                          unsafe.Pointer
	t5 = &t2[1:int]                                         *unsafe.Pointer
	t6 = cstring(v)                                          unsafe.Pointer
	*t3 = t4
	*t5 = t6
	t7 = *_cgo_setenv                                               uintptr
	t8 = convert unsafe.Pointer <- uintptr (t7)              unsafe.Pointer
	t9 = convert unsafe.Pointer <- *[2]unsafe.Pointer (t2)   unsafe.Pointer
	t10 = asmcgocall(t8, t9)                                             ()
	return

# Name: runtime.syscall_unsetenv_c
# Package: runtime
# Location: /usr/local/go/src/runtime/env_posix.go:50:6
func syscall_unsetenv_c(k string):
0:                                                                entry P:0 S:2
	t0 = *_cgo_unsetenv                                             uintptr
	t1 = t0 == 0:uintptr                                               bool
	if t1 goto 1 else 2
1:                                                              if.then P:1 S:0
	return
2:                                                              if.done P:1 S:0
	t2 = new [1]unsafe.Pointer (arg)                     *[1]unsafe.Pointer
	t3 = &t2[0:int]                                         *unsafe.Pointer
	t4 = cstring(k)                                          unsafe.Pointer
	*t3 = t4
	t5 = *_cgo_unsetenv                                             uintptr
	t6 = convert unsafe.Pointer <- uintptr (t5)              unsafe.Pointer
	t7 = convert unsafe.Pointer <- *[1]unsafe.Pointer (t2)   unsafe.Pointer
	t8 = asmcgocall(t6, t7)                                              ()
	return

# Name: runtime.cstring
# Package: runtime
# Location: /usr/local/go/src/runtime/env_posix.go:58:6
func cstring(s string) unsafe.Pointer:
0:                                                                entry P:0 S:0
	t0 = new string (s)                                             *string
	*t0 = s
	t1 = *t0                                                         string
	t2 = len(t1)                                                        int
	t3 = t2 + 1:int                                                     int
	t4 = make []byte t3 t3                                           []byte
	t5 = convert unsafe.Pointer <- *string (t0)              unsafe.Pointer
	t6 = convert *_string <- unsafe.Pointer (t5)                   *_string
	t7 = &t4[0:int]                                                   *byte
	t8 = convert unsafe.Pointer <- *byte (t7)                unsafe.Pointer
	t9 = &t6.str [#0]                                                **byte
	t10 = *t9                                                         *byte
	t11 = convert unsafe.Pointer <- *byte (t10)              unsafe.Pointer
	t12 = *t0                                                        string
	t13 = len(t12)                                                      int
	t14 = convert uintptr <- int (t13)                              uintptr
	t15 = memmove(t8, t11, t14)                                          ()
	t16 = &t4[0:int]                                                  *byte
	t17 = convert unsafe.Pointer <- *byte (t16)              unsafe.Pointer
	return t17

# Name: (*runtime.TypeAssertionError).RuntimeError
# Package: runtime
# Location: /usr/local/go/src/runtime/error.go:28:28
func (arg0 *TypeAssertionError) RuntimeError():
0:                                                                entry P:0 S:0
	return

# Name: (*runtime.TypeAssertionError).Error
# Package: runtime
# Location: /usr/local/go/src/runtime/error.go:30:30
func (e *TypeAssertionError) Error() string:
0:                                                                entry P:0 S:2
	t0 = &e.interfaceString [#0]                                    *string
	t1 = *t0                                                         string
	t2 = t1 == "":string                                               bool
	if t2 goto 1 else 2
1:                                                              if.then P:1 S:1
	jump 2
2:                                                              if.done P:2 S:2
	t3 = phi [0: t1, 1: "interface":string] #inter                   string
	t4 = &e.concreteString [#1]                                     *string
	t5 = *t4                                                         string
	t6 = t5 == "":string                                               bool
	if t6 goto 3 else 4
3:                                                              if.then P:1 S:0
	t7 = "interface convers...":string + t3                          string
	t8 = t7 + " is nil, not ":string                                 string
	t9 = &e.assertedString [#2]                                     *string
	t10 = *t9                                                        string
	t11 = t8 + t10                                                   string
	return t11
4:                                                              if.done P:1 S:2
	t12 = &e.missingMethod [#3]                                     *string
	t13 = *t12                                                       string
	t14 = t13 == "":string                                             bool
	if t14 goto 5 else 6
5:                                                              if.then P:1 S:0
	t15 = "interface convers...":string + t3                         string
	t16 = t15 + " is ":string                                        string
	t17 = &e.concreteString [#1]                                    *string
	t18 = *t17                                                       string
	t19 = t16 + t18                                                  string
	t20 = t19 + ", not ":string                                      string
	t21 = &e.assertedString [#2]                                    *string
	t22 = *t21                                                       string
	t23 = t20 + t22                                                  string
	return t23
6:                                                              if.done P:1 S:0
	t24 = &e.concreteString [#1]                                    *string
	t25 = *t24                                                       string
	t26 = "interface convers...":string + t25                        string
	t27 = t26 + " is not ":string                                    string
	t28 = &e.assertedString [#2]                                    *string
	t29 = *t28                                                       string
	t30 = t27 + t29                                                  string
	t31 = t30 + ": missing method ":string                           string
	t32 = &e.missingMethod [#3]                                     *string
	t33 = *t32                                                       string
	t34 = t31 + t33                                                  string
	return t34

# Name: runtime.newTypeAssertionError
# Package: runtime
# Location: /usr/local/go/src/runtime/error.go:47:6
func newTypeAssertionError(ps1 *string, ps2 *string, ps3 *string, pmeth *string, ret *interface{}):
0:                                                                entry P:0 S:2
	t0 = ps1 != nil:*string                                            bool
	if t0 goto 1 else 2
1:                                                              if.then P:1 S:1
	t1 = *ps1                                                        string
	jump 2
2:                                                              if.done P:2 S:2
	t2 = phi [0: "":string, 1: t1] #s1                               string
	t3 = ps2 != nil:*string                                            bool
	if t3 goto 3 else 4
3:                                                              if.then P:1 S:1
	t4 = *ps2                                                        string
	jump 4
4:                                                              if.done P:2 S:2
	t5 = phi [2: "":string, 3: t4] #s2                               string
	t6 = ps3 != nil:*string                                            bool
	if t6 goto 5 else 6
5:                                                              if.then P:1 S:1
	t7 = *ps3                                                        string
	jump 6
6:                                                              if.done P:2 S:2
	t8 = phi [4: "":string, 5: t7] #s3                               string
	t9 = pmeth != nil:*string                                          bool
	if t9 goto 7 else 8
7:                                                              if.then P:1 S:1
	t10 = *pmeth                                                     string
	jump 8
8:                                                              if.done P:2 S:0
	t11 = phi [6: "":string, 7: t10] #meth                           string
	t12 = new TypeAssertionError (complit)              *TypeAssertionError
	t13 = &t12.interfaceString [#0]                                 *string
	t14 = &t12.concreteString [#1]                                  *string
	t15 = &t12.assertedString [#2]                                  *string
	t16 = &t12.missingMethod [#3]                                   *string
	*t13 = t2
	*t14 = t5
	*t15 = t8
	*t16 = t11
	t17 = make interface{} <- *TypeAssertionError (t12)         interface{}
	*ret = t17
	return

# Name: (runtime.errorString).RuntimeError
# Package: runtime
# Location: /usr/local/go/src/runtime/error.go:68:22
func (e errorString) RuntimeError():
0:                                                                entry P:0 S:0
	return

# Name: (runtime.errorString).Error
# Package: runtime
# Location: /usr/local/go/src/runtime/error.go:70:22
func (e errorString) Error() string:
0:                                                                entry P:0 S:0
	t0 = changetype string <- errorString (e)                        string
	t1 = "runtime error: ":string + t0                               string
	return t1

# Name: runtime.typestring
# Package: runtime
# Location: /usr/local/go/src/runtime/error.go:78:6
func typestring(x interface{}) string:
0:                                                                entry P:0 S:0
	t0 = new interface{} (x)                                   *interface{}
	*t0 = x
	t1 = convert unsafe.Pointer <- *interface{} (t0)         unsafe.Pointer
	t2 = convert *eface <- unsafe.Pointer (t1)                       *eface
	t3 = &t2._type [#0]                                             **_type
	t4 = *t3                                                         *_type
	t5 = &t4._string [#8]                                          **string
	t6 = *t5                                                        *string
	t7 = *t6                                                         string
	return t7

# Name: runtime.printany
# Package: runtime
# Location: /usr/local/go/src/runtime/error.go:87:6
func printany(i interface{}):
0:                                                                entry P:0 S:2
	t0 = i == nil:interface{}                                          bool
	if t0 goto 2 else 3
1:                                                      typeswitch.done P:6 S:0
	return
2:                                                      typeswitch.body P:1 S:1
	t1 = print("nil":string)                                             ()
	jump 1
3:                                                      typeswitch.next P:1 S:2
	t2 = typeassert,ok i.(stringer)               (value stringer, ok bool)
	t3 = extract t2 #0                                             stringer
	t4 = extract t2 #1                                                 bool
	if t4 goto 4 else 5
4:                                                      typeswitch.body P:1 S:1
	t5 = invoke t3.String()                                          string
	t6 = print(t5)                                                       ()
	jump 1
5:                                                      typeswitch.next P:1 S:2
	t7 = typeassert,ok i.(error)                     (value error, ok bool)
	t8 = extract t7 #0                                                error
	t9 = extract t7 #1                                                 bool
	if t9 goto 6 else 7
6:                                                      typeswitch.body P:1 S:1
	t10 = invoke t8.Error()                                          string
	t11 = print(t10)                                                     ()
	jump 1
7:                                                      typeswitch.next P:1 S:2
	t12 = typeassert,ok i.(int)                        (value int, ok bool)
	t13 = extract t12 #0                                                int
	t14 = extract t12 #1                                               bool
	if t14 goto 8 else 9
8:                                                      typeswitch.body P:1 S:1
	t15 = print(t13)                                                     ()
	jump 1
9:                                                      typeswitch.next P:1 S:2
	t16 = typeassert,ok i.(string)                  (value string, ok bool)
	t17 = extract t16 #0                                             string
	t18 = extract t16 #1                                               bool
	if t18 goto 10 else 11
10:                                                     typeswitch.body P:1 S:1
	t19 = print(t17)                                                     ()
	jump 1
11:                                                     typeswitch.next P:1 S:1
	t20 = typestring(i)                                              string
	t21 = print("(":string, t20, ") ":string, i)                         ()
	jump 1

# Name: runtime.panicwrap
# Package: runtime
# Location: /usr/local/go/src/runtime/error.go:105:6
func panicwrap(pkg string, typ string, meth string):
0:                                                                entry P:0 S:0
	t0 = "value method ":string + pkg                                string
	t1 = t0 + ".":string                                             string
	t2 = t1 + typ                                                    string
	t3 = t2 + ".":string                                             string
	t4 = t3 + meth                                                   string
	t5 = t4 + " called using nil *":string                           string
	t6 = t5 + typ                                                    string
	t7 = t6 + " pointer":string                                      string
	t8 = make interface{} <- string (t7)                        interface{}
	panic t8

# Name: runtime.Caller
# Package: runtime
# Location: /usr/local/go/src/runtime/extern.go:90:6
func Caller(skip int) (pc uintptr, file string, line int, ok bool):
0:                                                                entry P:0 S:2
	t0 = new string (file)                                          *string
	t1 = new [2]uintptr (rpc)                                   *[2]uintptr
	t2 = 1:int + skip                                                   int
	t3 = t2 - 1:int                                                     int
	t4 = &t1[0:int]                                                *uintptr
	t5 = callers(t3, t4, 2:int)                                         int
	t6 = t5 < 2:int                                                    bool
	if t6 goto 1 else 2
1:                                                              if.then P:1 S:0
	t7 = *t0                                                         string
	return 0:uintptr, t7, 0:int, false:bool
2:                                                              if.done P:1 S:2
	t8 = &t1[1:int]                                                *uintptr
	t9 = *t8                                                        uintptr
	t10 = findfunc(t9)                                               *_func
	t11 = t10 == nil:*_func                                            bool
	if t11 goto 3 else 4
3:                                                              if.then P:1 S:0
	t12 = *t0                                                        string
	return 0:uintptr, t12, 0:int, true:bool
4:                                                              if.done P:1 S:2
	t13 = &t1[1:int]                                               *uintptr
	t14 = *t13                                                      uintptr
	t15 = &t1[0:int]                                               *uintptr
	t16 = *t15                                                      uintptr
	t17 = findfunc(t16)                                              *_func
	t18 = &t10.entry [#0]                                          *uintptr
	t19 = *t18                                                      uintptr
	t20 = t14 > t19                                                    bool
	if t20 goto 7 else 6
5:                                                              if.then P:2 S:1
	t21 = t14 - 1:uintptr                                           uintptr
	jump 6
6:                                                              if.done P:3 S:0
	t22 = phi [4: t14, 8: t14, 5: t21] #xpc                         uintptr
	t23 = funcline(t10, t22, t0)                                      int32
	t24 = convert int <- int32 (t23)                                    int
	t25 = *t0                                                        string
	return t14, t25, t24, true:bool
7:                                                            cond.true P:1 S:2
	t26 = t17 == nil:*_func                                            bool
	if t26 goto 5 else 8
8:                                                           cond.false P:1 S:2
	t27 = &t17.entry [#0]                                          *uintptr
	t28 = *t27                                                      uintptr
	t29 = make interface{} <- func() (sigpanic)                 interface{}
	t30 = funcPC(t29)                                               uintptr
	t31 = t28 != t30                                                   bool
	if t31 goto 5 else 6

# Name: runtime.Callers
# Package: runtime
# Location: /usr/local/go/src/runtime/extern.go:134:6
func Callers(skip int, pc []uintptr) int:
0:                                                                entry P:0 S:2
	t0 = len(pc)                                                        int
	t1 = t0 == 0:int                                                   bool
	if t1 goto 1 else 2
1:                                                              if.then P:1 S:0
	return 0:int
2:                                                              if.done P:1 S:0
	t2 = &pc[0:int]                                                *uintptr
	t3 = len(pc)                                                        int
	t4 = callers(skip, t2, t3)                                          int
	return t4

# Name: runtime.GOROOT
# Package: runtime
# Location: /usr/local/go/src/runtime/extern.go:147:6
func GOROOT() string:
0:                                                                entry P:0 S:2
	t0 = gogetenv("GOROOT":string)                                   string
	t1 = t0 != "":string                                               bool
	if t1 goto 1 else 2
1:                                                              if.then P:1 S:0
	return t0
2:                                                              if.done P:1 S:0
	return "/usr/local/go":string

# Name: runtime.Version
# Package: runtime
# Location: /usr/local/go/src/runtime/extern.go:158:6
func Version() string:
0:                                                                entry P:0 S:0
	return "go1.4.2":string

# Name: runtime.evacuated
# Package: runtime
# Location: /usr/local/go/src/runtime/hashmap.go:147:6
func evacuated(b *bmap) bool:
0:                                                                entry P:0 S:2
	t0 = &b.tophash [#0]                                          *[8]uint8
	t1 = &t0[0:int]                                                  *uint8
	t2 = *t1                                                          uint8
	t3 = t2 > 0:uint8                                                  bool
	if t3 goto 1 else 2
1:                                                            binop.rhs P:1 S:1
	t4 = t2 < 4:uint8                                                  bool
	jump 2
2:                                                           binop.done P:2 S:0
	t5 = phi [0: false:bool, 1: t4] #&&                                bool
	return t5

# Name: (*runtime.bmap).overflow
# Package: runtime
# Location: /usr/local/go/src/runtime/hashmap.go:152:16
func (b *bmap) overflow(t *maptype) *bmap:
0:                                                                entry P:0 S:0
	t0 = convert unsafe.Pointer <- *bmap (b)                 unsafe.Pointer
	t1 = &t.bucketsize [#9]                                         *uint16
	t2 = *t1                                                         uint16
	t3 = convert uintptr <- uint16 (t2)                             uintptr
	t4 = t3 - 8:uintptr                                             uintptr
	t5 = add(t0, t4)                                         unsafe.Pointer
	t6 = convert **bmap <- unsafe.Pointer (t5)                       **bmap
	t7 = *t6                                                          *bmap
	return t7

# Name: (*runtime.bmap).setoverflow
# Package: runtime
# Location: /usr/local/go/src/runtime/hashmap.go:155:16
func (b *bmap) setoverflow(t *maptype, ovf *bmap):
0:                                                                entry P:0 S:0
	t0 = convert unsafe.Pointer <- *bmap (b)                 unsafe.Pointer
	t1 = &t.bucketsize [#9]                                         *uint16
	t2 = *t1                                                         uint16
	t3 = convert uintptr <- uint16 (t2)                             uintptr
	t4 = t3 - 8:uintptr                                             uintptr
	t5 = add(t0, t4)                                         unsafe.Pointer
	t6 = convert **bmap <- unsafe.Pointer (t5)                       **bmap
	*t6 = ovf
	return

# Name: runtime.makemap
# Package: runtime
# Location: /usr/local/go/src/runtime/hashmap.go:159:6
func makemap(t *maptype, hint int64) *hmap:
0:                                                                entry P:0 S:2
	t0 = 48:uintptr > 48:uintptr                                       bool
	if t0 goto 1 else 3
1:                                                              if.then P:2 S:1
	t1 = gothrow("bad hmap size":string)                                 ()
	jump 2
2:                                                              if.done P:2 S:2
	t2 = hint < 0:int64                                                bool
	if t2 goto 4 else 6
3:                                                           cond.false P:1 S:2
	t3 = &t.hmap [#4]                                               **_type
	t4 = *t3                                                         *_type
	t5 = &t4.size [#0]                                             *uintptr
	t6 = *t5                                                        uintptr
	t7 = 48:uintptr != t6                                              bool
	if t7 goto 1 else 2
4:                                                              if.then P:2 S:0
	t8 = make interface{} <- string ("makemap: size out...":string) interface{}
	panic t8
5:                                                              if.done P:1 S:2
	t9 = &t.key [#1]                                                **_type
	t10 = *t9                                                        *_type
	t11 = ismapkey(t10)                                                bool
	if t11 goto 8 else 7
6:                                                           cond.false P:1 S:2
	t12 = convert int32 <- int64 (hint)                               int32
	t13 = convert int64 <- int32 (t12)                                int64
	t14 = t13 != hint                                                  bool
	if t14 goto 4 else 5
7:                                                              if.then P:1 S:1
	t15 = gothrow("runtime.makemap: ...":string)                         ()
	jump 8
8:                                                              if.done P:2 S:2
	t16 = &t.key [#1]                                               **_type
	t17 = *t16                                                       *_type
	t18 = &t17.size [#0]                                           *uintptr
	t19 = *t18                                                      uintptr
	t20 = t19 > 128:uintptr                                            bool
	if t20 goto 12 else 11
9:                                                              if.then P:4 S:1
	t21 = gothrow("key size wrong":string)                               ()
	jump 10
10:                                                             if.done P:3 S:2
	t22 = &t.elem [#2]                                              **_type
	t23 = *t22                                                       *_type
	t24 = &t23.size [#0]                                           *uintptr
	t25 = *t24                                                      uintptr
	t26 = t25 > 128:uintptr                                            bool
	if t26 goto 19 else 18
11:                                                          cond.false P:2 S:2
	t27 = &t.key [#1]                                               **_type
	t28 = *t27                                                       *_type
	t29 = &t28.size [#0]                                           *uintptr
	t30 = *t29                                                      uintptr
	t31 = t30 <= 128:uintptr                                           bool
	if t31 goto 14 else 10
12:                                                           cond.true P:1 S:2
	t32 = &t.indirectkey [#6]                                         *bool
	t33 = *t32                                                         bool
	if t33 goto 13 else 9
13:                                                          cond.false P:1 S:2
	t34 = &t.keysize [#5]                                            *uint8
	t35 = *t34                                                        uint8
	t36 = t35 != 8:uint8                                               bool
	if t36 goto 9 else 11
14:                                                           cond.true P:1 S:2
	t37 = &t.indirectkey [#6]                                         *bool
	t38 = *t37                                                         bool
	if t38 goto 9 else 15
15:                                                          cond.false P:1 S:2
	t39 = &t.keysize [#5]                                            *uint8
	t40 = *t39                                                        uint8
	t41 = &t.key [#1]                                               **_type
	t42 = *t41                                                       *_type
	t43 = &t42.size [#0]                                           *uintptr
	t44 = *t43                                                      uintptr
	t45 = convert uint8 <- uintptr (t44)                              uint8
	t46 = t40 != t45                                                   bool
	if t46 goto 9 else 10
16:                                                             if.then P:4 S:1
	t47 = gothrow("value size wrong":string)                             ()
	jump 17
17:                                                             if.done P:3 S:2
	t48 = &t.key [#1]                                               **_type
	t49 = *t48                                                       *_type
	t50 = &t49.align [#3]                                            *uint8
	t51 = *t50                                                        uint8
	t52 = t51 > 8:uint8                                                bool
	if t52 goto 23 else 24
18:                                                          cond.false P:2 S:2
	t53 = &t.elem [#2]                                              **_type
	t54 = *t53                                                       *_type
	t55 = &t54.size [#0]                                           *uintptr
	t56 = *t55                                                      uintptr
	t57 = t56 <= 128:uintptr                                           bool
	if t57 goto 21 else 17
19:                                                           cond.true P:1 S:2
	t58 = &t.indirectvalue [#8]                                       *bool
	t59 = *t58                                                         bool
	if t59 goto 20 else 16
20:                                                          cond.false P:1 S:2
	t60 = &t.valuesize [#7]                                          *uint8
	t61 = *t60                                                        uint8
	t62 = t61 != 8:uint8                                               bool
	if t62 goto 16 else 18
21:                                                           cond.true P:1 S:2
	t63 = &t.indirectvalue [#8]                                       *bool
	t64 = *t63                                                         bool
	if t64 goto 16 else 22
22:                                                          cond.false P:1 S:2
	t65 = &t.valuesize [#7]                                          *uint8
	t66 = *t65                                                        uint8
	t67 = &t.elem [#2]                                              **_type
	t68 = *t67                                                       *_type
	t69 = &t68.size [#0]                                           *uintptr
	t70 = *t69                                                      uintptr
	t71 = convert uint8 <- uintptr (t70)                              uint8
	t72 = t66 != t71                                                   bool
	if t72 goto 16 else 17
23:                                                             if.then P:1 S:1
	t73 = gothrow("key align too big":string)                            ()
	jump 24
24:                                                             if.done P:2 S:2
	t74 = &t.elem [#2]                                              **_type
	t75 = *t74                                                       *_type
	t76 = &t75.align [#3]                                            *uint8
	t77 = *t76                                                        uint8
	t78 = t77 > 8:uint8                                                bool
	if t78 goto 25 else 26
25:                                                             if.then P:1 S:1
	t79 = gothrow("value align too big":string)                          ()
	jump 26
26:                                                             if.done P:2 S:2
	t80 = &t.key [#1]                                               **_type
	t81 = *t80                                                       *_type
	t82 = &t81.size [#0]                                           *uintptr
	t83 = *t82                                                      uintptr
	t84 = &t.key [#1]                                               **_type
	t85 = *t84                                                       *_type
	t86 = &t85.align [#3]                                            *uint8
	t87 = *t86                                                        uint8
	t88 = convert uintptr <- uint8 (t87)                            uintptr
	t89 = t83 % t88                                                 uintptr
	t90 = t89 != 0:uintptr                                             bool
	if t90 goto 27 else 28
27:                                                             if.then P:1 S:1
	t91 = gothrow("key size not a mu...":string)                         ()
	jump 28
28:                                                             if.done P:2 S:2
	t92 = &t.elem [#2]                                              **_type
	t93 = *t92                                                       *_type
	t94 = &t93.size [#0]                                           *uintptr
	t95 = *t94                                                      uintptr
	t96 = &t.elem [#2]                                              **_type
	t97 = *t96                                                       *_type
	t98 = &t97.align [#3]                                            *uint8
	t99 = *t98                                                        uint8
	t100 = convert uintptr <- uint8 (t99)                           uintptr
	t101 = t95 % t100                                               uintptr
	t102 = t101 != 0:uintptr                                           bool
	if t102 goto 29 else 30
29:                                                             if.then P:1 S:1
	t103 = gothrow("value size not a ...":string)                        ()
	jump 30
30:                                                             if.done P:2 S:2
	if false:untyped bool goto 31 else 32
31:                                                             if.then P:1 S:1
	t104 = gothrow("bucketsize too sm...":string)                        ()
	jump 32
32:                                                             if.done P:2 S:2
	t105 = &t.key [#1]                                              **_type
	t106 = *t105                                                     *_type
	t107 = &t106.align [#3]                                          *uint8
	t108 = *t107                                                      uint8
	t109 = convert uintptr <- uint8 (t108)                          uintptr
	t110 = 8:uintptr % t109                                         uintptr
	t111 = t110 != 0:uintptr                                           bool
	if t111 goto 33 else 34
33:                                                             if.then P:1 S:1
	t112 = gothrow("need padding in b...":string)                        ()
	jump 34
34:                                                             if.done P:2 S:2
	t113 = &t.elem [#2]                                             **_type
	t114 = *t113                                                     *_type
	t115 = &t114.align [#3]                                          *uint8
	t116 = *t115                                                      uint8
	t117 = convert uintptr <- uint8 (t116)                          uintptr
	t118 = 8:uintptr % t117                                         uintptr
	t119 = t118 != 0:uintptr                                           bool
	if t119 goto 35 else 36
35:                                                             if.then P:1 S:1
	t120 = gothrow("need padding in b...":string)                        ()
	jump 36
36:                                                             if.done P:2 S:1
	jump 39
37:                                                            for.body P:1 S:1
	t121 = t123 + 1:uint8                                             uint8
	jump 39
38:                                                            for.done P:2 S:2
	t122 = t123 != 0:uint8                                             bool
	if t122 goto 41 else 42
39:                                                            for.loop P:2 S:2
	t123 = phi [36: 0:uint8, 37: t121] #B                             uint8
	t124 = hint > 8:int64                                              bool
	if t124 goto 40 else 38
40:                                                           cond.true P:1 S:2
	t125 = convert float32 <- int64 (hint)                          float32
	t126 = 1:uintptr << t123                                        uintptr
	t127 = convert float32 <- uintptr (t126)                        float32
	t128 = 13/2:float32 * t127                                      float32
	t129 = t125 > t128                                                 bool
	if t129 goto 37 else 38
41:                                                             if.then P:1 S:2
	if false:untyped bool goto 43 else 44
42:                                                             if.done P:2 S:2
	t130 = phi [38: nil:unsafe.Pointer, 44: t137] #buckets   unsafe.Pointer
	if false:untyped bool goto 45 else 46
43:                                                             if.then P:1 S:1
	t131 = &memstats.next_gc [#21]                                  *uint64
	t132 = &memstats.heap_alloc [#6]                                *uint64
	t133 = *t132                                                     uint64
	*t131 = t133
	jump 44
44:                                                             if.done P:2 S:1
	t134 = &t.bucket [#3]                                           **_type
	t135 = *t134                                                     *_type
	t136 = 1:uintptr << t123                                        uintptr
	t137 = newarray(t135, t136)                              unsafe.Pointer
	jump 42
45:                                                             if.then P:1 S:1
	t138 = &memstats.next_gc [#21]                                  *uint64
	t139 = &memstats.heap_alloc [#6]                                *uint64
	t140 = *t139                                                     uint64
	*t138 = t140
	jump 46
46:                                                             if.done P:2 S:0
	t141 = &t.hmap [#4]                                             **_type
	t142 = *t141                                                     *_type
	t143 = newobject(t142)                                   unsafe.Pointer
	t144 = convert *hmap <- unsafe.Pointer (t143)                     *hmap
	t145 = &t144.count [#0]                                            *int
	*t145 = 0:int
	t146 = &t144.B [#3]                                              *uint8
	*t146 = t123
	t147 = &t144.flags [#1]                                         *uint32
	*t147 = 0:uint32
	t148 = &t144.hash0 [#2]                                         *uint32
	t149 = fastrand1()                                               uint32
	*t148 = t149
	t150 = &t144.buckets [#4]                               *unsafe.Pointer
	*t150 = t130
	t151 = &t144.oldbuckets [#5]                            *unsafe.Pointer
	*t151 = nil:unsafe.Pointer
	t152 = &t144.nevacuate [#6]                                    *uintptr
	*t152 = 0:uintptr
	return t144

# Name: runtime.mapaccess1
# Package: runtime
# Location: /usr/local/go/src/runtime/hashmap.go:244:6
func mapaccess1(t *maptype, h *hmap, key unsafe.Pointer) unsafe.Pointer:
0:                                                                entry P:0 S:2
	t0 = new *maptype (t)                                         **maptype
	*t0 = t
	if false:untyped bool goto 3 else 2
1:                                                              if.then P:1 S:1
	t1 = convert unsafe.Pointer <- **maptype (t0)            unsafe.Pointer
	t2 = getcallerpc(t1)                                            uintptr
	t3 = make interface{} <- func(t *maptype, h *hmap, key unsafe.Pointer) unsafe.Pointer (mapaccess1) interface{}
	t4 = funcPC(t3)                                                 uintptr
	t5 = convert unsafe.Pointer <- *hmap (h)                 unsafe.Pointer
	t6 = racereadpc(t5, t2, t4)                                          ()
	t7 = *t0                                                       *maptype
	t8 = &t7.key [#1]                                               **_type
	t9 = *t8                                                         *_type
	t10 = raceReadObjectPC(t9, key, t2, t4)                              ()
	jump 2
2:                                                              if.done P:3 S:2
	t11 = h == nil:*hmap                                               bool
	if t11 goto 4 else 6
3:                                                            cond.true P:1 S:2
	t12 = h != nil:*hmap                                               bool
	if t12 goto 1 else 2
4:                                                              if.then P:2 S:0
	t13 = *t0                                                      *maptype
	t14 = &t13.elem [#2]                                            **_type
	t15 = *t14                                                       *_type
	t16 = &t15.zero [#11]                                            **byte
	t17 = *t16                                                        *byte
	t18 = convert unsafe.Pointer <- *byte (t17)              unsafe.Pointer
	return t18
5:                                                              if.done P:1 S:2
	t19 = *t0                                                      *maptype
	t20 = &t19.key [#1]                                             **_type
	t21 = *t20                                                       *_type
	t22 = &t21.alg [#6]                                     *unsafe.Pointer
	t23 = *t22                                               unsafe.Pointer
	t24 = goalg(t23)                                               *typeAlg
	t25 = &t24.hash [#0]    *func(unsafe.Pointer, uintptr, uintptr) uintptr
	t26 = *t25               func(unsafe.Pointer, uintptr, uintptr) uintptr
	t27 = *t0                                                      *maptype
	t28 = &t27.key [#1]                                             **_type
	t29 = *t28                                                       *_type
	t30 = &t29.size [#0]                                           *uintptr
	t31 = *t30                                                      uintptr
	t32 = &h.hash0 [#2]                                             *uint32
	t33 = *t32                                                       uint32
	t34 = convert uintptr <- uint32 (t33)                           uintptr
	t35 = t26(key, t31, t34)                                        uintptr
	t36 = &h.B [#3]                                                  *uint8
	t37 = *t36                                                        uint8
	t38 = 1:uintptr << t37                                          uintptr
	t39 = t38 - 1:uintptr                                           uintptr
	t40 = &h.buckets [#4]                                   *unsafe.Pointer
	t41 = *t40                                               unsafe.Pointer
	t42 = t35 & t39                                                 uintptr
	t43 = *t0                                                      *maptype
	t44 = &t43.bucketsize [#9]                                      *uint16
	t45 = *t44                                                       uint16
	t46 = convert uintptr <- uint16 (t45)                           uintptr
	t47 = t42 * t46                                                 uintptr
	t48 = add(t41, t47)                                      unsafe.Pointer
	t49 = convert *bmap <- unsafe.Pointer (t48)                       *bmap
	t50 = &h.oldbuckets [#5]                                *unsafe.Pointer
	t51 = *t50                                               unsafe.Pointer
	t52 = t51 != nil:unsafe.Pointer                                    bool
	if t52 goto 7 else 8
6:                                                           cond.false P:1 S:2
	t53 = &h.count [#0]                                                *int
	t54 = *t53                                                          int
	t55 = t54 == 0:int                                                 bool
	if t55 goto 4 else 5
7:                                                              if.then P:1 S:2
	t56 = t39 >> 1:uint64                                           uintptr
	t57 = t35 & t56                                                 uintptr
	t58 = *t0                                                      *maptype
	t59 = &t58.bucketsize [#9]                                      *uint16
	t60 = *t59                                                       uint16
	t61 = convert uintptr <- uint16 (t60)                           uintptr
	t62 = t57 * t61                                                 uintptr
	t63 = add(t51, t62)                                      unsafe.Pointer
	t64 = convert *bmap <- unsafe.Pointer (t63)                       *bmap
	t65 = evacuated(t64)                                               bool
	if t65 goto 8 else 9
8:                                                              if.done P:3 S:2
	t66 = phi [5: t49, 7: t49, 9: t64] #b                             *bmap
	t67 = t35 >> 56:uint64                                          uintptr
	t68 = convert uint8 <- uintptr (t67)                              uint8
	t69 = t68 < 4:uint8                                                bool
	if t69 goto 10 else 11
9:                                                              if.then P:1 S:1
	jump 8
10:                                                             if.then P:1 S:1
	t70 = t68 + 4:uint8                                               uint8
	jump 11
11:                                                            for.body P:3 S:1
	t71 = phi [8: t66, 13: t80, 10: t66] #b                           *bmap
	t72 = phi [8: t68, 13: t72, 10: t70] #top                         uint8
	t73 = phi [8: nil:unsafe.Pointer, 13: t83, 10: nil:unsafe.Pointer] #k unsafe.Pointer
	jump 14
12:                                                            for.body P:1 S:2
	t74 = &t71.tophash [#0]                                       *[8]uint8
	t75 = convert int <- uintptr (t82)                                  int
	t76 = &t74[t75]                                                  *uint8
	t77 = *t76                                                        uint8
	t78 = t77 != t72                                                   bool
	if t78 goto 15 else 16
13:                                                            for.done P:1 S:2
	t79 = *t0                                                      *maptype
	t80 = (*bmap).overflow(t71, t79)                                  *bmap
	t81 = t80 == nil:*bmap                                             bool
	if t81 goto 22 else 11
14:                                                            for.loop P:2 S:2
	t82 = phi [11: 0:uintptr, 15: t86] #i                           uintptr
	t83 = phi [11: t73, 15: t85] #k                          unsafe.Pointer
	t84 = t82 < 8:uintptr                                              bool
	if t84 goto 12 else 13
15:                                                            for.post P:2 S:1
	t85 = phi [12: t83, 18: t100] #k                         unsafe.Pointer
	t86 = t82 + 1:uintptr                                           uintptr
	jump 14
16:                                                             if.done P:1 S:2
	t87 = convert unsafe.Pointer <- *bmap (t71)              unsafe.Pointer
	t88 = *t0                                                      *maptype
	t89 = &t88.keysize [#5]                                          *uint8
	t90 = *t89                                                        uint8
	t91 = convert uintptr <- uint8 (t90)                            uintptr
	t92 = t82 * t91                                                 uintptr
	t93 = 8:uintptr + t92                                           uintptr
	t94 = add(t87, t93)                                      unsafe.Pointer
	t95 = *t0                                                      *maptype
	t96 = &t95.indirectkey [#6]                                       *bool
	t97 = *t96                                                         bool
	if t97 goto 17 else 18
17:                                                             if.then P:1 S:1
	t98 = convert *unsafe.Pointer <- unsafe.Pointer (t94)   *unsafe.Pointer
	t99 = *t98                                               unsafe.Pointer
	jump 18
18:                                                             if.done P:2 S:2
	t100 = phi [16: t94, 17: t99] #k                         unsafe.Pointer
	t101 = &t24.equal [#1] *func(unsafe.Pointer, unsafe.Pointer, uintptr) bool
	t102 = *t101         func(unsafe.Pointer, unsafe.Pointer, uintptr) bool
	t103 = *t0                                                     *maptype
	t104 = &t103.key [#1]                                           **_type
	t105 = *t104                                                     *_type
	t106 = &t105.size [#0]                                         *uintptr
	t107 = *t106                                                    uintptr
	t108 = t102(key, t100, t107)                                       bool
	if t108 goto 19 else 15
19:                                                             if.then P:1 S:2
	t109 = convert unsafe.Pointer <- *bmap (t71)             unsafe.Pointer
	t110 = *t0                                                     *maptype
	t111 = &t110.keysize [#5]                                        *uint8
	t112 = *t111                                                      uint8
	t113 = convert uintptr <- uint8 (t112)                          uintptr
	t114 = 8:uintptr * t113                                         uintptr
	t115 = 8:uintptr + t114                                         uintptr
	t116 = *t0                                                     *maptype
	t117 = &t116.valuesize [#7]                                      *uint8
	t118 = *t117                                                      uint8
	t119 = convert uintptr <- uint8 (t118)                          uintptr
	t120 = t82 * t119                                               uintptr
	t121 = t115 + t120                                              uintptr
	t122 = add(t109, t121)                                   unsafe.Pointer
	t123 = *t0                                                     *maptype
	t124 = &t123.indirectvalue [#8]                                   *bool
	t125 = *t124                                                       bool
	if t125 goto 20 else 21
20:                                                             if.then P:1 S:1
	t126 = convert *unsafe.Pointer <- unsafe.Pointer (t122) *unsafe.Pointer
	t127 = *t126                                             unsafe.Pointer
	jump 21
21:                                                             if.done P:2 S:0
	t128 = phi [19: t122, 20: t127] #v                       unsafe.Pointer
	return t128
22:                                                             if.then P:1 S:0
	t129 = *t0                                                     *maptype
	t130 = &t129.elem [#2]                                          **_type
	t131 = *t130                                                     *_type
	t132 = &t131.zero [#11]                                          **byte
	t133 = *t132                                                      *byte
	t134 = convert unsafe.Pointer <- *byte (t133)            unsafe.Pointer
	return t134

# Name: runtime.mapaccess2
# Package: runtime
# Location: /usr/local/go/src/runtime/hashmap.go:292:6
func mapaccess2(t *maptype, h *hmap, key unsafe.Pointer) (unsafe.Pointer, bool):
0:                                                                entry P:0 S:2
	t0 = new *maptype (t)                                         **maptype
	*t0 = t
	if false:untyped bool goto 3 else 2
1:                                                              if.then P:1 S:1
	t1 = convert unsafe.Pointer <- **maptype (t0)            unsafe.Pointer
	t2 = getcallerpc(t1)                                            uintptr
	t3 = make interface{} <- func(t *maptype, h *hmap, key unsafe.Pointer) (unsafe.Pointer, bool) (mapaccess2) interface{}
	t4 = funcPC(t3)                                                 uintptr
	t5 = convert unsafe.Pointer <- *hmap (h)                 unsafe.Pointer
	t6 = racereadpc(t5, t2, t4)                                          ()
	t7 = *t0                                                       *maptype
	t8 = &t7.key [#1]                                               **_type
	t9 = *t8                                                         *_type
	t10 = raceReadObjectPC(t9, key, t2, t4)                              ()
	jump 2
2:                                                              if.done P:3 S:2
	t11 = h == nil:*hmap                                               bool
	if t11 goto 4 else 6
3:                                                            cond.true P:1 S:2
	t12 = h != nil:*hmap                                               bool
	if t12 goto 1 else 2
4:                                                              if.then P:2 S:0
	t13 = *t0                                                      *maptype
	t14 = &t13.elem [#2]                                            **_type
	t15 = *t14                                                       *_type
	t16 = &t15.zero [#11]                                            **byte
	t17 = *t16                                                        *byte
	t18 = convert unsafe.Pointer <- *byte (t17)              unsafe.Pointer
	return t18, false:bool
5:                                                              if.done P:1 S:2
	t19 = *t0                                                      *maptype
	t20 = &t19.key [#1]                                             **_type
	t21 = *t20                                                       *_type
	t22 = &t21.alg [#6]                                     *unsafe.Pointer
	t23 = *t22                                               unsafe.Pointer
	t24 = goalg(t23)                                               *typeAlg
	t25 = &t24.hash [#0]    *func(unsafe.Pointer, uintptr, uintptr) uintptr
	t26 = *t25               func(unsafe.Pointer, uintptr, uintptr) uintptr
	t27 = *t0                                                      *maptype
	t28 = &t27.key [#1]                                             **_type
	t29 = *t28                                                       *_type
	t30 = &t29.size [#0]                                           *uintptr
	t31 = *t30                                                      uintptr
	t32 = &h.hash0 [#2]                                             *uint32
	t33 = *t32                                                       uint32
	t34 = convert uintptr <- uint32 (t33)                           uintptr
	t35 = t26(key, t31, t34)                                        uintptr
	t36 = &h.B [#3]                                                  *uint8
	t37 = *t36                                                        uint8
	t38 = 1:uintptr << t37                                          uintptr
	t39 = t38 - 1:uintptr                                           uintptr
	t40 = &h.buckets [#4]                                   *unsafe.Pointer
	t41 = *t40                                               unsafe.Pointer
	t42 = convert uintptr <- unsafe.Pointer (t41)                   uintptr
	t43 = t35 & t39                                                 uintptr
	t44 = *t0                                                      *maptype
	t45 = &t44.bucketsize [#9]                                      *uint16
	t46 = *t45                                                       uint16
	t47 = convert uintptr <- uint16 (t46)                           uintptr
	t48 = t43 * t47                                                 uintptr
	t49 = t42 + t48                                                 uintptr
	t50 = convert unsafe.Pointer <- uintptr (t49)            unsafe.Pointer
	t51 = convert *bmap <- unsafe.Pointer (t50)                       *bmap
	t52 = &h.oldbuckets [#5]                                *unsafe.Pointer
	t53 = *t52                                               unsafe.Pointer
	t54 = t53 != nil:unsafe.Pointer                                    bool
	if t54 goto 7 else 8
6:                                                           cond.false P:1 S:2
	t55 = &h.count [#0]                                                *int
	t56 = *t55                                                          int
	t57 = t56 == 0:int                                                 bool
	if t57 goto 4 else 5
7:                                                              if.then P:1 S:2
	t58 = convert uintptr <- unsafe.Pointer (t53)                   uintptr
	t59 = t39 >> 1:uint64                                           uintptr
	t60 = t35 & t59                                                 uintptr
	t61 = *t0                                                      *maptype
	t62 = &t61.bucketsize [#9]                                      *uint16
	t63 = *t62                                                       uint16
	t64 = convert uintptr <- uint16 (t63)                           uintptr
	t65 = t60 * t64                                                 uintptr
	t66 = t58 + t65                                                 uintptr
	t67 = convert unsafe.Pointer <- uintptr (t66)            unsafe.Pointer
	t68 = convert *bmap <- unsafe.Pointer (t67)                       *bmap
	t69 = evacuated(t68)                                               bool
	if t69 goto 8 else 9
8:                                                              if.done P:3 S:2
	t70 = phi [5: t51, 7: t51, 9: t68] #b                             *bmap
	t71 = t35 >> 56:uint64                                          uintptr
	t72 = convert uint8 <- uintptr (t71)                              uint8
	t73 = t72 < 4:uint8                                                bool
	if t73 goto 10 else 11
9:                                                              if.then P:1 S:1
	jump 8
10:                                                             if.then P:1 S:1
	t74 = t72 + 4:uint8                                               uint8
	jump 11
11:                                                            for.body P:3 S:1
	t75 = phi [8: t70, 13: t84, 10: t70] #b                           *bmap
	t76 = phi [8: t72, 13: t76, 10: t74] #top                         uint8
	t77 = phi [8: nil:unsafe.Pointer, 13: t87, 10: nil:unsafe.Pointer] #k unsafe.Pointer
	jump 14
12:                                                            for.body P:1 S:2
	t78 = &t75.tophash [#0]                                       *[8]uint8
	t79 = convert int <- uintptr (t86)                                  int
	t80 = &t78[t79]                                                  *uint8
	t81 = *t80                                                        uint8
	t82 = t81 != t76                                                   bool
	if t82 goto 15 else 16
13:                                                            for.done P:1 S:2
	t83 = *t0                                                      *maptype
	t84 = (*bmap).overflow(t75, t83)                                  *bmap
	t85 = t84 == nil:*bmap                                             bool
	if t85 goto 22 else 11
14:                                                            for.loop P:2 S:2
	t86 = phi [11: 0:uintptr, 15: t90] #i                           uintptr
	t87 = phi [11: t77, 15: t89] #k                          unsafe.Pointer
	t88 = t86 < 8:uintptr                                              bool
	if t88 goto 12 else 13
15:                                                            for.post P:2 S:1
	t89 = phi [12: t87, 18: t104] #k                         unsafe.Pointer
	t90 = t86 + 1:uintptr                                           uintptr
	jump 14
16:                                                             if.done P:1 S:2
	t91 = convert unsafe.Pointer <- *bmap (t75)              unsafe.Pointer
	t92 = *t0                                                      *maptype
	t93 = &t92.keysize [#5]                                          *uint8
	t94 = *t93                                                        uint8
	t95 = convert uintptr <- uint8 (t94)                            uintptr
	t96 = t86 * t95                                                 uintptr
	t97 = 8:uintptr + t96                                           uintptr
	t98 = add(t91, t97)                                      unsafe.Pointer
	t99 = *t0                                                      *maptype
	t100 = &t99.indirectkey [#6]                                      *bool
	t101 = *t100                                                       bool
	if t101 goto 17 else 18
17:                                                             if.then P:1 S:1
	t102 = convert *unsafe.Pointer <- unsafe.Pointer (t98)  *unsafe.Pointer
	t103 = *t102                                             unsafe.Pointer
	jump 18
18:                                                             if.done P:2 S:2
	t104 = phi [16: t98, 17: t103] #k                        unsafe.Pointer
	t105 = &t24.equal [#1] *func(unsafe.Pointer, unsafe.Pointer, uintptr) bool
	t106 = *t105         func(unsafe.Pointer, unsafe.Pointer, uintptr) bool
	t107 = *t0                                                     *maptype
	t108 = &t107.key [#1]                                           **_type
	t109 = *t108                                                     *_type
	t110 = &t109.size [#0]                                         *uintptr
	t111 = *t110                                                    uintptr
	t112 = t106(key, t104, t111)                                       bool
	if t112 goto 19 else 15
19:                                                             if.then P:1 S:2
	t113 = convert unsafe.Pointer <- *bmap (t75)             unsafe.Pointer
	t114 = *t0                                                     *maptype
	t115 = &t114.keysize [#5]                                        *uint8
	t116 = *t115                                                      uint8
	t117 = convert uintptr <- uint8 (t116)                          uintptr
	t118 = 8:uintptr * t117                                         uintptr
	t119 = 8:uintptr + t118                                         uintptr
	t120 = *t0                                                     *maptype
	t121 = &t120.valuesize [#7]                                      *uint8
	t122 = *t121                                                      uint8
	t123 = convert uintptr <- uint8 (t122)                          uintptr
	t124 = t86 * t123                                               uintptr
	t125 = t119 + t124                                              uintptr
	t126 = add(t113, t125)                                   unsafe.Pointer
	t127 = *t0                                                     *maptype
	t128 = &t127.indirectvalue [#8]                                   *bool
	t129 = *t128                                                       bool
	if t129 goto 20 else 21
20:                                                             if.then P:1 S:1
	t130 = convert *unsafe.Pointer <- unsafe.Pointer (t126) *unsafe.Pointer
	t131 = *t130                                             unsafe.Pointer
	jump 21
21:                                                             if.done P:2 S:0
	t132 = phi [19: t126, 20: t131] #v                       unsafe.Pointer
	return t132, true:bool
22:                                                             if.then P:1 S:0
	t133 = *t0                                                     *maptype
	t134 = &t133.elem [#2]                                          **_type
	t135 = *t134                                                     *_type
	t136 = &t135.zero [#11]                                          **byte
	t137 = *t136                                                      *byte
	t138 = convert unsafe.Pointer <- *byte (t137)            unsafe.Pointer
	return t138, false:bool

# Name: runtime.mapaccessK
# Package: runtime
# Location: /usr/local/go/src/runtime/hashmap.go:341:6
func mapaccessK(t *maptype, h *hmap, key unsafe.Pointer) (unsafe.Pointer, unsafe.Pointer):
0:                                                                entry P:0 S:2
	t0 = h == nil:*hmap                                                bool
	if t0 goto 1 else 3
1:                                                              if.then P:2 S:0
	return nil:unsafe.Pointer, nil:unsafe.Pointer
2:                                                              if.done P:1 S:2
	t1 = &t.key [#1]                                                **_type
	t2 = *t1                                                         *_type
	t3 = &t2.alg [#6]                                       *unsafe.Pointer
	t4 = *t3                                                 unsafe.Pointer
	t5 = goalg(t4)                                                 *typeAlg
	t6 = &t5.hash [#0]      *func(unsafe.Pointer, uintptr, uintptr) uintptr
	t7 = *t6                 func(unsafe.Pointer, uintptr, uintptr) uintptr
	t8 = &t.key [#1]                                                **_type
	t9 = *t8                                                         *_type
	t10 = &t9.size [#0]                                            *uintptr
	t11 = *t10                                                      uintptr
	t12 = &h.hash0 [#2]                                             *uint32
	t13 = *t12                                                       uint32
	t14 = convert uintptr <- uint32 (t13)                           uintptr
	t15 = t7(key, t11, t14)                                         uintptr
	t16 = &h.B [#3]                                                  *uint8
	t17 = *t16                                                        uint8
	t18 = 1:uintptr << t17                                          uintptr
	t19 = t18 - 1:uintptr                                           uintptr
	t20 = &h.buckets [#4]                                   *unsafe.Pointer
	t21 = *t20                                               unsafe.Pointer
	t22 = convert uintptr <- unsafe.Pointer (t21)                   uintptr
	t23 = t15 & t19                                                 uintptr
	t24 = &t.bucketsize [#9]                                        *uint16
	t25 = *t24                                                       uint16
	t26 = convert uintptr <- uint16 (t25)                           uintptr
	t27 = t23 * t26                                                 uintptr
	t28 = t22 + t27                                                 uintptr
	t29 = convert unsafe.Pointer <- uintptr (t28)            unsafe.Pointer
	t30 = convert *bmap <- unsafe.Pointer (t29)                       *bmap
	t31 = &h.oldbuckets [#5]                                *unsafe.Pointer
	t32 = *t31                                               unsafe.Pointer
	t33 = t32 != nil:unsafe.Pointer                                    bool
	if t33 goto 4 else 5
3:                                                           cond.false P:1 S:2
	t34 = &h.count [#0]                                                *int
	t35 = *t34                                                          int
	t36 = t35 == 0:int                                                 bool
	if t36 goto 1 else 2
4:                                                              if.then P:1 S:2
	t37 = convert uintptr <- unsafe.Pointer (t32)                   uintptr
	t38 = t19 >> 1:uint64                                           uintptr
	t39 = t15 & t38                                                 uintptr
	t40 = &t.bucketsize [#9]                                        *uint16
	t41 = *t40                                                       uint16
	t42 = convert uintptr <- uint16 (t41)                           uintptr
	t43 = t39 * t42                                                 uintptr
	t44 = t37 + t43                                                 uintptr
	t45 = convert unsafe.Pointer <- uintptr (t44)            unsafe.Pointer
	t46 = convert *bmap <- unsafe.Pointer (t45)                       *bmap
	t47 = evacuated(t46)                                               bool
	if t47 goto 5 else 6
5:                                                              if.done P:3 S:2
	t48 = phi [2: t30, 4: t30, 6: t46] #b                             *bmap
	t49 = t15 >> 56:uint64                                          uintptr
	t50 = convert uint8 <- uintptr (t49)                              uint8
	t51 = t50 < 4:uint8                                                bool
	if t51 goto 7 else 8
6:                                                              if.then P:1 S:1
	jump 5
7:                                                              if.then P:1 S:1
	t52 = t50 + 4:uint8                                               uint8
	jump 8
8:                                                             for.body P:3 S:1
	t53 = phi [5: t48, 10: t61, 7: t48] #b                            *bmap
	t54 = phi [5: t50, 10: t54, 7: t52] #top                          uint8
	t55 = phi [5: nil:unsafe.Pointer, 10: t64, 7: nil:unsafe.Pointer] #k unsafe.Pointer
	jump 11
9:                                                             for.body P:1 S:2
	t56 = &t53.tophash [#0]                                       *[8]uint8
	t57 = convert int <- uintptr (t63)                                  int
	t58 = &t56[t57]                                                  *uint8
	t59 = *t58                                                        uint8
	t60 = t59 != t54                                                   bool
	if t60 goto 12 else 13
10:                                                            for.done P:1 S:2
	t61 = (*bmap).overflow(t53, t)                                    *bmap
	t62 = t61 == nil:*bmap                                             bool
	if t62 goto 19 else 8
11:                                                            for.loop P:2 S:2
	t63 = phi [8: 0:uintptr, 12: t67] #i                            uintptr
	t64 = phi [8: t55, 12: t66] #k                           unsafe.Pointer
	t65 = t63 < 8:uintptr                                              bool
	if t65 goto 9 else 10
12:                                                            for.post P:2 S:1
	t66 = phi [9: t64, 15: t79] #k                           unsafe.Pointer
	t67 = t63 + 1:uintptr                                           uintptr
	jump 11
13:                                                             if.done P:1 S:2
	t68 = convert unsafe.Pointer <- *bmap (t53)              unsafe.Pointer
	t69 = &t.keysize [#5]                                            *uint8
	t70 = *t69                                                        uint8
	t71 = convert uintptr <- uint8 (t70)                            uintptr
	t72 = t63 * t71                                                 uintptr
	t73 = 8:uintptr + t72                                           uintptr
	t74 = add(t68, t73)                                      unsafe.Pointer
	t75 = &t.indirectkey [#6]                                         *bool
	t76 = *t75                                                         bool
	if t76 goto 14 else 15
14:                                                             if.then P:1 S:1
	t77 = convert *unsafe.Pointer <- unsafe.Pointer (t74)   *unsafe.Pointer
	t78 = *t77                                               unsafe.Pointer
	jump 15
15:                                                             if.done P:2 S:2
	t79 = phi [13: t74, 14: t78] #k                          unsafe.Pointer
	t80 = &t5.equal [#1] *func(unsafe.Pointer, unsafe.Pointer, uintptr) bool
	t81 = *t80           func(unsafe.Pointer, unsafe.Pointer, uintptr) bool
	t82 = &t.key [#1]                                               **_type
	t83 = *t82                                                       *_type
	t84 = &t83.size [#0]                                           *uintptr
	t85 = *t84                                                      uintptr
	t86 = t81(key, t79, t85)                                           bool
	if t86 goto 16 else 12
16:                                                             if.then P:1 S:2
	t87 = convert unsafe.Pointer <- *bmap (t53)              unsafe.Pointer
	t88 = &t.keysize [#5]                                            *uint8
	t89 = *t88                                                        uint8
	t90 = convert uintptr <- uint8 (t89)                            uintptr
	t91 = 8:uintptr * t90                                           uintptr
	t92 = 8:uintptr + t91                                           uintptr
	t93 = &t.valuesize [#7]                                          *uint8
	t94 = *t93                                                        uint8
	t95 = convert uintptr <- uint8 (t94)                            uintptr
	t96 = t63 * t95                                                 uintptr
	t97 = t92 + t96                                                 uintptr
	t98 = add(t87, t97)                                      unsafe.Pointer
	t99 = &t.indirectvalue [#8]                                       *bool
	t100 = *t99                                                        bool
	if t100 goto 17 else 18
17:                                                             if.then P:1 S:1
	t101 = convert *unsafe.Pointer <- unsafe.Pointer (t98)  *unsafe.Pointer
	t102 = *t101                                             unsafe.Pointer
	jump 18
18:                                                             if.done P:2 S:0
	t103 = phi [16: t98, 17: t102] #v                        unsafe.Pointer
	return t79, t103
19:                                                             if.then P:1 S:0
	return nil:unsafe.Pointer, nil:unsafe.Pointer

# Name: runtime.mapassign1
# Package: runtime
# Location: /usr/local/go/src/runtime/hashmap.go:383:6
func mapassign1(t *maptype, h *hmap, key unsafe.Pointer, val unsafe.Pointer):
0:                                                                entry P:0 S:2
	t0 = new *maptype (t)                                         **maptype
	*t0 = t
	t1 = h == nil:*hmap                                                bool
	if t1 goto 1 else 2
1:                                                              if.then P:1 S:0
	t2 = make interface{} <- string ("assignment to ent...":string) interface{}
	panic t2
2:                                                              if.done P:1 S:2
	if false:untyped bool goto 3 else 4
3:                                                              if.then P:1 S:1
	t3 = convert unsafe.Pointer <- **maptype (t0)            unsafe.Pointer
	t4 = getcallerpc(t3)                                            uintptr
	t5 = make interface{} <- func(t *maptype, h *hmap, key unsafe.Pointer, val unsafe.Pointer) (mapassign1) interface{}
	t6 = funcPC(t5)                                                 uintptr
	t7 = convert unsafe.Pointer <- *hmap (h)                 unsafe.Pointer
	t8 = racewritepc(t7, t4, t6)                                         ()
	t9 = *t0                                                       *maptype
	t10 = &t9.key [#1]                                              **_type
	t11 = *t10                                                       *_type
	t12 = raceReadObjectPC(t11, key, t4, t6)                             ()
	t13 = *t0                                                      *maptype
	t14 = &t13.elem [#2]                                            **_type
	t15 = *t14                                                       *_type
	t16 = raceReadObjectPC(t15, val, t4, t6)                             ()
	jump 4
4:                                                              if.done P:2 S:2
	t17 = *t0                                                      *maptype
	t18 = &t17.key [#1]                                             **_type
	t19 = *t18                                                       *_type
	t20 = &t19.alg [#6]                                     *unsafe.Pointer
	t21 = *t20                                               unsafe.Pointer
	t22 = goalg(t21)                                               *typeAlg
	t23 = &t22.hash [#0]    *func(unsafe.Pointer, uintptr, uintptr) uintptr
	t24 = *t23               func(unsafe.Pointer, uintptr, uintptr) uintptr
	t25 = *t0                                                      *maptype
	t26 = &t25.key [#1]                                             **_type
	t27 = *t26                                                       *_type
	t28 = &t27.size [#0]                                           *uintptr
	t29 = *t28                                                      uintptr
	t30 = &h.hash0 [#2]                                             *uint32
	t31 = *t30                                                       uint32
	t32 = convert uintptr <- uint32 (t31)                           uintptr
	t33 = t24(key, t29, t32)                                        uintptr
	t34 = &h.buckets [#4]                                   *unsafe.Pointer
	t35 = *t34                                               unsafe.Pointer
	t36 = t35 == nil:unsafe.Pointer                                    bool
	if t36 goto 5 else 8
5:                                                              if.then P:1 S:2
	if false:untyped bool goto 6 else 7
6:                                                              if.then P:1 S:1
	t37 = &memstats.next_gc [#21]                                   *uint64
	t38 = &memstats.heap_alloc [#6]                                 *uint64
	t39 = *t38                                                       uint64
	*t37 = t39
	jump 7
7:                                                              if.done P:2 S:1
	t40 = &h.buckets [#4]                                   *unsafe.Pointer
	t41 = *t0                                                      *maptype
	t42 = &t41.bucket [#3]                                          **_type
	t43 = *t42                                                       *_type
	t44 = newarray(t43, 1:uintptr)                           unsafe.Pointer
	*t40 = t44
	jump 8
8:                                                                again P:3 S:2
	t45 = phi [4: 0:uintptr, 29: t92, 7: 0:uintptr] #i              uintptr
	t46 = phi [4: nil:*bmap, 29: t87, 7: nil:*bmap] #ovf              *bmap
	t47 = phi [4: nil:unsafe.Pointer, 29: t93, 7: nil:unsafe.Pointer] #k unsafe.Pointer
	t48 = phi [4: nil:unsafe.Pointer, 29: t94, 7: nil:unsafe.Pointer] #k2 unsafe.Pointer
	t49 = &h.B [#3]                                                  *uint8
	t50 = *t49                                                        uint8
	t51 = 1:uintptr << t50                                          uintptr
	t52 = t51 - 1:uintptr                                           uintptr
	t53 = t33 & t52                                                 uintptr
	t54 = &h.oldbuckets [#5]                                *unsafe.Pointer
	t55 = *t54                                               unsafe.Pointer
	t56 = t55 != nil:unsafe.Pointer                                    bool
	if t56 goto 9 else 10
9:                                                              if.then P:1 S:1
	t57 = *t0                                                      *maptype
	t58 = growWork(t57, h, t53)                                          ()
	jump 10
10:                                                             if.done P:2 S:2
	t59 = &h.buckets [#4]                                   *unsafe.Pointer
	t60 = *t59                                               unsafe.Pointer
	t61 = convert uintptr <- unsafe.Pointer (t60)                   uintptr
	t62 = *t0                                                      *maptype
	t63 = &t62.bucketsize [#9]                                      *uint16
	t64 = *t63                                                       uint16
	t65 = convert uintptr <- uint16 (t64)                           uintptr
	t66 = t53 * t65                                                 uintptr
	t67 = t61 + t66                                                 uintptr
	t68 = convert unsafe.Pointer <- uintptr (t67)            unsafe.Pointer
	t69 = convert *bmap <- unsafe.Pointer (t68)                       *bmap
	t70 = t33 >> 56:uint64                                          uintptr
	t71 = convert uint8 <- uintptr (t70)                              uint8
	t72 = t71 < 4:uint8                                                bool
	if t72 goto 11 else 12
11:                                                             if.then P:1 S:1
	t73 = t71 + 4:uint8                                               uint8
	jump 12
12:                                                             if.done P:2 S:1
	t74 = phi [10: t71, 11: t73] #top                                 uint8
	jump 13
13:                                                            for.body P:2 S:1
	t75 = phi [12: t69, 28: t87] #b                                   *bmap
	t76 = phi [12: nil:*uint8, 28: t89] #inserti                     *uint8
	t77 = phi [12: nil:unsafe.Pointer, 28: t90] #insertk     unsafe.Pointer
	t78 = phi [12: nil:unsafe.Pointer, 28: t91] #insertv     unsafe.Pointer
	t79 = phi [12: t47, 28: t93] #k                          unsafe.Pointer
	t80 = phi [12: t48, 28: t94] #k2                         unsafe.Pointer
	jump 16
14:                                                            for.body P:1 S:2
	t81 = &t75.tophash [#0]                                       *[8]uint8
	t82 = convert int <- uintptr (t92)                                  int
	t83 = &t81[t82]                                                  *uint8
	t84 = *t83                                                        uint8
	t85 = t84 != t74                                                   bool
	if t85 goto 18 else 19
15:                                                            for.done P:1 S:2
	t86 = *t0                                                      *maptype
	t87 = (*bmap).overflow(t75, t86)                                  *bmap
	t88 = t87 == nil:*bmap                                             bool
	if t88 goto 27 else 28
16:                                                            for.loop P:2 S:2
	t89 = phi [13: t76, 17: t96] #inserti                            *uint8
	t90 = phi [13: t77, 17: t97] #insertk                    unsafe.Pointer
	t91 = phi [13: t78, 17: t98] #insertv                    unsafe.Pointer
	t92 = phi [13: 0:uintptr, 17: t101] #i                          uintptr
	t93 = phi [13: t79, 17: t99] #k                          unsafe.Pointer
	t94 = phi [13: t80, 17: t100] #k2                        unsafe.Pointer
	t95 = t92 < 8:uintptr                                              bool
	if t95 goto 14 else 15
17:                                                            for.post P:4 S:1
	t96 = phi [18: t89, 23: t89, 21: t89, 20: t120] #inserti         *uint8
	t97 = phi [18: t90, 23: t90, 21: t90, 20: t128] #insertk unsafe.Pointer
	t98 = phi [18: t91, 23: t91, 21: t91, 20: t142] #insertv unsafe.Pointer
	t99 = phi [18: t93, 23: t114, 21: t93, 20: t93] #k       unsafe.Pointer
	t100 = phi [18: t94, 23: t146, 21: t94, 20: t94] #k2     unsafe.Pointer
	t101 = t92 + 1:uintptr                                          uintptr
	jump 16
18:                                                             if.then P:1 S:2
	t102 = &t75.tophash [#0]                                      *[8]uint8
	t103 = convert int <- uintptr (t92)                                 int
	t104 = &t102[t103]                                               *uint8
	t105 = *t104                                                      uint8
	t106 = t105 == 0:uint8                                             bool
	if t106 goto 21 else 17
19:                                                             if.done P:1 S:2
	t107 = convert unsafe.Pointer <- *bmap (t75)             unsafe.Pointer
	t108 = *t0                                                     *maptype
	t109 = &t108.keysize [#5]                                        *uint8
	t110 = *t109                                                      uint8
	t111 = convert uintptr <- uint8 (t110)                          uintptr
	t112 = t92 * t111                                               uintptr
	t113 = 8:uintptr + t112                                         uintptr
	t114 = add(t107, t113)                                   unsafe.Pointer
	t115 = *t0                                                     *maptype
	t116 = &t115.indirectkey [#6]                                     *bool
	t117 = *t116                                                       bool
	if t117 goto 22 else 23
20:                                                             if.then P:1 S:1
	t118 = &t75.tophash [#0]                                      *[8]uint8
	t119 = convert int <- uintptr (t92)                                 int
	t120 = &t118[t119]                                               *uint8
	t121 = convert unsafe.Pointer <- *bmap (t75)             unsafe.Pointer
	t122 = *t0                                                     *maptype
	t123 = &t122.keysize [#5]                                        *uint8
	t124 = *t123                                                      uint8
	t125 = convert uintptr <- uint8 (t124)                          uintptr
	t126 = t92 * t125                                               uintptr
	t127 = 8:uintptr + t126                                         uintptr
	t128 = add(t121, t127)                                   unsafe.Pointer
	t129 = convert unsafe.Pointer <- *bmap (t75)             unsafe.Pointer
	t130 = *t0                                                     *maptype
	t131 = &t130.keysize [#5]                                        *uint8
	t132 = *t131                                                      uint8
	t133 = convert uintptr <- uint8 (t132)                          uintptr
	t134 = 8:uintptr * t133                                         uintptr
	t135 = 8:uintptr + t134                                         uintptr
	t136 = *t0                                                     *maptype
	t137 = &t136.valuesize [#7]                                      *uint8
	t138 = *t137                                                      uint8
	t139 = convert uintptr <- uint8 (t138)                          uintptr
	t140 = t92 * t139                                               uintptr
	t141 = t135 + t140                                              uintptr
	t142 = add(t129, t141)                                   unsafe.Pointer
	jump 17
21:                                                           cond.true P:1 S:2
	t143 = t89 == nil:*uint8                                           bool
	if t143 goto 20 else 17
22:                                                             if.then P:1 S:1
	t144 = convert *unsafe.Pointer <- unsafe.Pointer (t114) *unsafe.Pointer
	t145 = *t144                                             unsafe.Pointer
	jump 23
23:                                                             if.done P:2 S:2
	t146 = phi [19: t114, 22: t145] #k2                      unsafe.Pointer
	t147 = &t22.equal [#1] *func(unsafe.Pointer, unsafe.Pointer, uintptr) bool
	t148 = *t147         func(unsafe.Pointer, unsafe.Pointer, uintptr) bool
	t149 = *t0                                                     *maptype
	t150 = &t149.key [#1]                                           **_type
	t151 = *t150                                                     *_type
	t152 = &t151.size [#0]                                         *uintptr
	t153 = *t152                                                    uintptr
	t154 = t148(key, t146, t153)                                       bool
	if t154 goto 24 else 17
24:                                                             if.done P:1 S:2
	t155 = *t0                                                     *maptype
	t156 = &t155.key [#1]                                           **_type
	t157 = *t156                                                     *_type
	t158 = &t157.size [#0]                                         *uintptr
	t159 = *t158                                                    uintptr
	t160 = memmove(t146, key, t159)                                      ()
	t161 = convert unsafe.Pointer <- *bmap (t75)             unsafe.Pointer
	t162 = *t0                                                     *maptype
	t163 = &t162.keysize [#5]                                        *uint8
	t164 = *t163                                                      uint8
	t165 = convert uintptr <- uint8 (t164)                          uintptr
	t166 = 8:uintptr * t165                                         uintptr
	t167 = 8:uintptr + t166                                         uintptr
	t168 = *t0                                                     *maptype
	t169 = &t168.valuesize [#7]                                      *uint8
	t170 = *t169                                                      uint8
	t171 = convert uintptr <- uint8 (t170)                          uintptr
	t172 = t92 * t171                                               uintptr
	t173 = t167 + t172                                              uintptr
	t174 = add(t161, t173)                                   unsafe.Pointer
	t175 = *t0                                                     *maptype
	t176 = &t175.indirectvalue [#8]                                   *bool
	t177 = *t176                                                       bool
	if t177 goto 25 else 26
25:                                                             if.then P:1 S:1
	t178 = convert *unsafe.Pointer <- unsafe.Pointer (t174) *unsafe.Pointer
	t179 = *t178                                             unsafe.Pointer
	jump 26
26:                                                             if.done P:2 S:0
	t180 = phi [24: t174, 25: t179] #v2                      unsafe.Pointer
	t181 = *t0                                                     *maptype
	t182 = &t181.elem [#2]                                          **_type
	t183 = *t182                                                     *_type
	t184 = &t183.size [#0]                                         *uintptr
	t185 = *t184                                                    uintptr
	t186 = memmove(t180, val, t185)                                      ()
	return
27:                                                             if.then P:1 S:2
	t187 = &h.count [#0]                                               *int
	t188 = *t187                                                        int
	t189 = convert float32 <- int (t188)                            float32
	t190 = &h.B [#3]                                                 *uint8
	t191 = *t190                                                      uint8
	t192 = 1:uintptr << t191                                        uintptr
	t193 = convert float32 <- uintptr (t192)                        float32
	t194 = 13/2:float32 * t193                                      float32
	t195 = t189 >= t194                                                bool
	if t195 goto 31 else 30
28:                                                             if.done P:1 S:1
	jump 13
29:                                                             if.then P:1 S:1
	t196 = *t0                                                     *maptype
	t197 = hashGrow(t196, h)                                             ()
	jump 8
30:                                                             if.done P:2 S:2
	t198 = t89 == nil:*uint8                                           bool
	if t198 goto 32 else 33
31:                                                           cond.true P:1 S:2
	t199 = &h.count [#0]                                               *int
	t200 = *t199                                                        int
	t201 = t200 >= 8:int                                               bool
	if t201 goto 29 else 30
32:                                                             if.then P:1 S:2
	if false:untyped bool goto 34 else 35
33:                                                             if.done P:2 S:2
	t202 = phi [30: t89, 35: t219] #inserti                          *uint8
	t203 = phi [30: t90, 35: t221] #insertk                  unsafe.Pointer
	t204 = phi [30: t91, 35: t227] #insertv                  unsafe.Pointer
	t205 = *t0                                                     *maptype
	t206 = &t205.indirectkey [#6]                                     *bool
	t207 = *t206                                                       bool
	if t207 goto 36 else 37
34:                                                             if.then P:1 S:1
	t208 = &memstats.next_gc [#21]                                  *uint64
	t209 = &memstats.heap_alloc [#6]                                *uint64
	t210 = *t209                                                     uint64
	*t208 = t210
	jump 35
35:                                                             if.done P:2 S:1
	t211 = *t0                                                     *maptype
	t212 = &t211.bucket [#3]                                        **_type
	t213 = *t212                                                     *_type
	t214 = newobject(t213)                                   unsafe.Pointer
	t215 = convert *bmap <- unsafe.Pointer (t214)                     *bmap
	t216 = *t0                                                     *maptype
	t217 = (*bmap).setoverflow(t75, t216, t215)                          ()
	t218 = &t215.tophash [#0]                                     *[8]uint8
	t219 = &t218[0:int]                                              *uint8
	t220 = convert unsafe.Pointer <- *bmap (t215)            unsafe.Pointer
	t221 = add(t220, 8:uintptr)                              unsafe.Pointer
	t222 = *t0                                                     *maptype
	t223 = &t222.keysize [#5]                                        *uint8
	t224 = *t223                                                      uint8
	t225 = convert uintptr <- uint8 (t224)                          uintptr
	t226 = 8:uintptr * t225                                         uintptr
	t227 = add(t221, t226)                                   unsafe.Pointer
	jump 33
36:                                                             if.then P:1 S:2
	if false:untyped bool goto 38 else 39
37:                                                             if.done P:2 S:2
	t228 = phi [33: t203, 39: t238] #insertk                 unsafe.Pointer
	t229 = *t0                                                     *maptype
	t230 = &t229.indirectvalue [#8]                                   *bool
	t231 = *t230                                                       bool
	if t231 goto 40 else 41
38:                                                             if.then P:1 S:1
	t232 = &memstats.next_gc [#21]                                  *uint64
	t233 = &memstats.heap_alloc [#6]                                *uint64
	t234 = *t233                                                     uint64
	*t232 = t234
	jump 39
39:                                                             if.done P:2 S:1
	t235 = *t0                                                     *maptype
	t236 = &t235.key [#1]                                           **_type
	t237 = *t236                                                     *_type
	t238 = newobject(t237)                                   unsafe.Pointer
	t239 = convert *unsafe.Pointer <- unsafe.Pointer (t203) *unsafe.Pointer
	*t239 = t238
	jump 37
40:                                                             if.then P:1 S:2
	if false:untyped bool goto 42 else 43
41:                                                             if.done P:2 S:0
	t240 = phi [37: t204, 43: t262] #insertv                 unsafe.Pointer
	t241 = *t0                                                     *maptype
	t242 = &t241.key [#1]                                           **_type
	t243 = *t242                                                     *_type
	t244 = &t243.size [#0]                                         *uintptr
	t245 = *t244                                                    uintptr
	t246 = memmove(t228, key, t245)                                      ()
	t247 = *t0                                                     *maptype
	t248 = &t247.elem [#2]                                          **_type
	t249 = *t248                                                     *_type
	t250 = &t249.size [#0]                                         *uintptr
	t251 = *t250                                                    uintptr
	t252 = memmove(t240, val, t251)                                      ()
	*t202 = t74
	t253 = &h.count [#0]                                               *int
	t254 = *t253                                                        int
	t255 = t254 + 1:int                                                 int
	*t253 = t255
	return
42:                                                             if.then P:1 S:1
	t256 = &memstats.next_gc [#21]                                  *uint64
	t257 = &memstats.heap_alloc [#6]                                *uint64
	t258 = *t257                                                     uint64
	*t256 = t258
	jump 43
43:                                                             if.done P:2 S:1
	t259 = *t0                                                     *maptype
	t260 = &t259.elem [#2]                                          **_type
	t261 = *t260                                                     *_type
	t262 = newobject(t261)                                   unsafe.Pointer
	t263 = convert *unsafe.Pointer <- unsafe.Pointer (t204) *unsafe.Pointer
	*t263 = t262
	jump 41

# Name: runtime.mapdelete
# Package: runtime
# Location: /usr/local/go/src/runtime/hashmap.go:495:6
func mapdelete(t *maptype, h *hmap, key unsafe.Pointer):
0:                                                                entry P:0 S:2
	t0 = new *maptype (t)                                         **maptype
	*t0 = t
	if false:untyped bool goto 3 else 2
1:                                                              if.then P:1 S:1
	t1 = convert unsafe.Pointer <- **maptype (t0)            unsafe.Pointer
	t2 = getcallerpc(t1)                                            uintptr
	t3 = make interface{} <- func(t *maptype, h *hmap, key unsafe.Pointer) (mapdelete) interface{}
	t4 = funcPC(t3)                                                 uintptr
	t5 = convert unsafe.Pointer <- *hmap (h)                 unsafe.Pointer
	t6 = racewritepc(t5, t2, t4)                                         ()
	t7 = *t0                                                       *maptype
	t8 = &t7.key [#1]                                               **_type
	t9 = *t8                                                         *_type
	t10 = raceReadObjectPC(t9, key, t2, t4)                              ()
	jump 2
2:                                                              if.done P:3 S:2
	t11 = h == nil:*hmap                                               bool
	if t11 goto 4 else 6
3:                                                            cond.true P:1 S:2
	t12 = h != nil:*hmap                                               bool
	if t12 goto 1 else 2
4:                                                              if.then P:2 S:0
	return
5:                                                              if.done P:1 S:2
	t13 = *t0                                                      *maptype
	t14 = &t13.key [#1]                                             **_type
	t15 = *t14                                                       *_type
	t16 = &t15.alg [#6]                                     *unsafe.Pointer
	t17 = *t16                                               unsafe.Pointer
	t18 = goalg(t17)                                               *typeAlg
	t19 = &t18.hash [#0]    *func(unsafe.Pointer, uintptr, uintptr) uintptr
	t20 = *t19               func(unsafe.Pointer, uintptr, uintptr) uintptr
	t21 = *t0                                                      *maptype
	t22 = &t21.key [#1]                                             **_type
	t23 = *t22                                                       *_type
	t24 = &t23.size [#0]                                           *uintptr
	t25 = *t24                                                      uintptr
	t26 = &h.hash0 [#2]                                             *uint32
	t27 = *t26                                                       uint32
	t28 = convert uintptr <- uint32 (t27)                           uintptr
	t29 = t20(key, t25, t28)                                        uintptr
	t30 = &h.B [#3]                                                  *uint8
	t31 = *t30                                                        uint8
	t32 = 1:uintptr << t31                                          uintptr
	t33 = t32 - 1:uintptr                                           uintptr
	t34 = t29 & t33                                                 uintptr
	t35 = &h.oldbuckets [#5]                                *unsafe.Pointer
	t36 = *t35                                               unsafe.Pointer
	t37 = t36 != nil:unsafe.Pointer                                    bool
	if t37 goto 7 else 8
6:                                                           cond.false P:1 S:2
	t38 = &h.count [#0]                                                *int
	t39 = *t38                                                          int
	t40 = t39 == 0:int                                                 bool
	if t40 goto 4 else 5
7:                                                              if.then P:1 S:1
	t41 = *t0                                                      *maptype
	t42 = growWork(t41, h, t34)                                          ()
	jump 8
8:                                                              if.done P:2 S:2
	t43 = &h.buckets [#4]                                   *unsafe.Pointer
	t44 = *t43                                               unsafe.Pointer
	t45 = convert uintptr <- unsafe.Pointer (t44)                   uintptr
	t46 = *t0                                                      *maptype
	t47 = &t46.bucketsize [#9]                                      *uint16
	t48 = *t47                                                       uint16
	t49 = convert uintptr <- uint16 (t48)                           uintptr
	t50 = t34 * t49                                                 uintptr
	t51 = t45 + t50                                                 uintptr
	t52 = convert unsafe.Pointer <- uintptr (t51)            unsafe.Pointer
	t53 = convert *bmap <- unsafe.Pointer (t52)                       *bmap
	t54 = t29 >> 56:uint64                                          uintptr
	t55 = convert uint8 <- uintptr (t54)                              uint8
	t56 = t55 < 4:uint8                                                bool
	if t56 goto 9 else 10
9:                                                              if.then P:1 S:1
	t57 = t55 + 4:uint8                                               uint8
	jump 10
10:                                                            for.body P:3 S:1
	t58 = phi [8: t53, 12: t68, 9: t53] #b                            *bmap
	t59 = phi [8: t55, 12: t59, 9: t57] #top                          uint8
	t60 = phi [8: nil:unsafe.Pointer, 12: t71, 9: nil:unsafe.Pointer] #k unsafe.Pointer
	t61 = phi [8: nil:unsafe.Pointer, 12: t72, 9: nil:unsafe.Pointer] #k2 unsafe.Pointer
	jump 13
11:                                                            for.body P:1 S:2
	t62 = &t58.tophash [#0]                                       *[8]uint8
	t63 = convert int <- uintptr (t70)                                  int
	t64 = &t62[t63]                                                  *uint8
	t65 = *t64                                                        uint8
	t66 = t65 != t59                                                   bool
	if t66 goto 14 else 15
12:                                                            for.done P:1 S:2
	t67 = *t0                                                      *maptype
	t68 = (*bmap).overflow(t58, t67)                                  *bmap
	t69 = t68 == nil:*bmap                                             bool
	if t69 goto 19 else 10
13:                                                            for.loop P:2 S:2
	t70 = phi [10: 0:uintptr, 14: t76] #i                           uintptr
	t71 = phi [10: t60, 14: t74] #k                          unsafe.Pointer
	t72 = phi [10: t61, 14: t75] #k2                         unsafe.Pointer
	t73 = t70 < 8:uintptr                                              bool
	if t73 goto 11 else 12
14:                                                            for.post P:2 S:1
	t74 = phi [11: t71, 17: t84] #k                          unsafe.Pointer
	t75 = phi [11: t72, 17: t90] #k2                         unsafe.Pointer
	t76 = t70 + 1:uintptr                                           uintptr
	jump 13
15:                                                             if.done P:1 S:2
	t77 = convert unsafe.Pointer <- *bmap (t58)              unsafe.Pointer
	t78 = *t0                                                      *maptype
	t79 = &t78.keysize [#5]                                          *uint8
	t80 = *t79                                                        uint8
	t81 = convert uintptr <- uint8 (t80)                            uintptr
	t82 = t70 * t81                                                 uintptr
	t83 = 8:uintptr + t82                                           uintptr
	t84 = add(t77, t83)                                      unsafe.Pointer
	t85 = *t0                                                      *maptype
	t86 = &t85.indirectkey [#6]                                       *bool
	t87 = *t86                                                         bool
	if t87 goto 16 else 17
16:                                                             if.then P:1 S:1
	t88 = convert *unsafe.Pointer <- unsafe.Pointer (t84)   *unsafe.Pointer
	t89 = *t88                                               unsafe.Pointer
	jump 17
17:                                                             if.done P:2 S:2
	t90 = phi [15: t84, 16: t89] #k2                         unsafe.Pointer
	t91 = &t18.equal [#1] *func(unsafe.Pointer, unsafe.Pointer, uintptr) bool
	t92 = *t91           func(unsafe.Pointer, unsafe.Pointer, uintptr) bool
	t93 = *t0                                                      *maptype
	t94 = &t93.key [#1]                                             **_type
	t95 = *t94                                                       *_type
	t96 = &t95.size [#0]                                           *uintptr
	t97 = *t96                                                      uintptr
	t98 = t92(key, t90, t97)                                           bool
	if t98 goto 18 else 14
18:                                                             if.done P:1 S:0
	t99 = *t0                                                      *maptype
	t100 = &t99.keysize [#5]                                         *uint8
	t101 = *t100                                                      uint8
	t102 = convert uintptr <- uint8 (t101)                          uintptr
	t103 = memclr(t84, t102)                                             ()
	t104 = convert unsafe.Pointer <- *bmap (t58)             unsafe.Pointer
	t105 = convert uintptr <- unsafe.Pointer (t104)                 uintptr
	t106 = t105 + 8:uintptr                                         uintptr
	t107 = *t0                                                     *maptype
	t108 = &t107.keysize [#5]                                        *uint8
	t109 = *t108                                                      uint8
	t110 = convert uintptr <- uint8 (t109)                          uintptr
	t111 = 8:uintptr * t110                                         uintptr
	t112 = t106 + t111                                              uintptr
	t113 = *t0                                                     *maptype
	t114 = &t113.valuesize [#7]                                      *uint8
	t115 = *t114                                                      uint8
	t116 = convert uintptr <- uint8 (t115)                          uintptr
	t117 = t70 * t116                                               uintptr
	t118 = t112 + t117                                              uintptr
	t119 = convert unsafe.Pointer <- uintptr (t118)          unsafe.Pointer
	t120 = *t0                                                     *maptype
	t121 = &t120.valuesize [#7]                                      *uint8
	t122 = *t121                                                      uint8
	t123 = convert uintptr <- uint8 (t122)                          uintptr
	t124 = memclr(t119, t123)                                            ()
	t125 = &t58.tophash [#0]                                      *[8]uint8
	t126 = convert int <- uintptr (t70)                                 int
	t127 = &t125[t126]                                               *uint8
	*t127 = 0:uint8
	t128 = &h.count [#0]                                               *int
	t129 = *t128                                                        int
	t130 = t129 - 1:int                                                 int
	*t128 = t130
	return
19:                                                             if.then P:1 S:0
	return

# Name: runtime.mapiterinit
# Package: runtime
# Location: /usr/local/go/src/runtime/hashmap.go:543:6
func mapiterinit(t *maptype, h *hmap, it *hiter):
0:                                                                entry P:0 S:2
	t0 = new *maptype (t)                                         **maptype
	*t0 = t
	t1 = &it.key [#0]                                       *unsafe.Pointer
	*t1 = nil:unsafe.Pointer
	t2 = &it.value [#1]                                     *unsafe.Pointer
	*t2 = nil:unsafe.Pointer
	t3 = &it.t [#2]                                               **maptype
	*t3 = nil:*maptype
	t4 = &it.h [#3]                                                  **hmap
	*t4 = nil:*hmap
	t5 = &it.buckets [#4]                                   *unsafe.Pointer
	*t5 = nil:unsafe.Pointer
	t6 = &it.bptr [#5]                                               **bmap
	*t6 = nil:*bmap
	if false:untyped bool goto 3 else 2
1:                                                              if.then P:1 S:1
	t7 = convert unsafe.Pointer <- **maptype (t0)            unsafe.Pointer
	t8 = getcallerpc(t7)                                            uintptr
	t9 = convert unsafe.Pointer <- *hmap (h)                 unsafe.Pointer
	t10 = make interface{} <- func(t *maptype, h *hmap, it *hiter) (mapiterinit) interface{}
	t11 = funcPC(t10)                                               uintptr
	t12 = racereadpc(t9, t8, t11)                                        ()
	jump 2
2:                                                              if.done P:3 S:2
	t13 = h == nil:*hmap                                               bool
	if t13 goto 4 else 6
3:                                                            cond.true P:1 S:2
	t14 = h != nil:*hmap                                               bool
	if t14 goto 1 else 2
4:                                                              if.then P:2 S:0
	t15 = &it.key [#0]                                      *unsafe.Pointer
	*t15 = nil:unsafe.Pointer
	t16 = &it.value [#1]                                    *unsafe.Pointer
	*t16 = nil:unsafe.Pointer
	return
5:                                                              if.done P:1 S:2
	if false:untyped bool goto 7 else 8
6:                                                           cond.false P:1 S:2
	t17 = &h.count [#0]                                                *int
	t18 = *t17                                                          int
	t19 = t18 == 0:int                                                 bool
	if t19 goto 4 else 5
7:                                                              if.then P:1 S:1
	t20 = gothrow("hash_iter size in...":string)                         ()
	jump 8
8:                                                              if.done P:2 S:2
	t21 = &it.t [#2]                                              **maptype
	t22 = *t0                                                      *maptype
	*t21 = t22
	t23 = &it.h [#3]                                                 **hmap
	*t23 = h
	t24 = &it.B [#9]                                                 *uint8
	t25 = &h.B [#3]                                                  *uint8
	t26 = *t25                                                        uint8
	*t24 = t26
	t27 = &it.buckets [#4]                                  *unsafe.Pointer
	t28 = &h.buckets [#4]                                   *unsafe.Pointer
	t29 = *t28                                               unsafe.Pointer
	*t27 = t29
	t30 = fastrand1()                                                uint32
	t31 = convert uintptr <- uint32 (t30)                           uintptr
	t32 = &h.B [#3]                                                  *uint8
	t33 = *t32                                                        uint8
	t34 = t33 > 28:uint8                                               bool
	if t34 goto 9 else 10
9:                                                              if.then P:1 S:1
	t35 = fastrand1()                                                uint32
	t36 = convert uintptr <- uint32 (t35)                           uintptr
	t37 = t36 << 31:uint64                                          uintptr
	t38 = t31 + t37                                                 uintptr
	jump 10
10:                                                             if.done P:2 S:1
	t39 = phi [8: t31, 9: t38] #r                                   uintptr
	t40 = &it.startBucket [#6]                                     *uintptr
	t41 = &h.B [#3]                                                  *uint8
	t42 = *t41                                                        uint8
	t43 = 1:uintptr << t42                                          uintptr
	t44 = t43 - 1:uintptr                                           uintptr
	t45 = t39 & t44                                                 uintptr
	*t40 = t45
	t46 = &it.offset [#7]                                            *uint8
	t47 = &h.B [#3]                                                  *uint8
	t48 = *t47                                                        uint8
	t49 = t39 >> t48                                                uintptr
	t50 = t49 & 7:uintptr                                           uintptr
	t51 = convert uint8 <- uintptr (t50)                              uint8
	*t46 = t51
	t52 = &it.bucket [#11]                                         *uintptr
	t53 = &it.startBucket [#6]                                     *uintptr
	t54 = *t53                                                      uintptr
	*t52 = t54
	t55 = &it.wrapped [#8]                                            *bool
	*t55 = false:bool
	t56 = &it.bptr [#5]                                              **bmap
	*t56 = nil:*bmap
	jump 11
11:                                                            for.body P:2 S:2
	t57 = &h.flags [#1]                                             *uint32
	t58 = *t57                                                       uint32
	t59 = t58 | 1:uint32                                             uint32
	t60 = t59 | 2:uint32                                             uint32
	t61 = t58 == t60                                                   bool
	if t61 goto 12 else 13
12:                                                            for.done P:2 S:0
	t62 = mapiternext(it)                                                ()
	return
13:                                                             if.done P:1 S:2
	t63 = &h.flags [#1]                                             *uint32
	t64 = t58 | 1:uint32                                             uint32
	t65 = t64 | 2:uint32                                             uint32
	t66 = cas(t63, t58, t65)                                           bool
	if t66 goto 12 else 11

# Name: runtime.mapiternext
# Package: runtime
# Location: /usr/local/go/src/runtime/hashmap.go:601:6
func mapiternext(it *hiter):
0:                                                                entry P:0 S:2
	t0 = new *hiter (it)                                            **hiter
	*t0 = it
	t1 = *t0                                                         *hiter
	t2 = &t1.h [#3]                                                  **hmap
	t3 = *t2                                                          *hmap
	if false:untyped bool goto 1 else 2
1:                                                              if.then P:1 S:1
	t4 = convert unsafe.Pointer <- **hiter (t0)              unsafe.Pointer
	t5 = getcallerpc(t4)                                            uintptr
	t6 = convert unsafe.Pointer <- *hmap (t3)                unsafe.Pointer
	t7 = make interface{} <- func(it *hiter) (mapiternext)      interface{}
	t8 = funcPC(t7)                                                 uintptr
	t9 = racereadpc(t6, t5, t8)                                          ()
	jump 2
2:                                                              if.done P:2 S:1
	t10 = *t0                                                        *hiter
	t11 = &t10.t [#2]                                             **maptype
	t12 = *t11                                                     *maptype
	t13 = *t0                                                        *hiter
	t14 = &t13.bucket [#11]                                        *uintptr
	t15 = *t14                                                      uintptr
	t16 = *t0                                                        *hiter
	t17 = &t16.bptr [#5]                                             **bmap
	t18 = *t17                                                        *bmap
	t19 = *t0                                                        *hiter
	t20 = &t19.i [#10]                                               *uint8
	t21 = *t20                                                        uint8
	t22 = *t0                                                        *hiter
	t23 = &t22.checkBucket [#12]                                   *uintptr
	t24 = *t23                                                      uintptr
	t25 = &t12.key [#1]                                             **_type
	t26 = *t25                                                       *_type
	t27 = &t26.alg [#6]                                     *unsafe.Pointer
	t28 = *t27                                               unsafe.Pointer
	t29 = goalg(t28)                                               *typeAlg
	jump 3
3:                                                                 next P:2 S:2
	t30 = phi [2: t15, 17: t142] #bucket                            uintptr
	t31 = phi [2: t18, 17: t141] #b                                   *bmap
	t32 = phi [2: t21, 17: 0:uint8] #i                                uint8
	t33 = phi [2: t24, 17: t145] #checkBucket                       uintptr
	t34 = phi [2: 0:uintptr, 17: t146] #oldbucket                   uintptr
	t35 = phi [2: 0:uint8, 17: t147] #offi                            uint8
	t36 = phi [2: nil:unsafe.Pointer, 17: t148] #k           unsafe.Pointer
	t37 = phi [2: nil:unsafe.Pointer, 17: t149] #v           unsafe.Pointer
	t38 = phi [2: nil:unsafe.Pointer, 17: t150] #k2          unsafe.Pointer
	t39 = phi [2: 0:uintptr, 17: t151] #hash                        uintptr
	t40 = phi [2: nil:unsafe.Pointer, 17: t152] #k2          unsafe.Pointer
	t41 = phi [2: nil:unsafe.Pointer, 17: t153] #rk          unsafe.Pointer
	t42 = phi [2: nil:unsafe.Pointer, 17: t154] #rv          unsafe.Pointer
	t43 = t31 == nil:*bmap                                             bool
	if t43 goto 4 else 18
4:                                                              if.then P:1 S:2
	t44 = *t0                                                        *hiter
	t45 = &t44.startBucket [#6]                                    *uintptr
	t46 = *t45                                                      uintptr
	t47 = t30 == t46                                                   bool
	if t47 goto 7 else 6
5:                                                              if.then P:1 S:0
	t48 = *t0                                                        *hiter
	t49 = &t48.key [#0]                                     *unsafe.Pointer
	*t49 = nil:unsafe.Pointer
	t50 = *t0                                                        *hiter
	t51 = &t50.value [#1]                                   *unsafe.Pointer
	*t51 = nil:unsafe.Pointer
	return
6:                                                              if.done P:2 S:2
	t52 = &t3.oldbuckets [#5]                               *unsafe.Pointer
	t53 = *t52                                               unsafe.Pointer
	t54 = t53 != nil:unsafe.Pointer                                    bool
	if t54 goto 11 else 10
7:                                                            cond.true P:1 S:2
	t55 = *t0                                                        *hiter
	t56 = &t55.wrapped [#8]                                           *bool
	t57 = *t56                                                         bool
	if t57 goto 5 else 6
8:                                                              if.then P:1 S:2
	t58 = *t0                                                        *hiter
	t59 = &t58.B [#9]                                                *uint8
	t60 = *t59                                                        uint8
	t61 = t60 - 1:uint8                                               uint8
	t62 = 1:uintptr << t61                                          uintptr
	t63 = t62 - 1:uintptr                                           uintptr
	t64 = t30 & t63                                                 uintptr
	t65 = &t3.oldbuckets [#5]                               *unsafe.Pointer
	t66 = *t65                                               unsafe.Pointer
	t67 = &t12.bucketsize [#9]                                      *uint16
	t68 = *t67                                                       uint16
	t69 = convert uintptr <- uint16 (t68)                           uintptr
	t70 = t64 * t69                                                 uintptr
	t71 = add(t66, t70)                                      unsafe.Pointer
	t72 = convert *bmap <- unsafe.Pointer (t71)                       *bmap
	t73 = evacuated(t72)                                               bool
	if t73 goto 13 else 12
9:                                                              if.done P:3 S:2
	t74 = phi [12: t72, 10: t91, 13: t106] #b                         *bmap
	t75 = phi [12: t30, 10: 18446744073709551615:uintptr, 13: 18446744073709551615:uintptr] #checkBucket uintptr
	t76 = phi [12: t64, 10: t34, 13: t64] #oldbucket                uintptr
	t77 = t30 + 1:uintptr                                           uintptr
	t78 = *t0                                                        *hiter
	t79 = &t78.B [#9]                                                *uint8
	t80 = *t79                                                        uint8
	t81 = 1:uintptr << t80                                          uintptr
	t82 = t77 == t81                                                   bool
	if t82 goto 14 else 15
10:                                                             if.else P:2 S:1
	t83 = *t0                                                        *hiter
	t84 = &t83.buckets [#4]                                 *unsafe.Pointer
	t85 = *t84                                               unsafe.Pointer
	t86 = &t12.bucketsize [#9]                                      *uint16
	t87 = *t86                                                       uint16
	t88 = convert uintptr <- uint16 (t87)                           uintptr
	t89 = t30 * t88                                                 uintptr
	t90 = add(t85, t89)                                      unsafe.Pointer
	t91 = convert *bmap <- unsafe.Pointer (t90)                       *bmap
	jump 9
11:                                                           cond.true P:1 S:2
	t92 = *t0                                                        *hiter
	t93 = &t92.B [#9]                                                *uint8
	t94 = *t93                                                        uint8
	t95 = &t3.B [#3]                                                 *uint8
	t96 = *t95                                                        uint8
	t97 = t94 == t96                                                   bool
	if t97 goto 8 else 10
12:                                                             if.then P:1 S:1
	jump 9
13:                                                             if.else P:1 S:1
	t98 = *t0                                                        *hiter
	t99 = &t98.buckets [#4]                                 *unsafe.Pointer
	t100 = *t99                                              unsafe.Pointer
	t101 = &t12.bucketsize [#9]                                     *uint16
	t102 = *t101                                                     uint16
	t103 = convert uintptr <- uint16 (t102)                         uintptr
	t104 = t30 * t103                                               uintptr
	t105 = add(t100, t104)                                   unsafe.Pointer
	t106 = convert *bmap <- unsafe.Pointer (t105)                     *bmap
	jump 9
14:                                                             if.then P:1 S:1
	t107 = *t0                                                       *hiter
	t108 = &t107.wrapped [#8]                                         *bool
	*t108 = true:bool
	jump 15
15:                                                             if.done P:2 S:1
	t109 = phi [9: t77, 14: 0:uintptr] #bucket                      uintptr
	jump 18
16:                                                            for.body P:1 S:2
	t110 = *t0                                                       *hiter
	t111 = &t110.offset [#7]                                         *uint8
	t112 = *t111                                                      uint8
	t113 = t144 + t112                                                uint8
	t114 = t113 & 7:uint8                                             uint8
	t115 = convert unsafe.Pointer <- *bmap (t143)            unsafe.Pointer
	t116 = convert uintptr <- uint8 (t114)                          uintptr
	t117 = &t12.keysize [#5]                                         *uint8
	t118 = *t117                                                      uint8
	t119 = convert uintptr <- uint8 (t118)                          uintptr
	t120 = t116 * t119                                              uintptr
	t121 = 8:uintptr + t120                                         uintptr
	t122 = add(t115, t121)                                   unsafe.Pointer
	t123 = convert unsafe.Pointer <- *bmap (t143)            unsafe.Pointer
	t124 = &t12.keysize [#5]                                         *uint8
	t125 = *t124                                                      uint8
	t126 = convert uintptr <- uint8 (t125)                          uintptr
	t127 = 8:uintptr * t126                                         uintptr
	t128 = 8:uintptr + t127                                         uintptr
	t129 = convert uintptr <- uint8 (t114)                          uintptr
	t130 = &t12.valuesize [#7]                                       *uint8
	t131 = *t130                                                      uint8
	t132 = convert uintptr <- uint8 (t131)                          uintptr
	t133 = t129 * t132                                              uintptr
	t134 = t128 + t133                                              uintptr
	t135 = add(t123, t134)                                   unsafe.Pointer
	t136 = &t143.tophash [#0]                                     *[8]uint8
	t137 = convert int <- uint8 (t114)                                  int
	t138 = &t136[t137]                                               *uint8
	t139 = *t138                                                      uint8
	t140 = t139 != 0:uint8                                             bool
	if t140 goto 21 else 19
17:                                                            for.done P:1 S:1
	t141 = (*bmap).overflow(t143, t12)                                *bmap
	jump 3
18:                                                            for.loop P:3 S:2
	t142 = phi [3: t30, 19: t142, 15: t109] #bucket                 uintptr
	t143 = phi [3: t31, 19: t143, 15: t74] #b                         *bmap
	t144 = phi [3: t32, 19: t161, 15: 0:uint8] #i                     uint8
	t145 = phi [3: t33, 19: t145, 15: t75] #checkBucket             uintptr
	t146 = phi [3: t34, 19: t146, 15: t76] #oldbucket               uintptr
	t147 = phi [3: t35, 19: t114, 15: t35] #offi                      uint8
	t148 = phi [3: t36, 19: t122, 15: t36] #k                unsafe.Pointer
	t149 = phi [3: t37, 19: t135, 15: t37] #v                unsafe.Pointer
	t150 = phi [3: t38, 19: t156, 15: t38] #k2               unsafe.Pointer
	t151 = phi [3: t39, 19: t157, 15: t39] #hash                    uintptr
	t152 = phi [3: t40, 19: t158, 15: t40] #k2               unsafe.Pointer
	t153 = phi [3: t41, 19: t159, 15: t41] #rk               unsafe.Pointer
	t154 = phi [3: t42, 19: t160, 15: t42] #rv               unsafe.Pointer
	t155 = t144 < 8:uint8                                              bool
	if t155 goto 16 else 17
19:                                                            for.post P:5 S:1
	t156 = phi [26: t179, 27: t179, 38: t170, 16: t150, 21: t150] #k2 unsafe.Pointer
	t157 = phi [26: t196, 27: t151, 38: t171, 16: t151, 21: t151] #hash uintptr
	t158 = phi [26: t152, 27: t152, 38: t248, 16: t152, 21: t152] #k2 unsafe.Pointer
	t159 = phi [26: t153, 27: t153, 38: t257, 16: t153, 21: t153] #rk unsafe.Pointer
	t160 = phi [26: t154, 27: t154, 38: t258, 16: t154, 21: t154] #rv unsafe.Pointer
	t161 = t144 + 1:uint8                                             uint8
	jump 18
20:                                                             if.then P:1 S:2
	t162 = t145 != 18446744073709551615:uintptr                        bool
	if t162 goto 22 else 23
21:                                                           cond.true P:1 S:2
	t163 = &t143.tophash [#0]                                     *[8]uint8
	t164 = convert int <- uint8 (t114)                                  int
	t165 = &t163[t164]                                               *uint8
	t166 = *t165                                                      uint8
	t167 = t166 != 1:uint8                                             bool
	if t167 goto 20 else 19
22:                                                             if.then P:1 S:2
	t168 = &t12.indirectkey [#6]                                      *bool
	t169 = *t168                                                       bool
	if t169 goto 24 else 25
23:                                                             if.done P:3 S:2
	t170 = phi [20: t150, 26: t179, 27: t179] #k2            unsafe.Pointer
	t171 = phi [20: t151, 26: t196, 27: t151] #hash                 uintptr
	t172 = &t143.tophash [#0]                                     *[8]uint8
	t173 = convert int <- uint8 (t114)                                  int
	t174 = &t172[t173]                                               *uint8
	t175 = *t174                                                      uint8
	t176 = t175 != 2:uint8                                             bool
	if t176 goto 31 else 30
24:                                                             if.then P:1 S:1
	t177 = convert *unsafe.Pointer <- unsafe.Pointer (t122) *unsafe.Pointer
	t178 = *t177                                             unsafe.Pointer
	jump 25
25:                                                             if.done P:2 S:2
	t179 = phi [22: t122, 24: t178] #k2                      unsafe.Pointer
	t180 = &t29.equal [#1] *func(unsafe.Pointer, unsafe.Pointer, uintptr) bool
	t181 = *t180         func(unsafe.Pointer, unsafe.Pointer, uintptr) bool
	t182 = &t12.key [#1]                                            **_type
	t183 = *t182                                                     *_type
	t184 = &t183.size [#0]                                         *uintptr
	t185 = *t184                                                    uintptr
	t186 = t181(t179, t179, t185)                                      bool
	if t186 goto 26 else 27
26:                                                             if.then P:1 S:2
	t187 = &t29.hash [#0]   *func(unsafe.Pointer, uintptr, uintptr) uintptr
	t188 = *t187             func(unsafe.Pointer, uintptr, uintptr) uintptr
	t189 = &t12.key [#1]                                            **_type
	t190 = *t189                                                     *_type
	t191 = &t190.size [#0]                                         *uintptr
	t192 = *t191                                                    uintptr
	t193 = &t3.hash0 [#2]                                           *uint32
	t194 = *t193                                                     uint32
	t195 = convert uintptr <- uint32 (t194)                         uintptr
	t196 = t188(t179, t192, t195)                                   uintptr
	t197 = *t0                                                       *hiter
	t198 = &t197.B [#9]                                              *uint8
	t199 = *t198                                                      uint8
	t200 = 1:uintptr << t199                                        uintptr
	t201 = t200 - 1:uintptr                                         uintptr
	t202 = t196 & t201                                              uintptr
	t203 = t202 != t145                                                bool
	if t203 goto 19 else 23
27:                                                             if.else P:1 S:2
	t204 = *t0                                                       *hiter
	t205 = &t204.B [#9]                                              *uint8
	t206 = *t205                                                      uint8
	t207 = t206 - 1:uint8                                             uint8
	t208 = t145 >> t207                                             uintptr
	t209 = &t143.tophash [#0]                                     *[8]uint8
	t210 = convert int <- uint8 (t114)                                  int
	t211 = &t209[t210]                                               *uint8
	t212 = *t211                                                      uint8
	t213 = t212 & 1:uint8                                             uint8
	t214 = convert uintptr <- uint8 (t213)                          uintptr
	t215 = t208 != t214                                                bool
	if t215 goto 19 else 23
28:                                                             if.then P:1 S:2
	t216 = &t12.indirectkey [#6]                                      *bool
	t217 = *t216                                                       bool
	if t217 goto 32 else 33
29:                                                             if.done P:3 S:0
	t218 = *t0                                                       *hiter
	t219 = &t218.bucket [#11]                                      *uintptr
	*t219 = t142
	t220 = *t0                                                       *hiter
	t221 = &t220.bptr [#5]                                           **bmap
	*t221 = t143
	t222 = *t0                                                       *hiter
	t223 = &t222.i [#10]                                             *uint8
	t224 = t144 + 1:uint8                                             uint8
	*t223 = t224
	t225 = *t0                                                       *hiter
	t226 = &t225.checkBucket [#12]                                 *uintptr
	*t226 = t145
	return
30:                                                             if.else P:2 S:2
	t227 = &t12.indirectkey [#6]                                      *bool
	t228 = *t227                                                       bool
	if t228 goto 36 else 37
31:                                                           cond.true P:1 S:2
	t229 = &t143.tophash [#0]                                     *[8]uint8
	t230 = convert int <- uint8 (t114)                                  int
	t231 = &t229[t230]                                               *uint8
	t232 = *t231                                                      uint8
	t233 = t232 != 3:uint8                                             bool
	if t233 goto 28 else 30
32:                                                             if.then P:1 S:1
	t234 = convert *unsafe.Pointer <- unsafe.Pointer (t122) *unsafe.Pointer
	t235 = *t234                                             unsafe.Pointer
	jump 33
33:                                                             if.done P:2 S:2
	t236 = phi [28: t122, 32: t235] #k                       unsafe.Pointer
	t237 = *t0                                                       *hiter
	t238 = &t237.key [#0]                                   *unsafe.Pointer
	*t238 = t236
	t239 = &t12.indirectvalue [#8]                                    *bool
	t240 = *t239                                                       bool
	if t240 goto 34 else 35
34:                                                             if.then P:1 S:1
	t241 = convert *unsafe.Pointer <- unsafe.Pointer (t135) *unsafe.Pointer
	t242 = *t241                                             unsafe.Pointer
	jump 35
35:                                                             if.done P:2 S:1
	t243 = phi [33: t135, 34: t242] #v                       unsafe.Pointer
	t244 = *t0                                                       *hiter
	t245 = &t244.value [#1]                                 *unsafe.Pointer
	*t245 = t243
	jump 29
36:                                                             if.then P:1 S:1
	t246 = convert *unsafe.Pointer <- unsafe.Pointer (t122) *unsafe.Pointer
	t247 = *t246                                             unsafe.Pointer
	jump 37
37:                                                             if.done P:2 S:2
	t248 = phi [30: t122, 36: t247] #k2                      unsafe.Pointer
	t249 = &t29.equal [#1] *func(unsafe.Pointer, unsafe.Pointer, uintptr) bool
	t250 = *t249         func(unsafe.Pointer, unsafe.Pointer, uintptr) bool
	t251 = &t12.key [#1]                                            **_type
	t252 = *t251                                                     *_type
	t253 = &t252.size [#0]                                         *uintptr
	t254 = *t253                                                    uintptr
	t255 = t250(t248, t248, t254)                                      bool
	if t255 goto 38 else 39
38:                                                             if.then P:1 S:2
	t256 = mapaccessK(t12, t3, t248)       (unsafe.Pointer, unsafe.Pointer)
	t257 = extract t256 #0                                   unsafe.Pointer
	t258 = extract t256 #1                                   unsafe.Pointer
	t259 = t257 == nil:unsafe.Pointer                                  bool
	if t259 goto 19 else 40
39:                                                             if.else P:1 S:2
	t260 = *t0                                                       *hiter
	t261 = &t260.key [#0]                                   *unsafe.Pointer
	*t261 = t248
	t262 = &t12.indirectvalue [#8]                                    *bool
	t263 = *t262                                                       bool
	if t263 goto 41 else 42
40:                                                             if.done P:1 S:1
	t264 = *t0                                                       *hiter
	t265 = &t264.key [#0]                                   *unsafe.Pointer
	*t265 = t257
	t266 = *t0                                                       *hiter
	t267 = &t266.value [#1]                                 *unsafe.Pointer
	*t267 = t258
	jump 29
41:                                                             if.then P:1 S:1
	t268 = convert *unsafe.Pointer <- unsafe.Pointer (t135) *unsafe.Pointer
	t269 = *t268                                             unsafe.Pointer
	jump 42
42:                                                             if.done P:2 S:1
	t270 = phi [39: t135, 41: t269] #v                       unsafe.Pointer
	t271 = *t0                                                       *hiter
	t272 = &t271.value [#1]                                 *unsafe.Pointer
	*t272 = t270
	jump 29

# Name: runtime.hashGrow
# Package: runtime
# Location: /usr/local/go/src/runtime/hashmap.go:736:6
func hashGrow(t *maptype, h *hmap):
0:                                                                entry P:0 S:2
	t0 = &h.oldbuckets [#5]                                 *unsafe.Pointer
	t1 = *t0                                                 unsafe.Pointer
	t2 = t1 != nil:unsafe.Pointer                                      bool
	if t2 goto 1 else 2
1:                                                              if.then P:1 S:1
	t3 = gothrow("evacuation not do...":string)                          ()
	jump 2
2:                                                              if.done P:2 S:2
	t4 = &h.buckets [#4]                                    *unsafe.Pointer
	t5 = *t4                                                 unsafe.Pointer
	if false:untyped bool goto 3 else 4
3:                                                              if.then P:1 S:1
	t6 = &memstats.next_gc [#21]                                    *uint64
	t7 = &memstats.heap_alloc [#6]                                  *uint64
	t8 = *t7                                                         uint64
	*t6 = t8
	jump 4
4:                                                              if.done P:2 S:2
	t9 = &t.bucket [#3]                                             **_type
	t10 = *t9                                                        *_type
	t11 = &h.B [#3]                                                  *uint8
	t12 = *t11                                                        uint8
	t13 = t12 + 1:uint8                                               uint8
	t14 = 1:uintptr << t13                                          uintptr
	t15 = newarray(t10, t14)                                 unsafe.Pointer
	t16 = &h.flags [#1]                                             *uint32
	t17 = *t16                                                       uint32
	t18 = t17 &^ 3:uint32                                            uint32
	t19 = &h.flags [#1]                                             *uint32
	t20 = *t19                                                       uint32
	t21 = t20 & 1:uint32                                             uint32
	t22 = t21 != 0:uint32                                              bool
	if t22 goto 5 else 6
5:                                                              if.then P:1 S:1
	t23 = t18 | 2:uint32                                             uint32
	jump 6
6:                                                              if.done P:2 S:0
	t24 = phi [4: t18, 5: t23] #flags                                uint32
	t25 = &h.B [#3]                                                  *uint8
	t26 = *t25                                                        uint8
	t27 = t26 + 1:uint8                                               uint8
	*t25 = t27
	t28 = &h.flags [#1]                                             *uint32
	*t28 = t24
	t29 = &h.oldbuckets [#5]                                *unsafe.Pointer
	*t29 = t5
	t30 = &h.buckets [#4]                                   *unsafe.Pointer
	*t30 = t15
	t31 = &h.nevacuate [#6]                                        *uintptr
	*t31 = 0:uintptr
	return

# Name: runtime.growWork
# Package: runtime
# Location: /usr/local/go/src/runtime/hashmap.go:760:6
func growWork(t *maptype, h *hmap, bucket uintptr):
0:                                                                entry P:0 S:2
	t0 = &h.B [#3]                                                   *uint8
	t1 = *t0                                                          uint8
	t2 = t1 - 1:uint8                                                 uint8
	t3 = 1:uintptr << t2                                            uintptr
	t4 = t3 - 1:uintptr                                             uintptr
	t5 = bucket & t4                                                uintptr
	t6 = evacuate(t, h, t5)                                              ()
	t7 = &h.oldbuckets [#5]                                 *unsafe.Pointer
	t8 = *t7                                                 unsafe.Pointer
	t9 = t8 != nil:unsafe.Pointer                                      bool
	if t9 goto 1 else 2
1:                                                              if.then P:1 S:1
	t10 = &h.nevacuate [#6]                                        *uintptr
	t11 = *t10                                                      uintptr
	t12 = evacuate(t, h, t11)                                            ()
	jump 2
2:                                                              if.done P:2 S:0
	return

# Name: runtime.evacuate
# Package: runtime
# Location: /usr/local/go/src/runtime/hashmap.go:773:6
func evacuate(t *maptype, h *hmap, oldbucket uintptr):
0:                                                                entry P:0 S:2
	t0 = &h.oldbuckets [#5]                                 *unsafe.Pointer
	t1 = *t0                                                 unsafe.Pointer
	t2 = &t.bucketsize [#9]                                         *uint16
	t3 = *t2                                                         uint16
	t4 = convert uintptr <- uint16 (t3)                             uintptr
	t5 = oldbucket * t4                                             uintptr
	t6 = add(t1, t5)                                         unsafe.Pointer
	t7 = convert *bmap <- unsafe.Pointer (t6)                         *bmap
	t8 = &h.B [#3]                                                   *uint8
	t9 = *t8                                                          uint8
	t10 = t9 - 1:uint8                                                uint8
	t11 = 1:uintptr << t10                                          uintptr
	t12 = &t.key [#1]                                               **_type
	t13 = *t12                                                       *_type
	t14 = &t13.alg [#6]                                     *unsafe.Pointer
	t15 = *t14                                               unsafe.Pointer
	t16 = goalg(t15)                                               *typeAlg
	t17 = evacuated(t7)                                                bool
	if t17 goto 2 else 1
1:                                                              if.then P:1 S:1
	t18 = &h.buckets [#4]                                   *unsafe.Pointer
	t19 = *t18                                               unsafe.Pointer
	t20 = &t.bucketsize [#9]                                        *uint16
	t21 = *t20                                                       uint16
	t22 = convert uintptr <- uint16 (t21)                           uintptr
	t23 = oldbucket * t22                                           uintptr
	t24 = add(t19, t23)                                      unsafe.Pointer
	t25 = convert *bmap <- unsafe.Pointer (t24)                       *bmap
	t26 = &h.buckets [#4]                                   *unsafe.Pointer
	t27 = *t26                                               unsafe.Pointer
	t28 = oldbucket + t11                                           uintptr
	t29 = &t.bucketsize [#9]                                        *uint16
	t30 = *t29                                                       uint16
	t31 = convert uintptr <- uint16 (t30)                           uintptr
	t32 = t28 * t31                                                 uintptr
	t33 = add(t27, t32)                                      unsafe.Pointer
	t34 = convert *bmap <- unsafe.Pointer (t33)                       *bmap
	t35 = convert unsafe.Pointer <- *bmap (t25)              unsafe.Pointer
	t36 = add(t35, 8:uintptr)                                unsafe.Pointer
	t37 = convert unsafe.Pointer <- *bmap (t34)              unsafe.Pointer
	t38 = add(t37, 8:uintptr)                                unsafe.Pointer
	t39 = &t.keysize [#5]                                            *uint8
	t40 = *t39                                                        uint8
	t41 = convert uintptr <- uint8 (t40)                            uintptr
	t42 = 8:uintptr * t41                                           uintptr
	t43 = add(t36, t42)                                      unsafe.Pointer
	t44 = &t.keysize [#5]                                            *uint8
	t45 = *t44                                                        uint8
	t46 = convert uintptr <- uint8 (t45)                            uintptr
	t47 = 8:uintptr * t46                                           uintptr
	t48 = add(t38, t47)                                      unsafe.Pointer
	jump 5
2:                                                              if.done P:3 S:2
	t49 = &h.nevacuate [#6]                                        *uintptr
	t50 = *t49                                                      uintptr
	t51 = oldbucket == t50                                             bool
	if t51 goto 46 else 47
3:                                                             for.body P:1 S:1
	t52 = convert unsafe.Pointer <- *bmap (t63)              unsafe.Pointer
	t53 = add(t52, 8:uintptr)                                unsafe.Pointer
	t54 = &t.keysize [#5]                                            *uint8
	t55 = *t54                                                        uint8
	t56 = convert uintptr <- uint8 (t55)                            uintptr
	t57 = 8:uintptr * t56                                           uintptr
	t58 = add(t53, t57)                                      unsafe.Pointer
	jump 8
4:                                                             for.done P:1 S:2
	t59 = &h.flags [#1]                                             *uint32
	t60 = *t59                                                       uint32
	t61 = t60 & 2:uint32                                             uint32
	t62 = t61 == 0:uint32                                              bool
	if t62 goto 45 else 2
5:                                                             for.loop P:2 S:2
	t63 = phi [1: t7, 7: t82] #b                                      *bmap
	t64 = phi [1: t25, 7: t83] #x                                     *bmap
	t65 = phi [1: t34, 7: t84] #y                                     *bmap
	t66 = phi [1: 0:int, 7: t85] #xi                                    int
	t67 = phi [1: 0:int, 7: t86] #yi                                    int
	t68 = phi [1: t36, 7: t87] #xk                           unsafe.Pointer
	t69 = phi [1: t38, 7: t88] #yk                           unsafe.Pointer
	t70 = phi [1: t43, 7: t89] #xv                           unsafe.Pointer
	t71 = phi [1: t48, 7: t90] #yv                           unsafe.Pointer
	t72 = phi [1: 0:uint8, 7: t94] #top                               uint8
	t73 = phi [1: nil:unsafe.Pointer, 7: t95] #k2            unsafe.Pointer
	t74 = phi [1: 0:uintptr, 7: t96] #hash                          uintptr
	t75 = phi [1: nil:*bmap, 7: t97] #newx                            *bmap
	t76 = phi [1: nil:*bmap, 7: t98] #newy                            *bmap
	t77 = t63 != nil:*bmap                                             bool
	if t77 goto 3 else 4
6:                                                             for.body P:1 S:2
	t78 = &t63.tophash [#0]                                       *[8]uint8
	t79 = &t78[t93]                                                  *uint8
	t80 = *t79                                                        uint8
	t81 = t80 == 0:uint8                                               bool
	if t81 goto 10 else 11
7:                                                             for.done P:1 S:1
	t82 = (*bmap).overflow(t63, t)                                    *bmap
	jump 5
8:                                                             for.loop P:2 S:2
	t83 = phi [3: t64, 9: t100] #x                                    *bmap
	t84 = phi [3: t65, 9: t101] #y                                    *bmap
	t85 = phi [3: t66, 9: t102] #xi                                     int
	t86 = phi [3: t67, 9: t103] #yi                                     int
	t87 = phi [3: t68, 9: t104] #xk                          unsafe.Pointer
	t88 = phi [3: t69, 9: t105] #yk                          unsafe.Pointer
	t89 = phi [3: t70, 9: t106] #xv                          unsafe.Pointer
	t90 = phi [3: t71, 9: t107] #yv                          unsafe.Pointer
	t91 = phi [3: t53, 9: t117] #k                           unsafe.Pointer
	t92 = phi [3: t58, 9: t121] #v                           unsafe.Pointer
	t93 = phi [3: 0:int, 9: t113] #i                                    int
	t94 = phi [3: t72, 9: t108] #top                                  uint8
	t95 = phi [3: t73, 9: t109] #k2                          unsafe.Pointer
	t96 = phi [3: t74, 9: t110] #hash                               uintptr
	t97 = phi [3: t75, 9: t111] #newx                                 *bmap
	t98 = phi [3: t76, 9: t112] #newy                                 *bmap
	t99 = t93 < 8:int                                                  bool
	if t99 goto 6 else 7
9:                                                             for.post P:3 S:1
	t100 = phi [10: t83, 33: t171, 43: t83] #x                        *bmap
	t101 = phi [10: t84, 33: t84, 43: t220] #y                        *bmap
	t102 = phi [10: t85, 33: t206, 43: t85] #xi                         int
	t103 = phi [10: t86, 33: t86, 43: t255] #yi                         int
	t104 = phi [10: t87, 33: t210, 43: t87] #xk              unsafe.Pointer
	t105 = phi [10: t88, 33: t88, 43: t259] #yk              unsafe.Pointer
	t106 = phi [10: t89, 33: t214, 43: t89] #xv              unsafe.Pointer
	t107 = phi [10: t90, 33: t90, 43: t263] #yv              unsafe.Pointer
	t108 = phi [10: t80, 33: t152, 43: t152] #top                     uint8
	t109 = phi [10: t95, 33: t130, 43: t130] #k2             unsafe.Pointer
	t110 = phi [10: t96, 33: t153, 43: t153] #hash                  uintptr
	t111 = phi [10: t97, 33: t175, 43: t97] #newx                     *bmap
	t112 = phi [10: t98, 33: t98, 43: t224] #newy                     *bmap
	t113 = t93 + 1:int                                                  int
	t114 = &t.keysize [#5]                                           *uint8
	t115 = *t114                                                      uint8
	t116 = convert uintptr <- uint8 (t115)                          uintptr
	t117 = add(t91, t116)                                    unsafe.Pointer
	t118 = &t.valuesize [#7]                                         *uint8
	t119 = *t118                                                      uint8
	t120 = convert uintptr <- uint8 (t119)                          uintptr
	t121 = add(t92, t120)                                    unsafe.Pointer
	jump 8
10:                                                             if.then P:1 S:1
	t122 = &t63.tophash [#0]                                      *[8]uint8
	t123 = &t122[t93]                                                *uint8
	*t123 = 1:uint8
	jump 9
11:                                                             if.done P:1 S:2
	t124 = t80 < 4:uint8                                               bool
	if t124 goto 12 else 13
12:                                                             if.then P:1 S:1
	t125 = gothrow("bad map state":string)                               ()
	jump 13
13:                                                             if.done P:2 S:2
	t126 = &t.indirectkey [#6]                                        *bool
	t127 = *t126                                                       bool
	if t127 goto 14 else 15
14:                                                             if.then P:1 S:1
	t128 = convert *unsafe.Pointer <- unsafe.Pointer (t91)  *unsafe.Pointer
	t129 = *t128                                             unsafe.Pointer
	jump 15
15:                                                             if.done P:2 S:2
	t130 = phi [13: t91, 14: t129] #k2                       unsafe.Pointer
	t131 = &t16.hash [#0]   *func(unsafe.Pointer, uintptr, uintptr) uintptr
	t132 = *t131             func(unsafe.Pointer, uintptr, uintptr) uintptr
	t133 = &t.key [#1]                                              **_type
	t134 = *t133                                                     *_type
	t135 = &t134.size [#0]                                         *uintptr
	t136 = *t135                                                    uintptr
	t137 = &h.hash0 [#2]                                            *uint32
	t138 = *t137                                                     uint32
	t139 = convert uintptr <- uint32 (t138)                         uintptr
	t140 = t132(t130, t136, t139)                                   uintptr
	t141 = &h.flags [#1]                                            *uint32
	t142 = *t141                                                     uint32
	t143 = t142 & 1:uint32                                           uint32
	t144 = t143 != 0:uint32                                            bool
	if t144 goto 16 else 17
16:                                                             if.then P:1 S:2
	t145 = &t16.equal [#1] *func(unsafe.Pointer, unsafe.Pointer, uintptr) bool
	t146 = *t145         func(unsafe.Pointer, unsafe.Pointer, uintptr) bool
	t147 = &t.key [#1]                                              **_type
	t148 = *t147                                                     *_type
	t149 = &t148.size [#0]                                         *uintptr
	t150 = *t149                                                    uintptr
	t151 = t146(t130, t130, t150)                                      bool
	if t151 goto 17 else 18
17:                                                             if.done P:4 S:2
	t152 = phi [15: t80, 16: t80, 20: t161, 22: t164] #top            uint8
	t153 = phi [15: t140, 16: t140, 20: t159, 22: t159] #hash       uintptr
	t154 = t153 & t11                                               uintptr
	t155 = t154 == 0:uintptr                                           bool
	if t155 goto 23 else 24
18:                                                             if.then P:1 S:2
	t156 = t80 & 1:uint8                                              uint8
	t157 = t156 != 0:uint8                                             bool
	if t157 goto 19 else 21
19:                                                             if.then P:1 S:1
	t158 = t140 | t11                                               uintptr
	jump 20
20:                                                             if.done P:2 S:2
	t159 = phi [19: t158, 21: t163] #hash                           uintptr
	t160 = t159 >> 56:uint64                                        uintptr
	t161 = convert uint8 <- uintptr (t160)                            uint8
	t162 = t161 < 4:uint8                                              bool
	if t162 goto 22 else 17
21:                                                             if.else P:1 S:1
	t163 = t140 &^ t11                                              uintptr
	jump 20
22:                                                             if.then P:1 S:1
	t164 = t161 + 4:uint8                                             uint8
	jump 17
23:                                                             if.then P:1 S:2
	t165 = &t63.tophash [#0]                                      *[8]uint8
	t166 = &t165[t93]                                                *uint8
	*t166 = 2:uint8
	t167 = t85 == 8:int                                                bool
	if t167 goto 25 else 26
24:                                                             if.else P:1 S:2
	t168 = &t63.tophash [#0]                                      *[8]uint8
	t169 = &t168[t93]                                                *uint8
	*t169 = 3:uint8
	t170 = t86 == 8:int                                                bool
	if t170 goto 35 else 36
25:                                                             if.then P:1 S:2
	if false:untyped bool goto 27 else 28
26:                                                             if.done P:2 S:2
	t171 = phi [23: t83, 28: t186] #x                                 *bmap
	t172 = phi [23: t85, 28: 0:int] #xi                                 int
	t173 = phi [23: t87, 28: t189] #xk                       unsafe.Pointer
	t174 = phi [23: t89, 28: t194] #xv                       unsafe.Pointer
	t175 = phi [23: t97, 28: t186] #newx                              *bmap
	t176 = &t171.tophash [#0]                                     *[8]uint8
	t177 = &t176[t172]                                               *uint8
	*t177 = t152
	t178 = &t.indirectkey [#6]                                        *bool
	t179 = *t178                                                       bool
	if t179 goto 29 else 31
27:                                                             if.then P:1 S:1
	t180 = &memstats.next_gc [#21]                                  *uint64
	t181 = &memstats.heap_alloc [#6]                                *uint64
	t182 = *t181                                                     uint64
	*t180 = t182
	jump 28
28:                                                             if.done P:2 S:1
	t183 = &t.bucket [#3]                                           **_type
	t184 = *t183                                                     *_type
	t185 = newobject(t184)                                   unsafe.Pointer
	t186 = convert *bmap <- unsafe.Pointer (t185)                     *bmap
	t187 = (*bmap).setoverflow(t83, t, t186)                             ()
	t188 = convert unsafe.Pointer <- *bmap (t186)            unsafe.Pointer
	t189 = add(t188, 8:uintptr)                              unsafe.Pointer
	t190 = &t.keysize [#5]                                           *uint8
	t191 = *t190                                                      uint8
	t192 = convert uintptr <- uint8 (t191)                          uintptr
	t193 = 8:uintptr * t192                                         uintptr
	t194 = add(t189, t193)                                   unsafe.Pointer
	jump 26
29:                                                             if.then P:1 S:1
	t195 = convert *unsafe.Pointer <- unsafe.Pointer (t173) *unsafe.Pointer
	*t195 = t130
	jump 30
30:                                                             if.done P:2 S:2
	t196 = &t.indirectvalue [#8]                                      *bool
	t197 = *t196                                                       bool
	if t197 goto 32 else 34
31:                                                             if.else P:1 S:1
	t198 = &t.key [#1]                                              **_type
	t199 = *t198                                                     *_type
	t200 = &t199.size [#0]                                         *uintptr
	t201 = *t200                                                    uintptr
	t202 = memmove(t173, t91, t201)                                      ()
	jump 30
32:                                                             if.then P:1 S:1
	t203 = convert *unsafe.Pointer <- unsafe.Pointer (t174) *unsafe.Pointer
	t204 = convert *unsafe.Pointer <- unsafe.Pointer (t92)  *unsafe.Pointer
	t205 = *t204                                             unsafe.Pointer
	*t203 = t205
	jump 33
33:                                                             if.done P:2 S:1
	t206 = t172 + 1:int                                                 int
	t207 = &t.keysize [#5]                                           *uint8
	t208 = *t207                                                      uint8
	t209 = convert uintptr <- uint8 (t208)                          uintptr
	t210 = add(t173, t209)                                   unsafe.Pointer
	t211 = &t.valuesize [#7]                                         *uint8
	t212 = *t211                                                      uint8
	t213 = convert uintptr <- uint8 (t212)                          uintptr
	t214 = add(t174, t213)                                   unsafe.Pointer
	jump 9
34:                                                             if.else P:1 S:1
	t215 = &t.elem [#2]                                             **_type
	t216 = *t215                                                     *_type
	t217 = &t216.size [#0]                                         *uintptr
	t218 = *t217                                                    uintptr
	t219 = memmove(t174, t92, t218)                                      ()
	jump 33
35:                                                             if.then P:1 S:2
	if false:untyped bool goto 37 else 38
36:                                                             if.done P:2 S:2
	t220 = phi [24: t84, 38: t235] #y                                 *bmap
	t221 = phi [24: t86, 38: 0:int] #yi                                 int
	t222 = phi [24: t88, 38: t238] #yk                       unsafe.Pointer
	t223 = phi [24: t90, 38: t243] #yv                       unsafe.Pointer
	t224 = phi [24: t98, 38: t235] #newy                              *bmap
	t225 = &t220.tophash [#0]                                     *[8]uint8
	t226 = &t225[t221]                                               *uint8
	*t226 = t152
	t227 = &t.indirectkey [#6]                                        *bool
	t228 = *t227                                                       bool
	if t228 goto 39 else 41
37:                                                             if.then P:1 S:1
	t229 = &memstats.next_gc [#21]                                  *uint64
	t230 = &memstats.heap_alloc [#6]                                *uint64
	t231 = *t230                                                     uint64
	*t229 = t231
	jump 38
38:                                                             if.done P:2 S:1
	t232 = &t.bucket [#3]                                           **_type
	t233 = *t232                                                     *_type
	t234 = newobject(t233)                                   unsafe.Pointer
	t235 = convert *bmap <- unsafe.Pointer (t234)                     *bmap
	t236 = (*bmap).setoverflow(t84, t, t235)                             ()
	t237 = convert unsafe.Pointer <- *bmap (t235)            unsafe.Pointer
	t238 = add(t237, 8:uintptr)                              unsafe.Pointer
	t239 = &t.keysize [#5]                                           *uint8
	t240 = *t239                                                      uint8
	t241 = convert uintptr <- uint8 (t240)                          uintptr
	t242 = 8:uintptr * t241                                         uintptr
	t243 = add(t238, t242)                                   unsafe.Pointer
	jump 36
39:                                                             if.then P:1 S:1
	t244 = convert *unsafe.Pointer <- unsafe.Pointer (t222) *unsafe.Pointer
	*t244 = t130
	jump 40
40:                                                             if.done P:2 S:2
	t245 = &t.indirectvalue [#8]                                      *bool
	t246 = *t245                                                       bool
	if t246 goto 42 else 44
41:                                                             if.else P:1 S:1
	t247 = &t.key [#1]                                              **_type
	t248 = *t247                                                     *_type
	t249 = &t248.size [#0]                                         *uintptr
	t250 = *t249                                                    uintptr
	t251 = memmove(t222, t91, t250)                                      ()
	jump 40
42:                                                             if.then P:1 S:1
	t252 = convert *unsafe.Pointer <- unsafe.Pointer (t223) *unsafe.Pointer
	t253 = convert *unsafe.Pointer <- unsafe.Pointer (t92)  *unsafe.Pointer
	t254 = *t253                                             unsafe.Pointer
	*t252 = t254
	jump 43
43:                                                             if.done P:2 S:1
	t255 = t221 + 1:int                                                 int
	t256 = &t.keysize [#5]                                           *uint8
	t257 = *t256                                                      uint8
	t258 = convert uintptr <- uint8 (t257)                          uintptr
	t259 = add(t222, t258)                                   unsafe.Pointer
	t260 = &t.valuesize [#7]                                         *uint8
	t261 = *t260                                                      uint8
	t262 = convert uintptr <- uint8 (t261)                          uintptr
	t263 = add(t223, t262)                                   unsafe.Pointer
	jump 9
44:                                                             if.else P:1 S:1
	t264 = &t.elem [#2]                                             **_type
	t265 = *t264                                                     *_type
	t266 = &t265.size [#0]                                         *uintptr
	t267 = *t266                                                    uintptr
	t268 = memmove(t223, t92, t267)                                      ()
	jump 43
45:                                                             if.then P:1 S:1
	t269 = &h.oldbuckets [#5]                               *unsafe.Pointer
	t270 = *t269                                             unsafe.Pointer
	t271 = &t.bucketsize [#9]                                       *uint16
	t272 = *t271                                                     uint16
	t273 = convert uintptr <- uint16 (t272)                         uintptr
	t274 = oldbucket * t273                                         uintptr
	t275 = add(t270, t274)                                   unsafe.Pointer
	t276 = convert *bmap <- unsafe.Pointer (t275)                     *bmap
	t277 = convert unsafe.Pointer <- *bmap (t276)            unsafe.Pointer
	t278 = add(t277, 8:uintptr)                              unsafe.Pointer
	t279 = &t.bucketsize [#9]                                       *uint16
	t280 = *t279                                                     uint16
	t281 = convert uintptr <- uint16 (t280)                         uintptr
	t282 = t281 - 8:uintptr                                         uintptr
	t283 = memclr(t278, t282)                                            ()
	jump 2
46:                                                             if.then P:1 S:2
	t284 = &h.nevacuate [#6]                                       *uintptr
	t285 = oldbucket + 1:uintptr                                    uintptr
	*t284 = t285
	t286 = oldbucket + 1:uintptr                                    uintptr
	t287 = t286 == t11                                                 bool
	if t287 goto 48 else 47
47:                                                             if.done P:3 S:0
	return
48:                                                             if.then P:1 S:1
	t288 = &h.oldbuckets [#5]                               *unsafe.Pointer
	*t288 = nil:unsafe.Pointer
	jump 47

# Name: runtime.ismapkey
# Package: runtime
# Location: /usr/local/go/src/runtime/hashmap.go:906:6
func ismapkey(t *_type) bool:
0:                                                                entry P:0 S:0
	t0 = &t.alg [#6]                                        *unsafe.Pointer
	t1 = *t0                                                 unsafe.Pointer
	t2 = goalg(t1)                                                 *typeAlg
	t3 = &t2.hash [#0]      *func(unsafe.Pointer, uintptr, uintptr) uintptr
	t4 = *t3                 func(unsafe.Pointer, uintptr, uintptr) uintptr
	t5 = t4 != nil:func(unsafe.Pointer, uintptr, uintptr) uintptr      bool
	return t5

# Name: runtime.reflect_makemap
# Package: runtime
# Location: /usr/local/go/src/runtime/hashmap.go:912:6
func reflect_makemap(t *maptype) *hmap:
0:                                                                entry P:0 S:0
	t0 = makemap(t, 0:int64)                                          *hmap
	return t0

# Name: runtime.reflect_mapaccess
# Package: runtime
# Location: /usr/local/go/src/runtime/hashmap.go:916:6
func reflect_mapaccess(t *maptype, h *hmap, key unsafe.Pointer) unsafe.Pointer:
0:                                                                entry P:0 S:2
	t0 = mapaccess2(t, h, key)                       (unsafe.Pointer, bool)
	t1 = extract t0 #0                                       unsafe.Pointer
	t2 = extract t0 #1                                                 bool
	if t2 goto 2 else 1
1:                                                              if.then P:1 S:1
	jump 2
2:                                                              if.done P:2 S:0
	t3 = phi [0: t1, 1: nil:unsafe.Pointer] #val             unsafe.Pointer
	return t3

# Name: runtime.reflect_mapassign
# Package: runtime
# Location: /usr/local/go/src/runtime/hashmap.go:925:6
func reflect_mapassign(t *maptype, h *hmap, key unsafe.Pointer, val unsafe.Pointer):
0:                                                                entry P:0 S:0
	t0 = mapassign1(t, h, key, val)                                      ()
	return

# Name: runtime.reflect_mapdelete
# Package: runtime
# Location: /usr/local/go/src/runtime/hashmap.go:929:6
func reflect_mapdelete(t *maptype, h *hmap, key unsafe.Pointer):
0:                                                                entry P:0 S:0
	t0 = mapdelete(t, h, key)                                            ()
	return

# Name: runtime.reflect_mapiterinit
# Package: runtime
# Location: /usr/local/go/src/runtime/hashmap.go:933:6
func reflect_mapiterinit(t *maptype, h *hmap) *hiter:
0:                                                                entry P:0 S:0
	t0 = new hiter (new)                                             *hiter
	t1 = mapiterinit(t, h, t0)                                           ()
	return t0

# Name: runtime.reflect_mapiternext
# Package: runtime
# Location: /usr/local/go/src/runtime/hashmap.go:939:6
func reflect_mapiternext(it *hiter):
0:                                                                entry P:0 S:0
	t0 = mapiternext(it)                                                 ()
	return

# Name: runtime.reflect_mapiterkey
# Package: runtime
# Location: /usr/local/go/src/runtime/hashmap.go:943:6
func reflect_mapiterkey(it *hiter) unsafe.Pointer:
0:                                                                entry P:0 S:0
	t0 = &it.key [#0]                                       *unsafe.Pointer
	t1 = *t0                                                 unsafe.Pointer
	return t1

# Name: runtime.reflect_maplen
# Package: runtime
# Location: /usr/local/go/src/runtime/hashmap.go:947:6
func reflect_maplen(h *hmap) int:
0:                                                                entry P:0 S:2
	t0 = new *hmap (h)                                               **hmap
	*t0 = h
	t1 = *t0                                                          *hmap
	t2 = t1 == nil:*hmap                                               bool
	if t2 goto 1 else 2
1:                                                              if.then P:1 S:0
	return 0:int
2:                                                              if.done P:1 S:2
	if false:untyped bool goto 3 else 4
3:                                                              if.then P:1 S:1
	t3 = convert unsafe.Pointer <- **hmap (t0)               unsafe.Pointer
	t4 = getcallerpc(t3)                                            uintptr
	t5 = *t0                                                          *hmap
	t6 = convert unsafe.Pointer <- *hmap (t5)                unsafe.Pointer
	t7 = make interface{} <- func(h *hmap) int (reflect_maplen) interface{}
	t8 = funcPC(t7)                                                 uintptr
	t9 = racereadpc(t6, t4, t8)                                          ()
	jump 4
4:                                                              if.done P:2 S:0
	t10 = *t0                                                         *hmap
	t11 = &t10.count [#0]                                              *int
	t12 = *t11                                                          int
	return t12

# Name: runtime.reflect_ismapkey
# Package: runtime
# Location: /usr/local/go/src/runtime/hashmap.go:958:6
func reflect_ismapkey(t *_type) bool:
0:                                                                entry P:0 S:0
	t0 = ismapkey(t)                                                   bool
	return t0

# Name: runtime.mapaccess1_fast32
# Package: runtime
# Location: /usr/local/go/src/runtime/hashmap_fast.go:11:6
func mapaccess1_fast32(t *maptype, h *hmap, key uint32) unsafe.Pointer:
0:                                                                entry P:0 S:2
	t0 = new *maptype (t)                                         **maptype
	*t0 = t
	t1 = new uint32 (key)                                           *uint32
	*t1 = key
	if false:untyped bool goto 3 else 2
1:                                                              if.then P:1 S:1
	t2 = convert unsafe.Pointer <- **maptype (t0)            unsafe.Pointer
	t3 = getcallerpc(t2)                                            uintptr
	t4 = convert unsafe.Pointer <- *hmap (h)                 unsafe.Pointer
	t5 = make interface{} <- func(t *maptype, h *hmap, key uint32) unsafe.Pointer (mapaccess1_fast32) interface{}
	t6 = funcPC(t5)                                                 uintptr
	t7 = racereadpc(t4, t3, t6)                                          ()
	jump 2
2:                                                              if.done P:3 S:2
	t8 = h == nil:*hmap                                                bool
	if t8 goto 4 else 6
3:                                                            cond.true P:1 S:2
	t9 = h != nil:*hmap                                                bool
	if t9 goto 1 else 2
4:                                                              if.then P:2 S:0
	t10 = *t0                                                      *maptype
	t11 = &t10.elem [#2]                                            **_type
	t12 = *t11                                                       *_type
	t13 = &t12.zero [#11]                                            **byte
	t14 = *t13                                                        *byte
	t15 = convert unsafe.Pointer <- *byte (t14)              unsafe.Pointer
	return t15
5:                                                              if.done P:1 S:2
	t16 = &h.B [#3]                                                  *uint8
	t17 = *t16                                                        uint8
	t18 = t17 == 0:uint8                                               bool
	if t18 goto 7 else 8
6:                                                           cond.false P:1 S:2
	t19 = &h.count [#0]                                                *int
	t20 = *t19                                                          int
	t21 = t20 == 0:int                                                 bool
	if t21 goto 4 else 5
7:                                                              if.then P:1 S:1
	t22 = &h.buckets [#4]                                   *unsafe.Pointer
	t23 = *t22                                               unsafe.Pointer
	t24 = convert *bmap <- unsafe.Pointer (t23)                       *bmap
	jump 11
8:                                                              if.else P:1 S:2
	t25 = *t0                                                      *maptype
	t26 = &t25.key [#1]                                             **_type
	t27 = *t26                                                       *_type
	t28 = &t27.alg [#6]                                     *unsafe.Pointer
	t29 = *t28                                               unsafe.Pointer
	t30 = goalg(t29)                                               *typeAlg
	t31 = &t30.hash [#0]    *func(unsafe.Pointer, uintptr, uintptr) uintptr
	t32 = *t31               func(unsafe.Pointer, uintptr, uintptr) uintptr
	t33 = convert unsafe.Pointer <- *uint32 (t1)             unsafe.Pointer
	t34 = noescape(t33)                                      unsafe.Pointer
	t35 = &h.hash0 [#2]                                             *uint32
	t36 = *t35                                                       uint32
	t37 = convert uintptr <- uint32 (t36)                           uintptr
	t38 = t32(t34, 4:uintptr, t37)                                  uintptr
	t39 = &h.B [#3]                                                  *uint8
	t40 = *t39                                                        uint8
	t41 = 1:uintptr << t40                                          uintptr
	t42 = t41 - 1:uintptr                                           uintptr
	t43 = &h.buckets [#4]                                   *unsafe.Pointer
	t44 = *t43                                               unsafe.Pointer
	t45 = t38 & t42                                                 uintptr
	t46 = *t0                                                      *maptype
	t47 = &t46.bucketsize [#9]                                      *uint16
	t48 = *t47                                                       uint16
	t49 = convert uintptr <- uint16 (t48)                           uintptr
	t50 = t45 * t49                                                 uintptr
	t51 = add(t44, t50)                                      unsafe.Pointer
	t52 = convert *bmap <- unsafe.Pointer (t51)                       *bmap
	t53 = &h.oldbuckets [#5]                                *unsafe.Pointer
	t54 = *t53                                               unsafe.Pointer
	t55 = t54 != nil:unsafe.Pointer                                    bool
	if t55 goto 9 else 11
9:                                                              if.then P:1 S:2
	t56 = t42 >> 1:uint64                                           uintptr
	t57 = t38 & t56                                                 uintptr
	t58 = *t0                                                      *maptype
	t59 = &t58.bucketsize [#9]                                      *uint16
	t60 = *t59                                                       uint16
	t61 = convert uintptr <- uint16 (t60)                           uintptr
	t62 = t57 * t61                                                 uintptr
	t63 = add(t54, t62)                                      unsafe.Pointer
	t64 = convert *bmap <- unsafe.Pointer (t63)                       *bmap
	t65 = evacuated(t64)                                               bool
	if t65 goto 11 else 10
10:                                                             if.then P:1 S:1
	jump 11
11:                                                            for.body P:5 S:1
	t66 = phi [7: t24, 13: t78, 8: t52, 9: t52, 10: t64] #b           *bmap
	t67 = phi [7: 0:uint32, 13: t81, 8: 0:uint32, 9: 0:uint32, 10: 0:uint32] #k uint32
	t68 = phi [7: 0:uint8, 13: t82, 8: 0:uint8, 9: 0:uint8, 10: 0:uint8] #x uint8
	jump 14
12:                                                            for.body P:1 S:2
	t69 = convert unsafe.Pointer <- *bmap (t66)              unsafe.Pointer
	t70 = t80 * 4:uintptr                                           uintptr
	t71 = 8:uintptr + t70                                           uintptr
	t72 = add(t69, t71)                                      unsafe.Pointer
	t73 = convert *uint32 <- unsafe.Pointer (t72)                   *uint32
	t74 = *t73                                                       uint32
	t75 = *t1                                                        uint32
	t76 = t74 != t75                                                   bool
	if t76 goto 15 else 16
13:                                                            for.done P:1 S:2
	t77 = *t0                                                      *maptype
	t78 = (*bmap).overflow(t66, t77)                                  *bmap
	t79 = t78 == nil:*bmap                                             bool
	if t79 goto 18 else 11
14:                                                            for.loop P:2 S:2
	t80 = phi [11: 0:uintptr, 15: t85] #i                           uintptr
	t81 = phi [11: t67, 15: t74] #k                                  uint32
	t82 = phi [11: t68, 15: t84] #x                                   uint8
	t83 = t80 < 8:uintptr                                              bool
	if t83 goto 12 else 13
15:                                                            for.post P:2 S:1
	t84 = phi [12: t82, 16: t89] #x                                   uint8
	t85 = t80 + 1:uintptr                                           uintptr
	jump 14
16:                                                             if.done P:1 S:2
	t86 = convert unsafe.Pointer <- *bmap (t66)              unsafe.Pointer
	t87 = add(t86, t80)                                      unsafe.Pointer
	t88 = convert *uint8 <- unsafe.Pointer (t87)                     *uint8
	t89 = *t88                                                        uint8
	t90 = t89 == 0:uint8                                               bool
	if t90 goto 15 else 17
17:                                                             if.done P:1 S:0
	t91 = convert unsafe.Pointer <- *bmap (t66)              unsafe.Pointer
	t92 = *t0                                                      *maptype
	t93 = &t92.valuesize [#7]                                        *uint8
	t94 = *t93                                                        uint8
	t95 = convert uintptr <- uint8 (t94)                            uintptr
	t96 = t80 * t95                                                 uintptr
	t97 = 40:uintptr + t96                                          uintptr
	t98 = add(t91, t97)                                      unsafe.Pointer
	return t98
18:                                                             if.then P:1 S:0
	t99 = *t0                                                      *maptype
	t100 = &t99.elem [#2]                                           **_type
	t101 = *t100                                                     *_type
	t102 = &t101.zero [#11]                                          **byte
	t103 = *t102                                                      *byte
	t104 = convert unsafe.Pointer <- *byte (t103)            unsafe.Pointer
	return t104

# Name: runtime.mapaccess2_fast32
# Package: runtime
# Location: /usr/local/go/src/runtime/hashmap_fast.go:53:6
func mapaccess2_fast32(t *maptype, h *hmap, key uint32) (unsafe.Pointer, bool):
0:                                                                entry P:0 S:2
	t0 = new *maptype (t)                                         **maptype
	*t0 = t
	t1 = new uint32 (key)                                           *uint32
	*t1 = key
	if false:untyped bool goto 3 else 2
1:                                                              if.then P:1 S:1
	t2 = convert unsafe.Pointer <- **maptype (t0)            unsafe.Pointer
	t3 = getcallerpc(t2)                                            uintptr
	t4 = convert unsafe.Pointer <- *hmap (h)                 unsafe.Pointer
	t5 = make interface{} <- func(t *maptype, h *hmap, key uint32) (unsafe.Pointer, bool) (mapaccess2_fast32) interface{}
	t6 = funcPC(t5)                                                 uintptr
	t7 = racereadpc(t4, t3, t6)                                          ()
	jump 2
2:                                                              if.done P:3 S:2
	t8 = h == nil:*hmap                                                bool
	if t8 goto 4 else 6
3:                                                            cond.true P:1 S:2
	t9 = h != nil:*hmap                                                bool
	if t9 goto 1 else 2
4:                                                              if.then P:2 S:0
	t10 = *t0                                                      *maptype
	t11 = &t10.elem [#2]                                            **_type
	t12 = *t11                                                       *_type
	t13 = &t12.zero [#11]                                            **byte
	t14 = *t13                                                        *byte
	t15 = convert unsafe.Pointer <- *byte (t14)              unsafe.Pointer
	return t15, false:bool
5:                                                              if.done P:1 S:2
	t16 = &h.B [#3]                                                  *uint8
	t17 = *t16                                                        uint8
	t18 = t17 == 0:uint8                                               bool
	if t18 goto 7 else 8
6:                                                           cond.false P:1 S:2
	t19 = &h.count [#0]                                                *int
	t20 = *t19                                                          int
	t21 = t20 == 0:int                                                 bool
	if t21 goto 4 else 5
7:                                                              if.then P:1 S:1
	t22 = &h.buckets [#4]                                   *unsafe.Pointer
	t23 = *t22                                               unsafe.Pointer
	t24 = convert *bmap <- unsafe.Pointer (t23)                       *bmap
	jump 11
8:                                                              if.else P:1 S:2
	t25 = *t0                                                      *maptype
	t26 = &t25.key [#1]                                             **_type
	t27 = *t26                                                       *_type
	t28 = &t27.alg [#6]                                     *unsafe.Pointer
	t29 = *t28                                               unsafe.Pointer
	t30 = goalg(t29)                                               *typeAlg
	t31 = &t30.hash [#0]    *func(unsafe.Pointer, uintptr, uintptr) uintptr
	t32 = *t31               func(unsafe.Pointer, uintptr, uintptr) uintptr
	t33 = convert unsafe.Pointer <- *uint32 (t1)             unsafe.Pointer
	t34 = noescape(t33)                                      unsafe.Pointer
	t35 = &h.hash0 [#2]                                             *uint32
	t36 = *t35                                                       uint32
	t37 = convert uintptr <- uint32 (t36)                           uintptr
	t38 = t32(t34, 4:uintptr, t37)                                  uintptr
	t39 = &h.B [#3]                                                  *uint8
	t40 = *t39                                                        uint8
	t41 = 1:uintptr << t40                                          uintptr
	t42 = t41 - 1:uintptr                                           uintptr
	t43 = &h.buckets [#4]                                   *unsafe.Pointer
	t44 = *t43                                               unsafe.Pointer
	t45 = t38 & t42                                                 uintptr
	t46 = *t0                                                      *maptype
	t47 = &t46.bucketsize [#9]                                      *uint16
	t48 = *t47                                                       uint16
	t49 = convert uintptr <- uint16 (t48)                           uintptr
	t50 = t45 * t49                                                 uintptr
	t51 = add(t44, t50)                                      unsafe.Pointer
	t52 = convert *bmap <- unsafe.Pointer (t51)                       *bmap
	t53 = &h.oldbuckets [#5]                                *unsafe.Pointer
	t54 = *t53                                               unsafe.Pointer
	t55 = t54 != nil:unsafe.Pointer                                    bool
	if t55 goto 9 else 11
9:                                                              if.then P:1 S:2
	t56 = t42 >> 1:uint64                                           uintptr
	t57 = t38 & t56                                                 uintptr
	t58 = *t0                                                      *maptype
	t59 = &t58.bucketsize [#9]                                      *uint16
	t60 = *t59                                                       uint16
	t61 = convert uintptr <- uint16 (t60)                           uintptr
	t62 = t57 * t61                                                 uintptr
	t63 = add(t54, t62)                                      unsafe.Pointer
	t64 = convert *bmap <- unsafe.Pointer (t63)                       *bmap
	t65 = evacuated(t64)                                               bool
	if t65 goto 11 else 10
10:                                                             if.then P:1 S:1
	jump 11
11:                                                            for.body P:5 S:1
	t66 = phi [7: t24, 13: t78, 8: t52, 9: t52, 10: t64] #b           *bmap
	t67 = phi [7: 0:uint32, 13: t81, 8: 0:uint32, 9: 0:uint32, 10: 0:uint32] #k uint32
	t68 = phi [7: 0:uint8, 13: t82, 8: 0:uint8, 9: 0:uint8, 10: 0:uint8] #x uint8
	jump 14
12:                                                            for.body P:1 S:2
	t69 = convert unsafe.Pointer <- *bmap (t66)              unsafe.Pointer
	t70 = t80 * 4:uintptr                                           uintptr
	t71 = 8:uintptr + t70                                           uintptr
	t72 = add(t69, t71)                                      unsafe.Pointer
	t73 = convert *uint32 <- unsafe.Pointer (t72)                   *uint32
	t74 = *t73                                                       uint32
	t75 = *t1                                                        uint32
	t76 = t74 != t75                                                   bool
	if t76 goto 15 else 16
13:                                                            for.done P:1 S:2
	t77 = *t0                                                      *maptype
	t78 = (*bmap).overflow(t66, t77)                                  *bmap
	t79 = t78 == nil:*bmap                                             bool
	if t79 goto 18 else 11
14:                                                            for.loop P:2 S:2
	t80 = phi [11: 0:uintptr, 15: t85] #i                           uintptr
	t81 = phi [11: t67, 15: t74] #k                                  uint32
	t82 = phi [11: t68, 15: t84] #x                                   uint8
	t83 = t80 < 8:uintptr                                              bool
	if t83 goto 12 else 13
15:                                                            for.post P:2 S:1
	t84 = phi [12: t82, 16: t89] #x                                   uint8
	t85 = t80 + 1:uintptr                                           uintptr
	jump 14
16:                                                             if.done P:1 S:2
	t86 = convert unsafe.Pointer <- *bmap (t66)              unsafe.Pointer
	t87 = add(t86, t80)                                      unsafe.Pointer
	t88 = convert *uint8 <- unsafe.Pointer (t87)                     *uint8
	t89 = *t88                                                        uint8
	t90 = t89 == 0:uint8                                               bool
	if t90 goto 15 else 17
17:                                                             if.done P:1 S:0
	t91 = convert unsafe.Pointer <- *bmap (t66)              unsafe.Pointer
	t92 = *t0                                                      *maptype
	t93 = &t92.valuesize [#7]                                        *uint8
	t94 = *t93                                                        uint8
	t95 = convert uintptr <- uint8 (t94)                            uintptr
	t96 = t80 * t95                                                 uintptr
	t97 = 40:uintptr + t96                                          uintptr
	t98 = add(t91, t97)                                      unsafe.Pointer
	return t98, true:bool
18:                                                             if.then P:1 S:0
	t99 = *t0                                                      *maptype
	t100 = &t99.elem [#2]                                           **_type
	t101 = *t100                                                     *_type
	t102 = &t101.zero [#11]                                          **byte
	t103 = *t102                                                      *byte
	t104 = convert unsafe.Pointer <- *byte (t103)            unsafe.Pointer
	return t104, false:bool

# Name: runtime.mapaccess1_fast64
# Package: runtime
# Location: /usr/local/go/src/runtime/hashmap_fast.go:95:6
func mapaccess1_fast64(t *maptype, h *hmap, key uint64) unsafe.Pointer:
0:                                                                entry P:0 S:2
	t0 = new *maptype (t)                                         **maptype
	*t0 = t
	t1 = new uint64 (key)                                           *uint64
	*t1 = key
	if false:untyped bool goto 3 else 2
1:                                                              if.then P:1 S:1
	t2 = convert unsafe.Pointer <- **maptype (t0)            unsafe.Pointer
	t3 = getcallerpc(t2)                                            uintptr
	t4 = convert unsafe.Pointer <- *hmap (h)                 unsafe.Pointer
	t5 = make interface{} <- func(t *maptype, h *hmap, key uint64) unsafe.Pointer (mapaccess1_fast64) interface{}
	t6 = funcPC(t5)                                                 uintptr
	t7 = racereadpc(t4, t3, t6)                                          ()
	jump 2
2:                                                              if.done P:3 S:2
	t8 = h == nil:*hmap                                                bool
	if t8 goto 4 else 6
3:                                                            cond.true P:1 S:2
	t9 = h != nil:*hmap                                                bool
	if t9 goto 1 else 2
4:                                                              if.then P:2 S:0
	t10 = *t0                                                      *maptype
	t11 = &t10.elem [#2]                                            **_type
	t12 = *t11                                                       *_type
	t13 = &t12.zero [#11]                                            **byte
	t14 = *t13                                                        *byte
	t15 = convert unsafe.Pointer <- *byte (t14)              unsafe.Pointer
	return t15
5:                                                              if.done P:1 S:2
	t16 = &h.B [#3]                                                  *uint8
	t17 = *t16                                                        uint8
	t18 = t17 == 0:uint8                                               bool
	if t18 goto 7 else 8
6:                                                           cond.false P:1 S:2
	t19 = &h.count [#0]                                                *int
	t20 = *t19                                                          int
	t21 = t20 == 0:int                                                 bool
	if t21 goto 4 else 5
7:                                                              if.then P:1 S:1
	t22 = &h.buckets [#4]                                   *unsafe.Pointer
	t23 = *t22                                               unsafe.Pointer
	t24 = convert *bmap <- unsafe.Pointer (t23)                       *bmap
	jump 11
8:                                                              if.else P:1 S:2
	t25 = *t0                                                      *maptype
	t26 = &t25.key [#1]                                             **_type
	t27 = *t26                                                       *_type
	t28 = &t27.alg [#6]                                     *unsafe.Pointer
	t29 = *t28                                               unsafe.Pointer
	t30 = goalg(t29)                                               *typeAlg
	t31 = &t30.hash [#0]    *func(unsafe.Pointer, uintptr, uintptr) uintptr
	t32 = *t31               func(unsafe.Pointer, uintptr, uintptr) uintptr
	t33 = convert unsafe.Pointer <- *uint64 (t1)             unsafe.Pointer
	t34 = noescape(t33)                                      unsafe.Pointer
	t35 = &h.hash0 [#2]                                             *uint32
	t36 = *t35                                                       uint32
	t37 = convert uintptr <- uint32 (t36)                           uintptr
	t38 = t32(t34, 8:uintptr, t37)                                  uintptr
	t39 = &h.B [#3]                                                  *uint8
	t40 = *t39                                                        uint8
	t41 = 1:uintptr << t40                                          uintptr
	t42 = t41 - 1:uintptr                                           uintptr
	t43 = &h.buckets [#4]                                   *unsafe.Pointer
	t44 = *t43                                               unsafe.Pointer
	t45 = t38 & t42                                                 uintptr
	t46 = *t0                                                      *maptype
	t47 = &t46.bucketsize [#9]                                      *uint16
	t48 = *t47                                                       uint16
	t49 = convert uintptr <- uint16 (t48)                           uintptr
	t50 = t45 * t49                                                 uintptr
	t51 = add(t44, t50)                                      unsafe.Pointer
	t52 = convert *bmap <- unsafe.Pointer (t51)                       *bmap
	t53 = &h.oldbuckets [#5]                                *unsafe.Pointer
	t54 = *t53                                               unsafe.Pointer
	t55 = t54 != nil:unsafe.Pointer                                    bool
	if t55 goto 9 else 11
9:                                                              if.then P:1 S:2
	t56 = t42 >> 1:uint64                                           uintptr
	t57 = t38 & t56                                                 uintptr
	t58 = *t0                                                      *maptype
	t59 = &t58.bucketsize [#9]                                      *uint16
	t60 = *t59                                                       uint16
	t61 = convert uintptr <- uint16 (t60)                           uintptr
	t62 = t57 * t61                                                 uintptr
	t63 = add(t54, t62)                                      unsafe.Pointer
	t64 = convert *bmap <- unsafe.Pointer (t63)                       *bmap
	t65 = evacuated(t64)                                               bool
	if t65 goto 11 else 10
10:                                                             if.then P:1 S:1
	jump 11
11:                                                            for.body P:5 S:1
	t66 = phi [7: t24, 13: t78, 8: t52, 9: t52, 10: t64] #b           *bmap
	t67 = phi [7: 0:uint64, 13: t81, 8: 0:uint64, 9: 0:uint64, 10: 0:uint64] #k uint64
	t68 = phi [7: 0:uint8, 13: t82, 8: 0:uint8, 9: 0:uint8, 10: 0:uint8] #x uint8
	jump 14
12:                                                            for.body P:1 S:2
	t69 = convert unsafe.Pointer <- *bmap (t66)              unsafe.Pointer
	t70 = t80 * 8:uintptr                                           uintptr
	t71 = 8:uintptr + t70                                           uintptr
	t72 = add(t69, t71)                                      unsafe.Pointer
	t73 = convert *uint64 <- unsafe.Pointer (t72)                   *uint64
	t74 = *t73                                                       uint64
	t75 = *t1                                                        uint64
	t76 = t74 != t75                                                   bool
	if t76 goto 15 else 16
13:                                                            for.done P:1 S:2
	t77 = *t0                                                      *maptype
	t78 = (*bmap).overflow(t66, t77)                                  *bmap
	t79 = t78 == nil:*bmap                                             bool
	if t79 goto 18 else 11
14:                                                            for.loop P:2 S:2
	t80 = phi [11: 0:uintptr, 15: t85] #i                           uintptr
	t81 = phi [11: t67, 15: t74] #k                                  uint64
	t82 = phi [11: t68, 15: t84] #x                                   uint8
	t83 = t80 < 8:uintptr                                              bool
	if t83 goto 12 else 13
15:                                                            for.post P:2 S:1
	t84 = phi [12: t82, 16: t89] #x                                   uint8
	t85 = t80 + 1:uintptr                                           uintptr
	jump 14
16:                                                             if.done P:1 S:2
	t86 = convert unsafe.Pointer <- *bmap (t66)              unsafe.Pointer
	t87 = add(t86, t80)                                      unsafe.Pointer
	t88 = convert *uint8 <- unsafe.Pointer (t87)                     *uint8
	t89 = *t88                                                        uint8
	t90 = t89 == 0:uint8                                               bool
	if t90 goto 15 else 17
17:                                                             if.done P:1 S:0
	t91 = convert unsafe.Pointer <- *bmap (t66)              unsafe.Pointer
	t92 = *t0                                                      *maptype
	t93 = &t92.valuesize [#7]                                        *uint8
	t94 = *t93                                                        uint8
	t95 = convert uintptr <- uint8 (t94)                            uintptr
	t96 = t80 * t95                                                 uintptr
	t97 = 72:uintptr + t96                                          uintptr
	t98 = add(t91, t97)                                      unsafe.Pointer
	return t98
18:                                                             if.then P:1 S:0
	t99 = *t0                                                      *maptype
	t100 = &t99.elem [#2]                                           **_type
	t101 = *t100                                                     *_type
	t102 = &t101.zero [#11]                                          **byte
	t103 = *t102                                                      *byte
	t104 = convert unsafe.Pointer <- *byte (t103)            unsafe.Pointer
	return t104

# Name: runtime.mapaccess2_fast64
# Package: runtime
# Location: /usr/local/go/src/runtime/hashmap_fast.go:137:6
func mapaccess2_fast64(t *maptype, h *hmap, key uint64) (unsafe.Pointer, bool):
0:                                                                entry P:0 S:2
	t0 = new *maptype (t)                                         **maptype
	*t0 = t
	t1 = new uint64 (key)                                           *uint64
	*t1 = key
	if false:untyped bool goto 3 else 2
1:                                                              if.then P:1 S:1
	t2 = convert unsafe.Pointer <- **maptype (t0)            unsafe.Pointer
	t3 = getcallerpc(t2)                                            uintptr
	t4 = convert unsafe.Pointer <- *hmap (h)                 unsafe.Pointer
	t5 = make interface{} <- func(t *maptype, h *hmap, key uint64) (unsafe.Pointer, bool) (mapaccess2_fast64) interface{}
	t6 = funcPC(t5)                                                 uintptr
	t7 = racereadpc(t4, t3, t6)                                          ()
	jump 2
2:                                                              if.done P:3 S:2
	t8 = h == nil:*hmap                                                bool
	if t8 goto 4 else 6
3:                                                            cond.true P:1 S:2
	t9 = h != nil:*hmap                                                bool
	if t9 goto 1 else 2
4:                                                              if.then P:2 S:0
	t10 = *t0                                                      *maptype
	t11 = &t10.elem [#2]                                            **_type
	t12 = *t11                                                       *_type
	t13 = &t12.zero [#11]                                            **byte
	t14 = *t13                                                        *byte
	t15 = convert unsafe.Pointer <- *byte (t14)              unsafe.Pointer
	return t15, false:bool
5:                                                              if.done P:1 S:2
	t16 = &h.B [#3]                                                  *uint8
	t17 = *t16                                                        uint8
	t18 = t17 == 0:uint8                                               bool
	if t18 goto 7 else 8
6:                                                           cond.false P:1 S:2
	t19 = &h.count [#0]                                                *int
	t20 = *t19                                                          int
	t21 = t20 == 0:int                                                 bool
	if t21 goto 4 else 5
7:                                                              if.then P:1 S:1
	t22 = &h.buckets [#4]                                   *unsafe.Pointer
	t23 = *t22                                               unsafe.Pointer
	t24 = convert *bmap <- unsafe.Pointer (t23)                       *bmap
	jump 11
8:                                                              if.else P:1 S:2
	t25 = *t0                                                      *maptype
	t26 = &t25.key [#1]                                             **_type
	t27 = *t26                                                       *_type
	t28 = &t27.alg [#6]                                     *unsafe.Pointer
	t29 = *t28                                               unsafe.Pointer
	t30 = goalg(t29)                                               *typeAlg
	t31 = &t30.hash [#0]    *func(unsafe.Pointer, uintptr, uintptr) uintptr
	t32 = *t31               func(unsafe.Pointer, uintptr, uintptr) uintptr
	t33 = convert unsafe.Pointer <- *uint64 (t1)             unsafe.Pointer
	t34 = noescape(t33)                                      unsafe.Pointer
	t35 = &h.hash0 [#2]                                             *uint32
	t36 = *t35                                                       uint32
	t37 = convert uintptr <- uint32 (t36)                           uintptr
	t38 = t32(t34, 8:uintptr, t37)                                  uintptr
	t39 = &h.B [#3]                                                  *uint8
	t40 = *t39                                                        uint8
	t41 = 1:uintptr << t40                                          uintptr
	t42 = t41 - 1:uintptr                                           uintptr
	t43 = &h.buckets [#4]                                   *unsafe.Pointer
	t44 = *t43                                               unsafe.Pointer
	t45 = t38 & t42                                                 uintptr
	t46 = *t0                                                      *maptype
	t47 = &t46.bucketsize [#9]                                      *uint16
	t48 = *t47                                                       uint16
	t49 = convert uintptr <- uint16 (t48)                           uintptr
	t50 = t45 * t49                                                 uintptr
	t51 = add(t44, t50)                                      unsafe.Pointer
	t52 = convert *bmap <- unsafe.Pointer (t51)                       *bmap
	t53 = &h.oldbuckets [#5]                                *unsafe.Pointer
	t54 = *t53                                               unsafe.Pointer
	t55 = t54 != nil:unsafe.Pointer                                    bool
	if t55 goto 9 else 11
9:                                                              if.then P:1 S:2
	t56 = t42 >> 1:uint64                                           uintptr
	t57 = t38 & t56                                                 uintptr
	t58 = *t0                                                      *maptype
	t59 = &t58.bucketsize [#9]                                      *uint16
	t60 = *t59                                                       uint16
	t61 = convert uintptr <- uint16 (t60)                           uintptr
	t62 = t57 * t61                                                 uintptr
	t63 = add(t54, t62)                                      unsafe.Pointer
	t64 = convert *bmap <- unsafe.Pointer (t63)                       *bmap
	t65 = evacuated(t64)                                               bool
	if t65 goto 11 else 10
10:                                                             if.then P:1 S:1
	jump 11
11:                                                            for.body P:5 S:1
	t66 = phi [7: t24, 13: t78, 8: t52, 9: t52, 10: t64] #b           *bmap
	t67 = phi [7: 0:uint64, 13: t81, 8: 0:uint64, 9: 0:uint64, 10: 0:uint64] #k uint64
	t68 = phi [7: 0:uint8, 13: t82, 8: 0:uint8, 9: 0:uint8, 10: 0:uint8] #x uint8
	jump 14
12:                                                            for.body P:1 S:2
	t69 = convert unsafe.Pointer <- *bmap (t66)              unsafe.Pointer
	t70 = t80 * 8:uintptr                                           uintptr
	t71 = 8:uintptr + t70                                           uintptr
	t72 = add(t69, t71)                                      unsafe.Pointer
	t73 = convert *uint64 <- unsafe.Pointer (t72)                   *uint64
	t74 = *t73                                                       uint64
	t75 = *t1                                                        uint64
	t76 = t74 != t75                                                   bool
	if t76 goto 15 else 16
13:                                                            for.done P:1 S:2
	t77 = *t0                                                      *maptype
	t78 = (*bmap).overflow(t66, t77)                                  *bmap
	t79 = t78 == nil:*bmap                                             bool
	if t79 goto 18 else 11
14:                                                            for.loop P:2 S:2
	t80 = phi [11: 0:uintptr, 15: t85] #i                           uintptr
	t81 = phi [11: t67, 15: t74] #k                                  uint64
	t82 = phi [11: t68, 15: t84] #x                                   uint8
	t83 = t80 < 8:uintptr                                              bool
	if t83 goto 12 else 13
15:                                                            for.post P:2 S:1
	t84 = phi [12: t82, 16: t89] #x                                   uint8
	t85 = t80 + 1:uintptr                                           uintptr
	jump 14
16:                                                             if.done P:1 S:2
	t86 = convert unsafe.Pointer <- *bmap (t66)              unsafe.Pointer
	t87 = add(t86, t80)                                      unsafe.Pointer
	t88 = convert *uint8 <- unsafe.Pointer (t87)                     *uint8
	t89 = *t88                                                        uint8
	t90 = t89 == 0:uint8                                               bool
	if t90 goto 15 else 17
17:                                                             if.done P:1 S:0
	t91 = convert unsafe.Pointer <- *bmap (t66)              unsafe.Pointer
	t92 = *t0                                                      *maptype
	t93 = &t92.valuesize [#7]                                        *uint8
	t94 = *t93                                                        uint8
	t95 = convert uintptr <- uint8 (t94)                            uintptr
	t96 = t80 * t95                                                 uintptr
	t97 = 72:uintptr + t96                                          uintptr
	t98 = add(t91, t97)                                      unsafe.Pointer
	return t98, true:bool
18:                                                             if.then P:1 S:0
	t99 = *t0                                                      *maptype
	t100 = &t99.elem [#2]                                           **_type
	t101 = *t100                                                     *_type
	t102 = &t101.zero [#11]                                          **byte
	t103 = *t102                                                      *byte
	t104 = convert unsafe.Pointer <- *byte (t103)            unsafe.Pointer
	return t104, false:bool

# Name: runtime.mapaccess1_faststr
# Package: runtime
# Location: /usr/local/go/src/runtime/hashmap_fast.go:179:6
func mapaccess1_faststr(t *maptype, h *hmap, ky string) unsafe.Pointer:
0:                                                                entry P:0 S:2
	t0 = new *maptype (t)                                         **maptype
	*t0 = t
	t1 = new string (ky)                                            *string
	*t1 = ky
	if false:untyped bool goto 3 else 2
1:                                                              if.then P:1 S:1
	t2 = convert unsafe.Pointer <- **maptype (t0)            unsafe.Pointer
	t3 = getcallerpc(t2)                                            uintptr
	t4 = convert unsafe.Pointer <- *hmap (h)                 unsafe.Pointer
	t5 = make interface{} <- func(t *maptype, h *hmap, ky string) unsafe.Pointer (mapaccess1_faststr) interface{}
	t6 = funcPC(t5)                                                 uintptr
	t7 = racereadpc(t4, t3, t6)                                          ()
	jump 2
2:                                                              if.done P:3 S:2
	t8 = h == nil:*hmap                                                bool
	if t8 goto 4 else 6
3:                                                            cond.true P:1 S:2
	t9 = h != nil:*hmap                                                bool
	if t9 goto 1 else 2
4:                                                              if.then P:2 S:0
	t10 = *t0                                                      *maptype
	t11 = &t10.elem [#2]                                            **_type
	t12 = *t11                                                       *_type
	t13 = &t12.zero [#11]                                            **byte
	t14 = *t13                                                        *byte
	t15 = convert unsafe.Pointer <- *byte (t14)              unsafe.Pointer
	return t15
5:                                                              if.done P:1 S:2
	t16 = convert unsafe.Pointer <- *string (t1)             unsafe.Pointer
	t17 = convert *stringStruct <- unsafe.Pointer (t16)       *stringStruct
	t18 = &h.B [#3]                                                  *uint8
	t19 = *t18                                                        uint8
	t20 = t19 == 0:uint8                                               bool
	if t20 goto 7 else 29
6:                                                           cond.false P:1 S:2
	t21 = &h.count [#0]                                                *int
	t22 = *t21                                                          int
	t23 = t22 == 0:int                                                 bool
	if t23 goto 4 else 5
7:                                                              if.then P:1 S:2
	t24 = &h.buckets [#4]                                   *unsafe.Pointer
	t25 = *t24                                               unsafe.Pointer
	t26 = convert *bmap <- unsafe.Pointer (t25)                       *bmap
	t27 = &t17.len [#1]                                                *int
	t28 = *t27                                                          int
	t29 = t28 < 32:int                                                 bool
	if t29 goto 8 else 9
8:                                                              if.then P:1 S:1
	jump 12
9:                                                              if.done P:1 S:1
	jump 20
10:                                                            for.body P:1 S:2
	t30 = convert unsafe.Pointer <- *bmap (t26)              unsafe.Pointer
	t31 = add(t30, t41)                                      unsafe.Pointer
	t32 = convert *uint8 <- unsafe.Pointer (t31)                     *uint8
	t33 = *t32                                                        uint8
	t34 = t33 == 0:uint8                                               bool
	if t34 goto 13 else 14
11:                                                            for.done P:1 S:0
	t35 = *t0                                                      *maptype
	t36 = &t35.elem [#2]                                            **_type
	t37 = *t36                                                       *_type
	t38 = &t37.zero [#11]                                            **byte
	t39 = *t38                                                        *byte
	t40 = convert unsafe.Pointer <- *byte (t39)              unsafe.Pointer
	return t40
12:                                                            for.loop P:2 S:2
	t41 = phi [8: 0:uintptr, 13: t45] #i                            uintptr
	t42 = phi [8: nil:*stringStruct, 13: t44] #k              *stringStruct
	t43 = t41 < 8:uintptr                                              bool
	if t43 goto 10 else 11
13:                                                            for.post P:3 S:1
	t44 = phi [10: t42, 14: t51, 17: t51] #k                  *stringStruct
	t45 = t41 + 1:uintptr                                           uintptr
	jump 12
14:                                                             if.done P:1 S:2
	t46 = convert unsafe.Pointer <- *bmap (t26)              unsafe.Pointer
	t47 = t41 * 2:uintptr                                           uintptr
	t48 = t47 * 8:uintptr                                           uintptr
	t49 = 8:uintptr + t48                                           uintptr
	t50 = add(t46, t49)                                      unsafe.Pointer
	t51 = convert *stringStruct <- unsafe.Pointer (t50)       *stringStruct
	t52 = &t51.len [#1]                                                *int
	t53 = *t52                                                          int
	t54 = &t17.len [#1]                                                *int
	t55 = *t54                                                          int
	t56 = t53 != t55                                                   bool
	if t56 goto 13 else 15
15:                                                             if.done P:1 S:2
	t57 = &t51.str [#0]                                     *unsafe.Pointer
	t58 = *t57                                               unsafe.Pointer
	t59 = &t17.str [#0]                                     *unsafe.Pointer
	t60 = *t59                                               unsafe.Pointer
	t61 = t58 == t60                                                   bool
	if t61 goto 16 else 17
16:                                                             if.then P:2 S:0
	t62 = convert unsafe.Pointer <- *bmap (t26)              unsafe.Pointer
	t63 = *t0                                                      *maptype
	t64 = &t63.valuesize [#7]                                        *uint8
	t65 = *t64                                                        uint8
	t66 = convert uintptr <- uint8 (t65)                            uintptr
	t67 = t41 * t66                                                 uintptr
	t68 = 136:uintptr + t67                                         uintptr
	t69 = add(t62, t68)                                      unsafe.Pointer
	return t69
17:                                                          cond.false P:1 S:2
	t70 = &t51.str [#0]                                     *unsafe.Pointer
	t71 = *t70                                               unsafe.Pointer
	t72 = &t17.str [#0]                                     *unsafe.Pointer
	t73 = *t72                                               unsafe.Pointer
	t74 = &t17.len [#1]                                                *int
	t75 = *t74                                                          int
	t76 = convert uintptr <- int (t75)                              uintptr
	t77 = memeq(t71, t73, t76)                                         bool
	if t77 goto 16 else 13
18:                                                            for.body P:1 S:2
	t78 = convert unsafe.Pointer <- *bmap (t26)              unsafe.Pointer
	t79 = add(t78, t85)                                      unsafe.Pointer
	t80 = convert *uint8 <- unsafe.Pointer (t79)                     *uint8
	t81 = *t80                                                        uint8
	t82 = t81 == 0:uint8                                               bool
	if t82 goto 21 else 22
19:                                                            for.done P:1 S:2
	t83 = t84 != 8:uintptr                                             bool
	if t83 goto 30 else 31
20:                                                            for.loop P:2 S:2
	t84 = phi [9: 8:uintptr, 21: t88] #keymaybe                     uintptr
	t85 = phi [9: 0:uintptr, 21: t90] #i                            uintptr
	t86 = phi [9: nil:*stringStruct, 21: t89] #k              *stringStruct
	t87 = t85 < 8:uintptr                                              bool
	if t87 goto 18 else 19
21:                                                            for.post P:5 S:1
	t88 = phi [18: t84, 22: t84, 25: t84, 26: t84, 28: t85] #keymaybe uintptr
	t89 = phi [18: t86, 22: t96, 25: t96, 26: t96, 28: t96] #k *stringStruct
	t90 = t85 + 1:uintptr                                           uintptr
	jump 20
22:                                                             if.done P:1 S:2
	t91 = convert unsafe.Pointer <- *bmap (t26)              unsafe.Pointer
	t92 = t85 * 2:uintptr                                           uintptr
	t93 = t92 * 8:uintptr                                           uintptr
	t94 = 8:uintptr + t93                                           uintptr
	t95 = add(t91, t94)                                      unsafe.Pointer
	t96 = convert *stringStruct <- unsafe.Pointer (t95)       *stringStruct
	t97 = &t96.len [#1]                                                *int
	t98 = *t97                                                          int
	t99 = &t17.len [#1]                                                *int
	t100 = *t99                                                         int
	t101 = t98 != t100                                                 bool
	if t101 goto 21 else 23
23:                                                             if.done P:1 S:2
	t102 = &t96.str [#0]                                    *unsafe.Pointer
	t103 = *t102                                             unsafe.Pointer
	t104 = &t17.str [#0]                                    *unsafe.Pointer
	t105 = *t104                                             unsafe.Pointer
	t106 = t103 == t105                                                bool
	if t106 goto 24 else 25
24:                                                             if.then P:1 S:0
	t107 = convert unsafe.Pointer <- *bmap (t26)             unsafe.Pointer
	t108 = *t0                                                     *maptype
	t109 = &t108.valuesize [#7]                                      *uint8
	t110 = *t109                                                      uint8
	t111 = convert uintptr <- uint8 (t110)                          uintptr
	t112 = t85 * t111                                               uintptr
	t113 = 136:uintptr + t112                                       uintptr
	t114 = add(t107, t113)                                   unsafe.Pointer
	return t114
25:                                                             if.done P:1 S:2
	t115 = &t17.str [#0]                                    *unsafe.Pointer
	t116 = *t115                                             unsafe.Pointer
	t117 = convert *[4]byte <- unsafe.Pointer (t116)               *[4]byte
	t118 = *t117                                                    [4]byte
	t119 = &t96.str [#0]                                    *unsafe.Pointer
	t120 = *t119                                             unsafe.Pointer
	t121 = convert *[4]byte <- unsafe.Pointer (t120)               *[4]byte
	t122 = *t121                                                    [4]byte
	t123 = t118 != t122                                                bool
	if t123 goto 21 else 26
26:                                                             if.done P:1 S:2
	t124 = &t17.str [#0]                                    *unsafe.Pointer
	t125 = *t124                                             unsafe.Pointer
	t126 = &t17.len [#1]                                               *int
	t127 = *t126                                                        int
	t128 = convert uintptr <- int (t127)                            uintptr
	t129 = t128 - 4:uintptr                                         uintptr
	t130 = add(t125, t129)                                   unsafe.Pointer
	t131 = convert *[4]byte <- unsafe.Pointer (t130)               *[4]byte
	t132 = *t131                                                    [4]byte
	t133 = &t96.str [#0]                                    *unsafe.Pointer
	t134 = *t133                                             unsafe.Pointer
	t135 = &t17.len [#1]                                               *int
	t136 = *t135                                                        int
	t137 = convert uintptr <- int (t136)                            uintptr
	t138 = t137 - 4:uintptr                                         uintptr
	t139 = add(t134, t138)                                   unsafe.Pointer
	t140 = convert *[4]byte <- unsafe.Pointer (t139)               *[4]byte
	t141 = *t140                                                    [4]byte
	t142 = t132 != t141                                                bool
	if t142 goto 21 else 27
27:                                                             if.done P:1 S:2
	t143 = t84 != 8:uintptr                                            bool
	if t143 goto 29 else 28
28:                                                             if.done P:1 S:1
	jump 21
29:                                                              dohash P:2 S:2
	t144 = *t0                                                     *maptype
	t145 = &t144.key [#1]                                           **_type
	t146 = *t145                                                     *_type
	t147 = &t146.alg [#6]                                   *unsafe.Pointer
	t148 = *t147                                             unsafe.Pointer
	t149 = goalg(t148)                                             *typeAlg
	t150 = &t149.hash [#0]  *func(unsafe.Pointer, uintptr, uintptr) uintptr
	t151 = *t150             func(unsafe.Pointer, uintptr, uintptr) uintptr
	t152 = convert unsafe.Pointer <- *string (t1)            unsafe.Pointer
	t153 = noescape(t152)                                    unsafe.Pointer
	t154 = &h.hash0 [#2]                                            *uint32
	t155 = *t154                                                     uint32
	t156 = convert uintptr <- uint32 (t155)                         uintptr
	t157 = t151(t153, 16:uintptr, t156)                             uintptr
	t158 = &h.B [#3]                                                 *uint8
	t159 = *t158                                                      uint8
	t160 = 1:uintptr << t159                                        uintptr
	t161 = t160 - 1:uintptr                                         uintptr
	t162 = &h.buckets [#4]                                  *unsafe.Pointer
	t163 = *t162                                             unsafe.Pointer
	t164 = t157 & t161                                              uintptr
	t165 = *t0                                                     *maptype
	t166 = &t165.bucketsize [#9]                                    *uint16
	t167 = *t166                                                     uint16
	t168 = convert uintptr <- uint16 (t167)                         uintptr
	t169 = t164 * t168                                              uintptr
	t170 = add(t163, t169)                                   unsafe.Pointer
	t171 = convert *bmap <- unsafe.Pointer (t170)                     *bmap
	t172 = &h.oldbuckets [#5]                               *unsafe.Pointer
	t173 = *t172                                             unsafe.Pointer
	t174 = t173 != nil:unsafe.Pointer                                  bool
	if t174 goto 33 else 34
30:                                                             if.then P:1 S:2
	t175 = convert unsafe.Pointer <- *bmap (t26)             unsafe.Pointer
	t176 = t84 * 2:uintptr                                          uintptr
	t177 = t176 * 8:uintptr                                         uintptr
	t178 = 8:uintptr + t177                                         uintptr
	t179 = add(t175, t178)                                   unsafe.Pointer
	t180 = convert *stringStruct <- unsafe.Pointer (t179)     *stringStruct
	t181 = &t180.str [#0]                                   *unsafe.Pointer
	t182 = *t181                                             unsafe.Pointer
	t183 = &t17.str [#0]                                    *unsafe.Pointer
	t184 = *t183                                             unsafe.Pointer
	t185 = &t17.len [#1]                                               *int
	t186 = *t185                                                        int
	t187 = convert uintptr <- int (t186)                            uintptr
	t188 = memeq(t182, t184, t187)                                     bool
	if t188 goto 32 else 31
31:                                                             if.done P:2 S:0
	t189 = *t0                                                     *maptype
	t190 = &t189.elem [#2]                                          **_type
	t191 = *t190                                                     *_type
	t192 = &t191.zero [#11]                                          **byte
	t193 = *t192                                                      *byte
	t194 = convert unsafe.Pointer <- *byte (t193)            unsafe.Pointer
	return t194
32:                                                             if.then P:1 S:0
	t195 = convert unsafe.Pointer <- *bmap (t26)             unsafe.Pointer
	t196 = *t0                                                     *maptype
	t197 = &t196.valuesize [#7]                                      *uint8
	t198 = *t197                                                      uint8
	t199 = convert uintptr <- uint8 (t198)                          uintptr
	t200 = t84 * t199                                               uintptr
	t201 = 136:uintptr + t200                                       uintptr
	t202 = add(t195, t201)                                   unsafe.Pointer
	return t202
33:                                                             if.then P:1 S:2
	t203 = t161 >> 1:uint64                                         uintptr
	t204 = t157 & t203                                              uintptr
	t205 = *t0                                                     *maptype
	t206 = &t205.bucketsize [#9]                                    *uint16
	t207 = *t206                                                     uint16
	t208 = convert uintptr <- uint16 (t207)                         uintptr
	t209 = t204 * t208                                              uintptr
	t210 = add(t173, t209)                                   unsafe.Pointer
	t211 = convert *bmap <- unsafe.Pointer (t210)                     *bmap
	t212 = evacuated(t211)                                             bool
	if t212 goto 34 else 35
34:                                                             if.done P:3 S:2
	t213 = phi [29: t171, 33: t171, 35: t211] #b                      *bmap
	t214 = t157 >> 56:uint64                                        uintptr
	t215 = convert uint8 <- uintptr (t214)                            uint8
	t216 = t215 < 4:uint8                                              bool
	if t216 goto 36 else 37
35:                                                             if.then P:1 S:1
	jump 34
36:                                                             if.then P:1 S:1
	t217 = t215 + 4:uint8                                             uint8
	jump 37
37:                                                            for.body P:3 S:1
	t218 = phi [34: t213, 39: t228, 36: t213] #b                      *bmap
	t219 = phi [34: t215, 39: t219, 36: t217] #top                    uint8
	t220 = phi [34: 0:uint8, 39: t231, 36: 0:uint8] #x                uint8
	t221 = phi [34: nil:*stringStruct, 39: t232, 36: nil:*stringStruct] #k *stringStruct
	jump 40
38:                                                            for.body P:1 S:2
	t222 = convert unsafe.Pointer <- *bmap (t218)            unsafe.Pointer
	t223 = add(t222, t230)                                   unsafe.Pointer
	t224 = convert *uint8 <- unsafe.Pointer (t223)                   *uint8
	t225 = *t224                                                      uint8
	t226 = t225 != t219                                                bool
	if t226 goto 41 else 42
39:                                                            for.done P:1 S:2
	t227 = *t0                                                     *maptype
	t228 = (*bmap).overflow(t218, t227)                               *bmap
	t229 = t228 == nil:*bmap                                           bool
	if t229 goto 46 else 37
40:                                                            for.loop P:2 S:2
	t230 = phi [37: 0:uintptr, 41: t235] #i                         uintptr
	t231 = phi [37: t220, 41: t225] #x                                uint8
	t232 = phi [37: t221, 41: t234] #k                        *stringStruct
	t233 = t230 < 8:uintptr                                            bool
	if t233 goto 38 else 39
41:                                                            for.post P:3 S:1
	t234 = phi [38: t232, 42: t241, 45: t241] #k              *stringStruct
	t235 = t230 + 1:uintptr                                         uintptr
	jump 40
42:                                                             if.done P:1 S:2
	t236 = convert unsafe.Pointer <- *bmap (t218)            unsafe.Pointer
	t237 = t230 * 2:uintptr                                         uintptr
	t238 = t237 * 8:uintptr                                         uintptr
	t239 = 8:uintptr + t238                                         uintptr
	t240 = add(t236, t239)                                   unsafe.Pointer
	t241 = convert *stringStruct <- unsafe.Pointer (t240)     *stringStruct
	t242 = &t241.len [#1]                                              *int
	t243 = *t242                                                        int
	t244 = &t17.len [#1]                                               *int
	t245 = *t244                                                        int
	t246 = t243 != t245                                                bool
	if t246 goto 41 else 43
43:                                                             if.done P:1 S:2
	t247 = &t241.str [#0]                                   *unsafe.Pointer
	t248 = *t247                                             unsafe.Pointer
	t249 = &t17.str [#0]                                    *unsafe.Pointer
	t250 = *t249                                             unsafe.Pointer
	t251 = t248 == t250                                                bool
	if t251 goto 44 else 45
44:                                                             if.then P:2 S:0
	t252 = convert unsafe.Pointer <- *bmap (t218)            unsafe.Pointer
	t253 = *t0                                                     *maptype
	t254 = &t253.valuesize [#7]                                      *uint8
	t255 = *t254                                                      uint8
	t256 = convert uintptr <- uint8 (t255)                          uintptr
	t257 = t230 * t256                                              uintptr
	t258 = 136:uintptr + t257                                       uintptr
	t259 = add(t252, t258)                                   unsafe.Pointer
	return t259
45:                                                          cond.false P:1 S:2
	t260 = &t241.str [#0]                                   *unsafe.Pointer
	t261 = *t260                                             unsafe.Pointer
	t262 = &t17.str [#0]                                    *unsafe.Pointer
	t263 = *t262                                             unsafe.Pointer
	t264 = &t17.len [#1]                                               *int
	t265 = *t264                                                        int
	t266 = convert uintptr <- int (t265)                            uintptr
	t267 = memeq(t261, t263, t266)                                     bool
	if t267 goto 44 else 41
46:                                                             if.then P:1 S:0
	t268 = *t0                                                     *maptype
	t269 = &t268.elem [#2]                                          **_type
	t270 = *t269                                                     *_type
	t271 = &t270.zero [#11]                                          **byte
	t272 = *t271                                                      *byte
	t273 = convert unsafe.Pointer <- *byte (t272)            unsafe.Pointer
	return t273

# Name: runtime.mapaccess2_faststr
# Package: runtime
# Location: /usr/local/go/src/runtime/hashmap_fast.go:281:6
func mapaccess2_faststr(t *maptype, h *hmap, ky string) (unsafe.Pointer, bool):
0:                                                                entry P:0 S:2
	t0 = new *maptype (t)                                         **maptype
	*t0 = t
	t1 = new string (ky)                                            *string
	*t1 = ky
	if false:untyped bool goto 3 else 2
1:                                                              if.then P:1 S:1
	t2 = convert unsafe.Pointer <- **maptype (t0)            unsafe.Pointer
	t3 = getcallerpc(t2)                                            uintptr
	t4 = convert unsafe.Pointer <- *hmap (h)                 unsafe.Pointer
	t5 = make interface{} <- func(t *maptype, h *hmap, ky string) (unsafe.Pointer, bool) (mapaccess2_faststr) interface{}
	t6 = funcPC(t5)                                                 uintptr
	t7 = racereadpc(t4, t3, t6)                                          ()
	jump 2
2:                                                              if.done P:3 S:2
	t8 = h == nil:*hmap                                                bool
	if t8 goto 4 else 6
3:                                                            cond.true P:1 S:2
	t9 = h != nil:*hmap                                                bool
	if t9 goto 1 else 2
4:                                                              if.then P:2 S:0
	t10 = *t0                                                      *maptype
	t11 = &t10.elem [#2]                                            **_type
	t12 = *t11                                                       *_type
	t13 = &t12.zero [#11]                                            **byte
	t14 = *t13                                                        *byte
	t15 = convert unsafe.Pointer <- *byte (t14)              unsafe.Pointer
	return t15, false:bool
5:                                                              if.done P:1 S:2
	t16 = convert unsafe.Pointer <- *string (t1)             unsafe.Pointer
	t17 = convert *stringStruct <- unsafe.Pointer (t16)       *stringStruct
	t18 = &h.B [#3]                                                  *uint8
	t19 = *t18                                                        uint8
	t20 = t19 == 0:uint8                                               bool
	if t20 goto 7 else 29
6:                                                           cond.false P:1 S:2
	t21 = &h.count [#0]                                                *int
	t22 = *t21                                                          int
	t23 = t22 == 0:int                                                 bool
	if t23 goto 4 else 5
7:                                                              if.then P:1 S:2
	t24 = &h.buckets [#4]                                   *unsafe.Pointer
	t25 = *t24                                               unsafe.Pointer
	t26 = convert *bmap <- unsafe.Pointer (t25)                       *bmap
	t27 = &t17.len [#1]                                                *int
	t28 = *t27                                                          int
	t29 = t28 < 32:int                                                 bool
	if t29 goto 8 else 9
8:                                                              if.then P:1 S:1
	jump 12
9:                                                              if.done P:1 S:1
	jump 20
10:                                                            for.body P:1 S:2
	t30 = convert unsafe.Pointer <- *bmap (t26)              unsafe.Pointer
	t31 = add(t30, t41)                                      unsafe.Pointer
	t32 = convert *uint8 <- unsafe.Pointer (t31)                     *uint8
	t33 = *t32                                                        uint8
	t34 = t33 == 0:uint8                                               bool
	if t34 goto 13 else 14
11:                                                            for.done P:1 S:0
	t35 = *t0                                                      *maptype
	t36 = &t35.elem [#2]                                            **_type
	t37 = *t36                                                       *_type
	t38 = &t37.zero [#11]                                            **byte
	t39 = *t38                                                        *byte
	t40 = convert unsafe.Pointer <- *byte (t39)              unsafe.Pointer
	return t40, false:bool
12:                                                            for.loop P:2 S:2
	t41 = phi [8: 0:uintptr, 13: t45] #i                            uintptr
	t42 = phi [8: nil:*stringStruct, 13: t44] #k              *stringStruct
	t43 = t41 < 8:uintptr                                              bool
	if t43 goto 10 else 11
13:                                                            for.post P:3 S:1
	t44 = phi [10: t42, 14: t51, 17: t51] #k                  *stringStruct
	t45 = t41 + 1:uintptr                                           uintptr
	jump 12
14:                                                             if.done P:1 S:2
	t46 = convert unsafe.Pointer <- *bmap (t26)              unsafe.Pointer
	t47 = t41 * 2:uintptr                                           uintptr
	t48 = t47 * 8:uintptr                                           uintptr
	t49 = 8:uintptr + t48                                           uintptr
	t50 = add(t46, t49)                                      unsafe.Pointer
	t51 = convert *stringStruct <- unsafe.Pointer (t50)       *stringStruct
	t52 = &t51.len [#1]                                                *int
	t53 = *t52                                                          int
	t54 = &t17.len [#1]                                                *int
	t55 = *t54                                                          int
	t56 = t53 != t55                                                   bool
	if t56 goto 13 else 15
15:                                                             if.done P:1 S:2
	t57 = &t51.str [#0]                                     *unsafe.Pointer
	t58 = *t57                                               unsafe.Pointer
	t59 = &t17.str [#0]                                     *unsafe.Pointer
	t60 = *t59                                               unsafe.Pointer
	t61 = t58 == t60                                                   bool
	if t61 goto 16 else 17
16:                                                             if.then P:2 S:0
	t62 = convert unsafe.Pointer <- *bmap (t26)              unsafe.Pointer
	t63 = *t0                                                      *maptype
	t64 = &t63.valuesize [#7]                                        *uint8
	t65 = *t64                                                        uint8
	t66 = convert uintptr <- uint8 (t65)                            uintptr
	t67 = t41 * t66                                                 uintptr
	t68 = 136:uintptr + t67                                         uintptr
	t69 = add(t62, t68)                                      unsafe.Pointer
	return t69, true:bool
17:                                                          cond.false P:1 S:2
	t70 = &t51.str [#0]                                     *unsafe.Pointer
	t71 = *t70                                               unsafe.Pointer
	t72 = &t17.str [#0]                                     *unsafe.Pointer
	t73 = *t72                                               unsafe.Pointer
	t74 = &t17.len [#1]                                                *int
	t75 = *t74                                                          int
	t76 = convert uintptr <- int (t75)                              uintptr
	t77 = memeq(t71, t73, t76)                                         bool
	if t77 goto 16 else 13
18:                                                            for.body P:1 S:2
	t78 = convert unsafe.Pointer <- *bmap (t26)              unsafe.Pointer
	t79 = add(t78, t85)                                      unsafe.Pointer
	t80 = convert *uint8 <- unsafe.Pointer (t79)                     *uint8
	t81 = *t80                                                        uint8
	t82 = t81 == 0:uint8                                               bool
	if t82 goto 21 else 22
19:                                                            for.done P:1 S:2
	t83 = t84 != 8:uintptr                                             bool
	if t83 goto 30 else 31
20:                                                            for.loop P:2 S:2
	t84 = phi [9: 8:uintptr, 21: t88] #keymaybe                     uintptr
	t85 = phi [9: 0:uintptr, 21: t90] #i                            uintptr
	t86 = phi [9: nil:*stringStruct, 21: t89] #k              *stringStruct
	t87 = t85 < 8:uintptr                                              bool
	if t87 goto 18 else 19
21:                                                            for.post P:5 S:1
	t88 = phi [18: t84, 22: t84, 25: t84, 26: t84, 28: t85] #keymaybe uintptr
	t89 = phi [18: t86, 22: t96, 25: t96, 26: t96, 28: t96] #k *stringStruct
	t90 = t85 + 1:uintptr                                           uintptr
	jump 20
22:                                                             if.done P:1 S:2
	t91 = convert unsafe.Pointer <- *bmap (t26)              unsafe.Pointer
	t92 = t85 * 2:uintptr                                           uintptr
	t93 = t92 * 8:uintptr                                           uintptr
	t94 = 8:uintptr + t93                                           uintptr
	t95 = add(t91, t94)                                      unsafe.Pointer
	t96 = convert *stringStruct <- unsafe.Pointer (t95)       *stringStruct
	t97 = &t96.len [#1]                                                *int
	t98 = *t97                                                          int
	t99 = &t17.len [#1]                                                *int
	t100 = *t99                                                         int
	t101 = t98 != t100                                                 bool
	if t101 goto 21 else 23
23:                                                             if.done P:1 S:2
	t102 = &t96.str [#0]                                    *unsafe.Pointer
	t103 = *t102                                             unsafe.Pointer
	t104 = &t17.str [#0]                                    *unsafe.Pointer
	t105 = *t104                                             unsafe.Pointer
	t106 = t103 == t105                                                bool
	if t106 goto 24 else 25
24:                                                             if.then P:1 S:0
	t107 = convert unsafe.Pointer <- *bmap (t26)             unsafe.Pointer
	t108 = *t0                                                     *maptype
	t109 = &t108.valuesize [#7]                                      *uint8
	t110 = *t109                                                      uint8
	t111 = convert uintptr <- uint8 (t110)                          uintptr
	t112 = t85 * t111                                               uintptr
	t113 = 136:uintptr + t112                                       uintptr
	t114 = add(t107, t113)                                   unsafe.Pointer
	return t114, true:bool
25:                                                             if.done P:1 S:2
	t115 = &t17.str [#0]                                    *unsafe.Pointer
	t116 = *t115                                             unsafe.Pointer
	t117 = convert *[4]byte <- unsafe.Pointer (t116)               *[4]byte
	t118 = *t117                                                    [4]byte
	t119 = &t96.str [#0]                                    *unsafe.Pointer
	t120 = *t119                                             unsafe.Pointer
	t121 = convert *[4]byte <- unsafe.Pointer (t120)               *[4]byte
	t122 = *t121                                                    [4]byte
	t123 = t118 != t122                                                bool
	if t123 goto 21 else 26
26:                                                             if.done P:1 S:2
	t124 = &t17.str [#0]                                    *unsafe.Pointer
	t125 = *t124                                             unsafe.Pointer
	t126 = &t17.len [#1]                                               *int
	t127 = *t126                                                        int
	t128 = convert uintptr <- int (t127)                            uintptr
	t129 = t128 - 4:uintptr                                         uintptr
	t130 = add(t125, t129)                                   unsafe.Pointer
	t131 = convert *[4]byte <- unsafe.Pointer (t130)               *[4]byte
	t132 = *t131                                                    [4]byte
	t133 = &t96.str [#0]                                    *unsafe.Pointer
	t134 = *t133                                             unsafe.Pointer
	t135 = &t17.len [#1]                                               *int
	t136 = *t135                                                        int
	t137 = convert uintptr <- int (t136)                            uintptr
	t138 = t137 - 4:uintptr                                         uintptr
	t139 = add(t134, t138)                                   unsafe.Pointer
	t140 = convert *[4]byte <- unsafe.Pointer (t139)               *[4]byte
	t141 = *t140                                                    [4]byte
	t142 = t132 != t141                                                bool
	if t142 goto 21 else 27
27:                                                             if.done P:1 S:2
	t143 = t84 != 8:uintptr                                            bool
	if t143 goto 29 else 28
28:                                                             if.done P:1 S:1
	jump 21
29:                                                              dohash P:2 S:2
	t144 = *t0                                                     *maptype
	t145 = &t144.key [#1]                                           **_type
	t146 = *t145                                                     *_type
	t147 = &t146.alg [#6]                                   *unsafe.Pointer
	t148 = *t147                                             unsafe.Pointer
	t149 = goalg(t148)                                             *typeAlg
	t150 = &t149.hash [#0]  *func(unsafe.Pointer, uintptr, uintptr) uintptr
	t151 = *t150             func(unsafe.Pointer, uintptr, uintptr) uintptr
	t152 = convert unsafe.Pointer <- *string (t1)            unsafe.Pointer
	t153 = noescape(t152)                                    unsafe.Pointer
	t154 = &h.hash0 [#2]                                            *uint32
	t155 = *t154                                                     uint32
	t156 = convert uintptr <- uint32 (t155)                         uintptr
	t157 = t151(t153, 16:uintptr, t156)                             uintptr
	t158 = &h.B [#3]                                                 *uint8
	t159 = *t158                                                      uint8
	t160 = 1:uintptr << t159                                        uintptr
	t161 = t160 - 1:uintptr                                         uintptr
	t162 = &h.buckets [#4]                                  *unsafe.Pointer
	t163 = *t162                                             unsafe.Pointer
	t164 = t157 & t161                                              uintptr
	t165 = *t0                                                     *maptype
	t166 = &t165.bucketsize [#9]                                    *uint16
	t167 = *t166                                                     uint16
	t168 = convert uintptr <- uint16 (t167)                         uintptr
	t169 = t164 * t168                                              uintptr
	t170 = add(t163, t169)                                   unsafe.Pointer
	t171 = convert *bmap <- unsafe.Pointer (t170)                     *bmap
	t172 = &h.oldbuckets [#5]                               *unsafe.Pointer
	t173 = *t172                                             unsafe.Pointer
	t174 = t173 != nil:unsafe.Pointer                                  bool
	if t174 goto 33 else 34
30:                                                             if.then P:1 S:2
	t175 = convert unsafe.Pointer <- *bmap (t26)             unsafe.Pointer
	t176 = t84 * 2:uintptr                                          uintptr
	t177 = t176 * 8:uintptr                                         uintptr
	t178 = 8:uintptr + t177                                         uintptr
	t179 = add(t175, t178)                                   unsafe.Pointer
	t180 = convert *stringStruct <- unsafe.Pointer (t179)     *stringStruct
	t181 = &t180.str [#0]                                   *unsafe.Pointer
	t182 = *t181                                             unsafe.Pointer
	t183 = &t17.str [#0]                                    *unsafe.Pointer
	t184 = *t183                                             unsafe.Pointer
	t185 = &t17.len [#1]                                               *int
	t186 = *t185                                                        int
	t187 = convert uintptr <- int (t186)                            uintptr
	t188 = memeq(t182, t184, t187)                                     bool
	if t188 goto 32 else 31
31:                                                             if.done P:2 S:0
	t189 = *t0                                                     *maptype
	t190 = &t189.elem [#2]                                          **_type
	t191 = *t190                                                     *_type
	t192 = &t191.zero [#11]                                          **byte
	t193 = *t192                                                      *byte
	t194 = convert unsafe.Pointer <- *byte (t193)            unsafe.Pointer
	return t194, false:bool
32:                                                             if.then P:1 S:0
	t195 = convert unsafe.Pointer <- *bmap (t26)             unsafe.Pointer
	t196 = *t0                                                     *maptype
	t197 = &t196.valuesize [#7]                                      *uint8
	t198 = *t197                                                      uint8
	t199 = convert uintptr <- uint8 (t198)                          uintptr
	t200 = t84 * t199                                               uintptr
	t201 = 136:uintptr + t200                                       uintptr
	t202 = add(t195, t201)                                   unsafe.Pointer
	return t202, true:bool
33:                                                             if.then P:1 S:2
	t203 = t161 >> 1:uint64                                         uintptr
	t204 = t157 & t203                                              uintptr
	t205 = *t0                                                     *maptype
	t206 = &t205.bucketsize [#9]                                    *uint16
	t207 = *t206                                                     uint16
	t208 = convert uintptr <- uint16 (t207)                         uintptr
	t209 = t204 * t208                                              uintptr
	t210 = add(t173, t209)                                   unsafe.Pointer
	t211 = convert *bmap <- unsafe.Pointer (t210)                     *bmap
	t212 = evacuated(t211)                                             bool
	if t212 goto 34 else 35
34:                                                             if.done P:3 S:2
	t213 = phi [29: t171, 33: t171, 35: t211] #b                      *bmap
	t214 = t157 >> 56:uint64                                        uintptr
	t215 = convert uint8 <- uintptr (t214)                            uint8
	t216 = t215 < 4:uint8                                              bool
	if t216 goto 36 else 37
35:                                                             if.then P:1 S:1
	jump 34
36:                                                             if.then P:1 S:1
	t217 = t215 + 4:uint8                                             uint8
	jump 37
37:                                                            for.body P:3 S:1
	t218 = phi [34: t213, 39: t228, 36: t213] #b                      *bmap
	t219 = phi [34: t215, 39: t219, 36: t217] #top                    uint8
	t220 = phi [34: 0:uint8, 39: t231, 36: 0:uint8] #x                uint8
	t221 = phi [34: nil:*stringStruct, 39: t232, 36: nil:*stringStruct] #k *stringStruct
	jump 40
38:                                                            for.body P:1 S:2
	t222 = convert unsafe.Pointer <- *bmap (t218)            unsafe.Pointer
	t223 = add(t222, t230)                                   unsafe.Pointer
	t224 = convert *uint8 <- unsafe.Pointer (t223)                   *uint8
	t225 = *t224                                                      uint8
	t226 = t225 != t219                                                bool
	if t226 goto 41 else 42
39:                                                            for.done P:1 S:2
	t227 = *t0                                                     *maptype
	t228 = (*bmap).overflow(t218, t227)                               *bmap
	t229 = t228 == nil:*bmap                                           bool
	if t229 goto 46 else 37
40:                                                            for.loop P:2 S:2
	t230 = phi [37: 0:uintptr, 41: t235] #i                         uintptr
	t231 = phi [37: t220, 41: t225] #x                                uint8
	t232 = phi [37: t221, 41: t234] #k                        *stringStruct
	t233 = t230 < 8:uintptr                                            bool
	if t233 goto 38 else 39
41:                                                            for.post P:3 S:1
	t234 = phi [38: t232, 42: t241, 45: t241] #k              *stringStruct
	t235 = t230 + 1:uintptr                                         uintptr
	jump 40
42:                                                             if.done P:1 S:2
	t236 = convert unsafe.Pointer <- *bmap (t218)            unsafe.Pointer
	t237 = t230 * 2:uintptr                                         uintptr
	t238 = t237 * 8:uintptr                                         uintptr
	t239 = 8:uintptr + t238                                         uintptr
	t240 = add(t236, t239)                                   unsafe.Pointer
	t241 = convert *stringStruct <- unsafe.Pointer (t240)     *stringStruct
	t242 = &t241.len [#1]                                              *int
	t243 = *t242                                                        int
	t244 = &t17.len [#1]                                               *int
	t245 = *t244                                                        int
	t246 = t243 != t245                                                bool
	if t246 goto 41 else 43
43:                                                             if.done P:1 S:2
	t247 = &t241.str [#0]                                   *unsafe.Pointer
	t248 = *t247                                             unsafe.Pointer
	t249 = &t17.str [#0]                                    *unsafe.Pointer
	t250 = *t249                                             unsafe.Pointer
	t251 = t248 == t250                                                bool
	if t251 goto 44 else 45
44:                                                             if.then P:2 S:0
	t252 = convert unsafe.Pointer <- *bmap (t218)            unsafe.Pointer
	t253 = *t0                                                     *maptype
	t254 = &t253.valuesize [#7]                                      *uint8
	t255 = *t254                                                      uint8
	t256 = convert uintptr <- uint8 (t255)                          uintptr
	t257 = t230 * t256                                              uintptr
	t258 = 136:uintptr + t257                                       uintptr
	t259 = add(t252, t258)                                   unsafe.Pointer
	return t259, true:bool
45:                                                          cond.false P:1 S:2
	t260 = &t241.str [#0]                                   *unsafe.Pointer
	t261 = *t260                                             unsafe.Pointer
	t262 = &t17.str [#0]                                    *unsafe.Pointer
	t263 = *t262                                             unsafe.Pointer
	t264 = &t17.len [#1]                                               *int
	t265 = *t264                                                        int
	t266 = convert uintptr <- int (t265)                            uintptr
	t267 = memeq(t261, t263, t266)                                     bool
	if t267 goto 44 else 41
46:                                                             if.then P:1 S:0
	t268 = *t0                                                     *maptype
	t269 = &t268.elem [#2]                                          **_type
	t270 = *t269                                                     *_type
	t271 = &t270.zero [#11]                                          **byte
	t272 = *t271                                                      *byte
	t273 = convert unsafe.Pointer <- *byte (t272)            unsafe.Pointer
	return t273, false:bool

# Name: runtime.getitab
# Package: runtime
# Location: /usr/local/go/src/runtime/iface.go:27:6
func getitab(inter *interfacetype, typ *_type, canfail bool) *itab:
0:                                                                entry P:0 S:2
	t0 = &inter.mhdr [#1]                                           *[]byte
	t1 = *t0                                                         []byte
	t2 = len(t1)                                                        int
	t3 = t2 == 0:int                                                   bool
	if t3 goto 1 else 2
1:                                                              if.then P:1 S:1
	t4 = gothrow("internal error - ...":string)                          ()
	jump 2
2:                                                              if.done P:2 S:2
	t5 = &typ.x [#9]                                         **uncommontype
	t6 = *t5                                                  *uncommontype
	t7 = t6 == nil:*uncommontype                                       bool
	if t7 goto 3 else 4
3:                                                              if.then P:1 S:2
	if canfail goto 5 else 6
4:                                                              if.done P:1 S:1
	t8 = &inter.typ [#0]                                             *_type
	t9 = &t8.hash [#1]                                              *uint32
	t10 = *t9                                                        uint32
	t11 = &typ.hash [#1]                                            *uint32
	t12 = *t11                                                       uint32
	t13 = 17:uint32 * t12                                            uint32
	t14 = t10 + t13                                                  uint32
	t15 = t14 % 1009:uint32                                          uint32
	jump 9
5:                                                              if.then P:1 S:0
	return nil:*itab
6:                                                              if.done P:1 S:0
	t16 = convert unsafe.Pointer <- *interfacetype (inter)   unsafe.Pointer
	t17 = add(t16, 96:uintptr)                               unsafe.Pointer
	t18 = convert *imethod <- unsafe.Pointer (t17)                 *imethod
	t19 = new TypeAssertionError (complit)              *TypeAssertionError
	t20 = &t19.interfaceString [#0]                                 *string
	t21 = &t19.concreteString [#1]                                  *string
	t22 = &typ._string [#8]                                        **string
	t23 = *t22                                                      *string
	t24 = *t23                                                       string
	t25 = &t19.assertedString [#2]                                  *string
	t26 = &inter.typ [#0]                                            *_type
	t27 = &t26._string [#8]                                        **string
	t28 = *t27                                                      *string
	t29 = *t28                                                       string
	t30 = &t19.missingMethod [#3]                                   *string
	t31 = &t18.name [#0]                                           **string
	t32 = *t31                                                      *string
	t33 = *t32                                                       string
	*t20 = "":string
	*t21 = t24
	*t25 = t29
	*t30 = t33
	t34 = make interface{} <- *TypeAssertionError (t19)         interface{}
	panic t34
7:                                                             for.body P:1 S:2
	t35 = t47 != 0:int                                                 bool
	if t35 goto 10 else 11
8:                                                             for.done P:1 S:1
	t36 = &inter.mhdr [#1]                                          *[]byte
	t37 = *t36                                                       []byte
	t38 = len(t37)                                                      int
	t39 = convert uintptr <- int (t38)                              uintptr
	t40 = t39 * 8:uintptr                                           uintptr
	t41 = 32:uintptr + t40                                          uintptr
	t42 = &memstats.other_sys [#20]                                 *uint64
	t43 = persistentalloc(t41, 0:uintptr, t42)               unsafe.Pointer
	t44 = convert *itab <- unsafe.Pointer (t43)                       *itab
	t45 = &t44.inter [#0]                                   **interfacetype
	*t45 = inter
	t46 = &t44._type [#1]                                           **_type
	*t46 = typ
	jump 20
9:                                                             for.loop P:2 S:2
	t47 = phi [4: 0:int, 13: t58] #locked                               int
	t48 = t47 < 2:int                                                  bool
	if t48 goto 7 else 8
10:                                                             if.then P:1 S:1
	t49 = lock(ifaceLock)                                                ()
	jump 11
11:                                                             if.done P:2 S:1
	t50 = convert int <- uint32 (t15)                                   int
	t51 = &hash[t50]                                                 **itab
	t52 = convert unsafe.Pointer <- **itab (t51)             unsafe.Pointer
	t53 = atomicloadp(t52)                                   unsafe.Pointer
	t54 = convert *itab <- unsafe.Pointer (t53)                       *itab
	jump 14
12:                                                            for.body P:1 S:2
	t55 = &t59.inter [#0]                                   **interfacetype
	t56 = *t55                                               *interfacetype
	t57 = t56 == inter                                                 bool
	if t57 goto 17 else 16
13:                                                            for.done P:1 S:1
	t58 = t47 + 1:int                                                   int
	jump 9
14:                                                            for.loop P:2 S:2
	t59 = phi [11: t54, 16: t65] #m                                   *itab
	t60 = t59 != nil:*itab                                             bool
	if t60 goto 12 else 13
15:                                                             if.then P:1 S:2
	t61 = &t59.bad [#3]                                              *int32
	t62 = *t61                                                        int32
	t63 = t62 != 0:int32                                               bool
	if t63 goto 18 else 19
16:                                                             if.done P:2 S:1
	t64 = &t59.link [#2]                                             **itab
	t65 = *t64                                                        *itab
	jump 14
17:                                                           cond.true P:1 S:2
	t66 = &t59._type [#1]                                           **_type
	t67 = *t66                                                       *_type
	t68 = t67 == typ                                                   bool
	if t68 goto 15 else 16
18:                                                             if.then P:1 S:2
	if canfail goto 19 else 20
19:                                                             if.done P:2 S:2
	t69 = phi [15: t59, 18: nil:*itab] #m                             *itab
	t70 = t47 != 0:int                                                 bool
	if t70 goto 21 else 22
20:                                                              search P:2 S:1
	t71 = phi [18: nil:*itab, 8: t44] #m                              *itab
	t72 = &inter.mhdr [#1]                                          *[]byte
	t73 = *t72                                                       []byte
	t74 = len(t73)                                                      int
	t75 = &t6.mhdr [#2]                                             *[]byte
	t76 = *t75                                                       []byte
	t77 = len(t76)                                                      int
	jump 25
21:                                                             if.then P:1 S:1
	t78 = unlock(ifaceLock)                                              ()
	jump 22
22:                                                             if.done P:2 S:0
	return t69
23:                                                            for.body P:1 S:1
	t79 = convert unsafe.Pointer <- *interfacetype (inter)   unsafe.Pointer
	t80 = convert uintptr <- int (t93)                              uintptr
	t81 = t80 * 24:uintptr                                          uintptr
	t82 = 96:uintptr + t81                                          uintptr
	t83 = add(t79, t82)                                      unsafe.Pointer
	t84 = convert *imethod <- unsafe.Pointer (t83)                 *imethod
	t85 = &t84.name [#0]                                           **string
	t86 = *t85                                                      *string
	t87 = &t84.pkgpath [#1]                                        **string
	t88 = *t87                                                      *string
	t89 = &t84._type [#2]                                           **_type
	t90 = *t89                                                       *_type
	jump 29
24:                                                            for.done P:2 S:2
	t91 = t47 == 0:int                                                 bool
	if t91 goto 39 else 40
25:                                                            for.loop P:2 S:2
	t92 = phi [20: 0:int, 26: t106] #j                                  int
	t93 = phi [20: 0:int, 26: t96] #k                                   int
	t94 = phi [20: nil:*method, 26: t102] #t                        *method
	t95 = t93 < t74                                                    bool
	if t95 goto 23 else 24
26:                                                            for.post P:2 S:1
	t96 = t93 + 1:int                                                   int
	jump 25
27:                                                            for.body P:1 S:2
	t97 = convert unsafe.Pointer <- *uncommontype (t6)       unsafe.Pointer
	t98 = convert uintptr <- int (t106)                             uintptr
	t99 = t98 * 48:uintptr                                          uintptr
	t100 = 40:uintptr + t99                                         uintptr
	t101 = add(t97, t100)                                    unsafe.Pointer
	t102 = convert *method <- unsafe.Pointer (t101)                 *method
	t103 = &t102.mtyp [#2]                                          **_type
	t104 = *t103                                                     *_type
	t105 = t104 == t90                                                 bool
	if t105 goto 33 else 31
28:                                                            for.done P:1 S:2
	if canfail goto 36 else 35
29:                                                            for.loop P:2 S:2
	t106 = phi [23: t92, 31: t109] #j                                   int
	t107 = t106 < t77                                                  bool
	if t107 goto 27 else 28
30:                                                             if.then P:1 S:2
	t108 = t71 != nil:*itab                                            bool
	if t108 goto 34 else 26
31:                                                             if.done P:3 S:1
	t109 = t106 + 1:int                                                 int
	jump 29
32:                                                           cond.true P:1 S:2
	t110 = &t102.pkgpath [#1]                                      **string
	t111 = *t110                                                    *string
	t112 = t111 == t88                                                 bool
	if t112 goto 30 else 31
33:                                                           cond.true P:1 S:2
	t113 = &t102.name [#0]                                         **string
	t114 = *t113                                                    *string
	t115 = t114 == t86                                                 bool
	if t115 goto 32 else 31
34:                                                             if.then P:1 S:1
	t116 = convert unsafe.Pointer <- *itab (t71)             unsafe.Pointer
	t117 = convert uintptr <- int (t93)                             uintptr
	t118 = t117 * 8:uintptr                                         uintptr
	t119 = 32:uintptr + t118                                        uintptr
	t120 = add(t116, t119)                                   unsafe.Pointer
	t121 = convert *unsafe.Pointer <- unsafe.Pointer (t120) *unsafe.Pointer
	t122 = &t102.ifn [#4]                                   *unsafe.Pointer
	t123 = *t122                                             unsafe.Pointer
	*t121 = t123
	jump 26
35:                                                             if.then P:1 S:2
	t124 = t47 != 0:int                                                bool
	if t124 goto 37 else 38
36:                                                             if.done P:1 S:1
	t125 = &t71.bad [#3]                                             *int32
	*t125 = 1:int32
	jump 24
37:                                                             if.then P:1 S:1
	t126 = unlock(ifaceLock)                                             ()
	jump 38
38:                                                             if.done P:2 S:0
	t127 = new TypeAssertionError (complit)             *TypeAssertionError
	t128 = &t127.interfaceString [#0]                               *string
	t129 = &t127.concreteString [#1]                                *string
	t130 = &typ._string [#8]                                       **string
	t131 = *t130                                                    *string
	t132 = *t131                                                     string
	t133 = &t127.assertedString [#2]                                *string
	t134 = &inter.typ [#0]                                           *_type
	t135 = &t134._string [#8]                                      **string
	t136 = *t135                                                    *string
	t137 = *t136                                                     string
	t138 = &t127.missingMethod [#3]                                 *string
	t139 = *t86                                                      string
	*t128 = "":string
	*t129 = t132
	*t133 = t137
	*t138 = t139
	t140 = make interface{} <- *TypeAssertionError (t127)       interface{}
	panic t140
39:                                                             if.then P:1 S:1
	t141 = gothrow("invalid itab locking":string)                        ()
	jump 40
40:                                                             if.done P:2 S:2
	t142 = &t71.link [#2]                                            **itab
	t143 = convert int <- uint32 (t15)                                  int
	t144 = &hash[t143]                                               **itab
	t145 = *t144                                                      *itab
	*t142 = t145
	t146 = convert int <- uint32 (t15)                                  int
	t147 = &hash[t146]                                               **itab
	t148 = convert unsafe.Pointer <- **itab (t147)           unsafe.Pointer
	t149 = convert unsafe.Pointer <- *itab (t71)             unsafe.Pointer
	t150 = atomicstorep(t148, t149)                                      ()
	t151 = unlock(ifaceLock)                                             ()
	t152 = &t71.bad [#3]                                             *int32
	t153 = *t152                                                      int32
	t154 = t153 != 0:int32                                             bool
	if t154 goto 41 else 42
41:                                                             if.then P:1 S:0
	return nil:*itab
42:                                                             if.done P:1 S:0
	return t71

# Name: runtime.typ2Itab
# Package: runtime
# Location: /usr/local/go/src/runtime/iface.go:128:6
func typ2Itab(t *_type, inter *interfacetype, cache **itab) *itab:
0:                                                                entry P:0 S:0
	t0 = getitab(inter, t, false:bool)                                *itab
	t1 = convert unsafe.Pointer <- **itab (cache)            unsafe.Pointer
	t2 = convert unsafe.Pointer <- *itab (t0)                unsafe.Pointer
	t3 = atomicstorep(t1, t2)                                            ()
	return t0

# Name: runtime.convT2E
# Package: runtime
# Location: /usr/local/go/src/runtime/iface.go:134:6
func convT2E(t *_type, elem unsafe.Pointer) (e interface{}):
0:                                                                entry P:0 S:2
	t0 = new interface{} (e)                                   *interface{}
	t1 = &t.size [#0]                                              *uintptr
	t2 = *t1                                                        uintptr
	t3 = convert unsafe.Pointer <- *interface{} (t0)         unsafe.Pointer
	t4 = convert *eface <- unsafe.Pointer (t3)                       *eface
	t5 = isDirectIface(t)                                              bool
	if t5 goto 1 else 3
1:                                                              if.then P:1 S:1
	t6 = &t4._type [#0]                                             **_type
	*t6 = t
	t7 = &t4.data [#1]                                      *unsafe.Pointer
	t8 = convert unsafe.Pointer <- *unsafe.Pointer (t7)      unsafe.Pointer
	t9 = memmove(t8, elem, t2)                                           ()
	jump 2
2:                                                              if.done P:2 S:0
	t10 = *t0                                                   interface{}
	return t10
3:                                                              if.else P:1 S:1
	t11 = newobject(t)                                       unsafe.Pointer
	t12 = memmove(t11, elem, t2)                                         ()
	t13 = &t4._type [#0]                                            **_type
	*t13 = t
	t14 = &t4.data [#1]                                     *unsafe.Pointer
	*t14 = t11
	jump 2

# Name: runtime.convT2I
# Package: runtime
# Location: /usr/local/go/src/runtime/iface.go:151:6
func convT2I(t *_type, inter *interfacetype, cache **itab, elem unsafe.Pointer) (i fInterface):
0:                                                                entry P:0 S:2
	t0 = new fInterface (i)                                     *fInterface
	t1 = convert unsafe.Pointer <- **itab (cache)            unsafe.Pointer
	t2 = atomicloadp(t1)                                     unsafe.Pointer
	t3 = convert *itab <- unsafe.Pointer (t2)                         *itab
	t4 = t3 == nil:*itab                                               bool
	if t4 goto 1 else 2
1:                                                              if.then P:1 S:1
	t5 = getitab(inter, t, false:bool)                                *itab
	t6 = convert unsafe.Pointer <- **itab (cache)            unsafe.Pointer
	t7 = convert unsafe.Pointer <- *itab (t5)                unsafe.Pointer
	t8 = atomicstorep(t6, t7)                                            ()
	jump 2
2:                                                              if.done P:2 S:2
	t9 = phi [0: t3, 1: t5] #tab                                      *itab
	t10 = &t.size [#0]                                             *uintptr
	t11 = *t10                                                      uintptr
	t12 = convert unsafe.Pointer <- *fInterface (t0)         unsafe.Pointer
	t13 = convert *iface <- unsafe.Pointer (t12)                     *iface
	t14 = isDirectIface(t)                                             bool
	if t14 goto 3 else 5
3:                                                              if.then P:1 S:1
	t15 = &t13.tab [#0]                                              **itab
	*t15 = t9
	t16 = &t13.data [#1]                                    *unsafe.Pointer
	t17 = convert unsafe.Pointer <- *unsafe.Pointer (t16)    unsafe.Pointer
	t18 = memmove(t17, elem, t11)                                        ()
	jump 4
4:                                                              if.done P:2 S:0
	t19 = *t0                                                    fInterface
	return t19
5:                                                              if.else P:1 S:1
	t20 = newobject(t)                                       unsafe.Pointer
	t21 = memmove(t20, elem, t11)                                        ()
	t22 = &t13.tab [#0]                                              **itab
	*t22 = t9
	t23 = &t13.data [#1]                                    *unsafe.Pointer
	*t23 = t20
	jump 4

# Name: runtime.assertI2T
# Package: runtime
# Location: /usr/local/go/src/runtime/iface.go:174:6
func assertI2T(t *_type, i fInterface) (r struct{}):
0:                                                                entry P:0 S:2
	t0 = new fInterface (i)                                     *fInterface
	*t0 = i
	t1 = new struct{} (r)                                         *struct{}
	t2 = convert unsafe.Pointer <- *fInterface (t0)          unsafe.Pointer
	t3 = convert *iface <- unsafe.Pointer (t2)                       *iface
	t4 = &t3.tab [#0]                                                **itab
	t5 = *t4                                                          *itab
	t6 = t5 == nil:*itab                                               bool
	if t6 goto 1 else 2
1:                                                              if.then P:1 S:0
	t7 = new TypeAssertionError (complit)               *TypeAssertionError
	t8 = &t7.interfaceString [#0]                                   *string
	t9 = &t7.concreteString [#1]                                    *string
	t10 = &t7.assertedString [#2]                                   *string
	t11 = &t._string [#8]                                          **string
	t12 = *t11                                                      *string
	t13 = *t12                                                       string
	t14 = &t7.missingMethod [#3]                                    *string
	*t8 = "":string
	*t9 = "":string
	*t10 = t13
	*t14 = "":string
	t15 = make interface{} <- *TypeAssertionError (t7)          interface{}
	panic t15
2:                                                              if.done P:1 S:2
	t16 = &t5._type [#1]                                            **_type
	t17 = *t16                                                       *_type
	t18 = t17 != t                                                     bool
	if t18 goto 3 else 4
3:                                                              if.then P:1 S:0
	t19 = new TypeAssertionError (complit)              *TypeAssertionError
	t20 = &t19.interfaceString [#0]                                 *string
	t21 = &t5.inter [#0]                                    **interfacetype
	t22 = *t21                                               *interfacetype
	t23 = &t22.typ [#0]                                              *_type
	t24 = &t23._string [#8]                                        **string
	t25 = *t24                                                      *string
	t26 = *t25                                                       string
	t27 = &t19.concreteString [#1]                                  *string
	t28 = &t5._type [#1]                                            **_type
	t29 = *t28                                                       *_type
	t30 = &t29._string [#8]                                        **string
	t31 = *t30                                                      *string
	t32 = *t31                                                       string
	t33 = &t19.assertedString [#2]                                  *string
	t34 = &t._string [#8]                                          **string
	t35 = *t34                                                      *string
	t36 = *t35                                                       string
	t37 = &t19.missingMethod [#3]                                   *string
	*t20 = t26
	*t27 = t32
	*t33 = t36
	*t37 = "":string
	t38 = make interface{} <- *TypeAssertionError (t19)         interface{}
	panic t38
4:                                                              if.done P:1 S:2
	t39 = &t.size [#0]                                             *uintptr
	t40 = *t39                                                      uintptr
	t41 = isDirectIface(t)                                             bool
	if t41 goto 5 else 7
5:                                                              if.then P:1 S:1
	t42 = convert unsafe.Pointer <- *struct{} (t1)           unsafe.Pointer
	t43 = &t3.data [#1]                                     *unsafe.Pointer
	t44 = convert unsafe.Pointer <- *unsafe.Pointer (t43)    unsafe.Pointer
	t45 = memmove(t42, t44, t40)                                         ()
	jump 6
6:                                                              if.done P:2 S:0
	t46 = *t1                                                      struct{}
	return t46
7:                                                              if.else P:1 S:1
	t47 = convert unsafe.Pointer <- *struct{} (t1)           unsafe.Pointer
	t48 = &t3.data [#1]                                     *unsafe.Pointer
	t49 = *t48                                               unsafe.Pointer
	t50 = memmove(t47, t49, t40)                                         ()
	jump 6

# Name: runtime.assertI2T2
# Package: runtime
# Location: /usr/local/go/src/runtime/iface.go:193:6
func assertI2T2(t *_type, i fInterface) (r byte):
0:                                                                entry P:0 S:2
	t0 = new fInterface (i)                                     *fInterface
	*t0 = i
	t1 = new byte (r)                                                 *byte
	t2 = convert unsafe.Pointer <- *fInterface (t0)          unsafe.Pointer
	t3 = convert *iface <- unsafe.Pointer (t2)                       *iface
	t4 = &t.size [#0]                                              *uintptr
	t5 = *t4                                                        uintptr
	t6 = convert unsafe.Pointer <- *byte (t1)                unsafe.Pointer
	t7 = add(t6, t5)                                         unsafe.Pointer
	t8 = convert *bool <- unsafe.Pointer (t7)                         *bool
	t9 = &t3.tab [#0]                                                **itab
	t10 = *t9                                                         *itab
	t11 = t10 == nil:*itab                                             bool
	if t11 goto 1 else 3
1:                                                              if.then P:2 S:0
	*t8 = false:bool
	t12 = convert unsafe.Pointer <- *byte (t1)               unsafe.Pointer
	t13 = memclr(t12, t5)                                                ()
	t14 = *t1                                                          byte
	return t14
2:                                                              if.done P:1 S:2
	*t8 = true:bool
	t15 = isDirectIface(t)                                             bool
	if t15 goto 4 else 6
3:                                                           cond.false P:1 S:2
	t16 = &t10._type [#1]                                           **_type
	t17 = *t16                                                       *_type
	t18 = t17 != t                                                     bool
	if t18 goto 1 else 2
4:                                                              if.then P:1 S:1
	t19 = convert unsafe.Pointer <- *byte (t1)               unsafe.Pointer
	t20 = &t3.data [#1]                                     *unsafe.Pointer
	t21 = convert unsafe.Pointer <- *unsafe.Pointer (t20)    unsafe.Pointer
	t22 = memmove(t19, t21, t5)                                          ()
	jump 5
5:                                                              if.done P:2 S:0
	t23 = *t1                                                          byte
	return t23
6:                                                              if.else P:1 S:1
	t24 = convert unsafe.Pointer <- *byte (t1)               unsafe.Pointer
	t25 = &t3.data [#1]                                     *unsafe.Pointer
	t26 = *t25                                               unsafe.Pointer
	t27 = memmove(t24, t26, t5)                                          ()
	jump 5

# Name: runtime.assertI2TOK
# Package: runtime
# Location: /usr/local/go/src/runtime/iface.go:212:6
func assertI2TOK(t *_type, i fInterface) bool:
0:                                                                entry P:0 S:2
	t0 = new fInterface (i)                                     *fInterface
	*t0 = i
	t1 = convert unsafe.Pointer <- *fInterface (t0)          unsafe.Pointer
	t2 = convert *iface <- unsafe.Pointer (t1)                       *iface
	t3 = &t2.tab [#0]                                                **itab
	t4 = *t3                                                          *itab
	t5 = t4 != nil:*itab                                               bool
	if t5 goto 1 else 2
1:                                                            binop.rhs P:1 S:1
	t6 = &t4._type [#1]                                             **_type
	t7 = *t6                                                         *_type
	t8 = t7 == t                                                       bool
	jump 2
2:                                                           binop.done P:2 S:0
	t9 = phi [0: false:bool, 1: t8] #&&                                bool
	return t9

# Name: runtime.assertE2T
# Package: runtime
# Location: /usr/local/go/src/runtime/iface.go:219:6
func assertE2T(t *_type, e interface{}) (r struct{}):
0:                                                                entry P:0 S:2
	t0 = new interface{} (e)                                   *interface{}
	*t0 = e
	t1 = new struct{} (r)                                         *struct{}
	t2 = convert unsafe.Pointer <- *interface{} (t0)         unsafe.Pointer
	t3 = convert *eface <- unsafe.Pointer (t2)                       *eface
	t4 = &t3._type [#0]                                             **_type
	t5 = *t4                                                         *_type
	t6 = t5 == nil:*_type                                              bool
	if t6 goto 1 else 2
1:                                                              if.then P:1 S:0
	t7 = new TypeAssertionError (complit)               *TypeAssertionError
	t8 = &t7.interfaceString [#0]                                   *string
	t9 = &t7.concreteString [#1]                                    *string
	t10 = &t7.assertedString [#2]                                   *string
	t11 = &t._string [#8]                                          **string
	t12 = *t11                                                      *string
	t13 = *t12                                                       string
	t14 = &t7.missingMethod [#3]                                    *string
	*t8 = "":string
	*t9 = "":string
	*t10 = t13
	*t14 = "":string
	t15 = make interface{} <- *TypeAssertionError (t7)          interface{}
	panic t15
2:                                                              if.done P:1 S:2
	t16 = &t3._type [#0]                                            **_type
	t17 = *t16                                                       *_type
	t18 = t17 != t                                                     bool
	if t18 goto 3 else 4
3:                                                              if.then P:1 S:0
	t19 = new TypeAssertionError (complit)              *TypeAssertionError
	t20 = &t19.interfaceString [#0]                                 *string
	t21 = &t19.concreteString [#1]                                  *string
	t22 = &t3._type [#0]                                            **_type
	t23 = *t22                                                       *_type
	t24 = &t23._string [#8]                                        **string
	t25 = *t24                                                      *string
	t26 = *t25                                                       string
	t27 = &t19.assertedString [#2]                                  *string
	t28 = &t._string [#8]                                          **string
	t29 = *t28                                                      *string
	t30 = *t29                                                       string
	t31 = &t19.missingMethod [#3]                                   *string
	*t20 = "":string
	*t21 = t26
	*t27 = t30
	*t31 = "":string
	t32 = make interface{} <- *TypeAssertionError (t19)         interface{}
	panic t32
4:                                                              if.done P:1 S:2
	t33 = &t.size [#0]                                             *uintptr
	t34 = *t33                                                      uintptr
	t35 = isDirectIface(t)                                             bool
	if t35 goto 5 else 7
5:                                                              if.then P:1 S:1
	t36 = convert unsafe.Pointer <- *struct{} (t1)           unsafe.Pointer
	t37 = &t3.data [#1]                                     *unsafe.Pointer
	t38 = convert unsafe.Pointer <- *unsafe.Pointer (t37)    unsafe.Pointer
	t39 = memmove(t36, t38, t34)                                         ()
	jump 6
6:                                                              if.done P:2 S:0
	t40 = *t1                                                      struct{}
	return t40
7:                                                              if.else P:1 S:1
	t41 = convert unsafe.Pointer <- *struct{} (t1)           unsafe.Pointer
	t42 = &t3.data [#1]                                     *unsafe.Pointer
	t43 = *t42                                               unsafe.Pointer
	t44 = memmove(t41, t43, t34)                                         ()
	jump 6

# Name: runtime.assertE2T2
# Package: runtime
# Location: /usr/local/go/src/runtime/iface.go:237:6
func assertE2T2(t *_type, e interface{}) (r byte):
0:                                                                entry P:0 S:2
	t0 = new interface{} (e)                                   *interface{}
	*t0 = e
	t1 = new byte (r)                                                 *byte
	t2 = convert unsafe.Pointer <- *interface{} (t0)         unsafe.Pointer
	t3 = convert *eface <- unsafe.Pointer (t2)                       *eface
	t4 = &t.size [#0]                                              *uintptr
	t5 = *t4                                                        uintptr
	t6 = convert unsafe.Pointer <- *byte (t1)                unsafe.Pointer
	t7 = add(t6, t5)                                         unsafe.Pointer
	t8 = convert *bool <- unsafe.Pointer (t7)                         *bool
	t9 = &t3._type [#0]                                             **_type
	t10 = *t9                                                        *_type
	t11 = t10 != t                                                     bool
	if t11 goto 1 else 2
1:                                                              if.then P:1 S:0
	*t8 = false:bool
	t12 = convert unsafe.Pointer <- *byte (t1)               unsafe.Pointer
	t13 = memclr(t12, t5)                                                ()
	t14 = *t1                                                          byte
	return t14
2:                                                              if.done P:1 S:2
	*t8 = true:bool
	t15 = isDirectIface(t)                                             bool
	if t15 goto 3 else 5
3:                                                              if.then P:1 S:1
	t16 = convert unsafe.Pointer <- *byte (t1)               unsafe.Pointer
	t17 = &t3.data [#1]                                     *unsafe.Pointer
	t18 = convert unsafe.Pointer <- *unsafe.Pointer (t17)    unsafe.Pointer
	t19 = memmove(t16, t18, t5)                                          ()
	jump 4
4:                                                              if.done P:2 S:0
	t20 = *t1                                                          byte
	return t20
5:                                                              if.else P:1 S:1
	t21 = convert unsafe.Pointer <- *byte (t1)               unsafe.Pointer
	t22 = &t3.data [#1]                                     *unsafe.Pointer
	t23 = *t22                                               unsafe.Pointer
	t24 = memmove(t21, t23, t5)                                          ()
	jump 4

# Name: runtime.assertE2TOK
# Package: runtime
# Location: /usr/local/go/src/runtime/iface.go:255:6
func assertE2TOK(t *_type, e interface{}) bool:
0:                                                                entry P:0 S:0
	t0 = new interface{} (e)                                   *interface{}
	*t0 = e
	t1 = convert unsafe.Pointer <- *interface{} (t0)         unsafe.Pointer
	t2 = convert *eface <- unsafe.Pointer (t1)                       *eface
	t3 = &t2._type [#0]                                             **_type
	t4 = *t3                                                         *_type
	t5 = t == t4                                                       bool
	return t5

# Name: runtime.convI2E
# Package: runtime
# Location: /usr/local/go/src/runtime/iface.go:260:6
func convI2E(i fInterface) (r interface{}):
0:                                                                entry P:0 S:2
	t0 = new fInterface (i)                                     *fInterface
	*t0 = i
	t1 = new interface{} (r)                                   *interface{}
	t2 = convert unsafe.Pointer <- *fInterface (t0)          unsafe.Pointer
	t3 = convert *iface <- unsafe.Pointer (t2)                       *iface
	t4 = &t3.tab [#0]                                                **itab
	t5 = *t4                                                          *itab
	t6 = t5 == nil:*itab                                               bool
	if t6 goto 1 else 2
1:                                                              if.then P:1 S:0
	t7 = *t1                                                    interface{}
	return t7
2:                                                              if.done P:1 S:0
	t8 = convert unsafe.Pointer <- *interface{} (t1)         unsafe.Pointer
	t9 = convert *eface <- unsafe.Pointer (t8)                       *eface
	t10 = &t9._type [#0]                                            **_type
	t11 = &t5._type [#1]                                            **_type
	t12 = *t11                                                       *_type
	*t10 = t12
	t13 = &t9.data [#1]                                     *unsafe.Pointer
	t14 = &t3.data [#1]                                     *unsafe.Pointer
	t15 = *t14                                               unsafe.Pointer
	*t13 = t15
	t16 = *t1                                                   interface{}
	return t16

# Name: runtime.assertI2E
# Package: runtime
# Location: /usr/local/go/src/runtime/iface.go:272:6
func assertI2E(inter *interfacetype, i fInterface) (r interface{}):
0:                                                                entry P:0 S:2
	t0 = new fInterface (i)                                     *fInterface
	*t0 = i
	t1 = new interface{} (r)                                   *interface{}
	t2 = convert unsafe.Pointer <- *fInterface (t0)          unsafe.Pointer
	t3 = convert *iface <- unsafe.Pointer (t2)                       *iface
	t4 = &t3.tab [#0]                                                **itab
	t5 = *t4                                                          *itab
	t6 = t5 == nil:*itab                                               bool
	if t6 goto 1 else 2
1:                                                              if.then P:1 S:0
	t7 = new TypeAssertionError (complit)               *TypeAssertionError
	t8 = &t7.interfaceString [#0]                                   *string
	t9 = &t7.concreteString [#1]                                    *string
	t10 = &t7.assertedString [#2]                                   *string
	t11 = &inter.typ [#0]                                            *_type
	t12 = &t11._string [#8]                                        **string
	t13 = *t12                                                      *string
	t14 = *t13                                                       string
	t15 = &t7.missingMethod [#3]                                    *string
	*t8 = "":string
	*t9 = "":string
	*t10 = t14
	*t15 = "":string
	t16 = make interface{} <- *TypeAssertionError (t7)          interface{}
	panic t16
2:                                                              if.done P:1 S:0
	t17 = convert unsafe.Pointer <- *interface{} (t1)        unsafe.Pointer
	t18 = convert *eface <- unsafe.Pointer (t17)                     *eface
	t19 = &t18._type [#0]                                           **_type
	t20 = &t5._type [#1]                                            **_type
	t21 = *t20                                                       *_type
	*t19 = t21
	t22 = &t18.data [#1]                                    *unsafe.Pointer
	t23 = &t3.data [#1]                                     *unsafe.Pointer
	t24 = *t23                                               unsafe.Pointer
	*t22 = t24
	t25 = *t1                                                   interface{}
	return t25

# Name: runtime.assertI2E2
# Package: runtime
# Location: /usr/local/go/src/runtime/iface.go:285:6
func assertI2E2(inter *interfacetype, i fInterface) (r interface{}, ok bool):
0:                                                                entry P:0 S:2
	t0 = new fInterface (i)                                     *fInterface
	*t0 = i
	t1 = new interface{} (r)                                   *interface{}
	t2 = convert unsafe.Pointer <- *fInterface (t0)          unsafe.Pointer
	t3 = convert *iface <- unsafe.Pointer (t2)                       *iface
	t4 = &t3.tab [#0]                                                **itab
	t5 = *t4                                                          *itab
	t6 = t5 == nil:*itab                                               bool
	if t6 goto 1 else 2
1:                                                              if.then P:1 S:0
	t7 = *t1                                                    interface{}
	return t7, false:bool
2:                                                              if.done P:1 S:0
	t8 = convert unsafe.Pointer <- *interface{} (t1)         unsafe.Pointer
	t9 = convert *eface <- unsafe.Pointer (t8)                       *eface
	t10 = &t9._type [#0]                                            **_type
	t11 = &t5._type [#1]                                            **_type
	t12 = *t11                                                       *_type
	*t10 = t12
	t13 = &t9.data [#1]                                     *unsafe.Pointer
	t14 = &t3.data [#1]                                     *unsafe.Pointer
	t15 = *t14                                               unsafe.Pointer
	*t13 = t15
	t16 = *t1                                                   interface{}
	return t16, true:bool

# Name: runtime.convI2I
# Package: runtime
# Location: /usr/local/go/src/runtime/iface.go:298:6
func convI2I(inter *interfacetype, i fInterface) (r fInterface):
0:                                                                entry P:0 S:2
	t0 = new fInterface (i)                                     *fInterface
	*t0 = i
	t1 = new fInterface (r)                                     *fInterface
	t2 = convert unsafe.Pointer <- *fInterface (t0)          unsafe.Pointer
	t3 = convert *iface <- unsafe.Pointer (t2)                       *iface
	t4 = &t3.tab [#0]                                                **itab
	t5 = *t4                                                          *itab
	t6 = t5 == nil:*itab                                               bool
	if t6 goto 1 else 2
1:                                                              if.then P:1 S:0
	t7 = *t1                                                     fInterface
	return t7
2:                                                              if.done P:1 S:2
	t8 = convert unsafe.Pointer <- *fInterface (t1)          unsafe.Pointer
	t9 = convert *iface <- unsafe.Pointer (t8)                       *iface
	t10 = &t5.inter [#0]                                    **interfacetype
	t11 = *t10                                               *interfacetype
	t12 = t11 == inter                                                 bool
	if t12 goto 3 else 4
3:                                                              if.then P:1 S:0
	t13 = &t9.tab [#0]                                               **itab
	*t13 = t5
	t14 = &t9.data [#1]                                     *unsafe.Pointer
	t15 = &t3.data [#1]                                     *unsafe.Pointer
	t16 = *t15                                               unsafe.Pointer
	*t14 = t16
	t17 = *t1                                                    fInterface
	return t17
4:                                                              if.done P:1 S:0
	t18 = &t9.tab [#0]                                               **itab
	t19 = &t5._type [#1]                                            **_type
	t20 = *t19                                                       *_type
	t21 = getitab(inter, t20, false:bool)                             *itab
	*t18 = t21
	t22 = &t9.data [#1]                                     *unsafe.Pointer
	t23 = &t3.data [#1]                                     *unsafe.Pointer
	t24 = *t23                                               unsafe.Pointer
	*t22 = t24
	t25 = *t1                                                    fInterface
	return t25

# Name: runtime.assertI2I
# Package: runtime
# Location: /usr/local/go/src/runtime/iface.go:315:6
func assertI2I(inter *interfacetype, i fInterface) (r fInterface):
0:                                                                entry P:0 S:2
	t0 = new fInterface (i)                                     *fInterface
	*t0 = i
	t1 = new fInterface (r)                                     *fInterface
	t2 = convert unsafe.Pointer <- *fInterface (t0)          unsafe.Pointer
	t3 = convert *iface <- unsafe.Pointer (t2)                       *iface
	t4 = &t3.tab [#0]                                                **itab
	t5 = *t4                                                          *itab
	t6 = t5 == nil:*itab                                               bool
	if t6 goto 1 else 2
1:                                                              if.then P:1 S:0
	t7 = new TypeAssertionError (complit)               *TypeAssertionError
	t8 = &t7.interfaceString [#0]                                   *string
	t9 = &t7.concreteString [#1]                                    *string
	t10 = &t7.assertedString [#2]                                   *string
	t11 = &inter.typ [#0]                                            *_type
	t12 = &t11._string [#8]                                        **string
	t13 = *t12                                                      *string
	t14 = *t13                                                       string
	t15 = &t7.missingMethod [#3]                                    *string
	*t8 = "":string
	*t9 = "":string
	*t10 = t14
	*t15 = "":string
	t16 = make interface{} <- *TypeAssertionError (t7)          interface{}
	panic t16
2:                                                              if.done P:1 S:2
	t17 = convert unsafe.Pointer <- *fInterface (t1)         unsafe.Pointer
	t18 = convert *iface <- unsafe.Pointer (t17)                     *iface
	t19 = &t5.inter [#0]                                    **interfacetype
	t20 = *t19                                               *interfacetype
	t21 = t20 == inter                                                 bool
	if t21 goto 3 else 4
3:                                                              if.then P:1 S:0
	t22 = &t18.tab [#0]                                              **itab
	*t22 = t5
	t23 = &t18.data [#1]                                    *unsafe.Pointer
	t24 = &t3.data [#1]                                     *unsafe.Pointer
	t25 = *t24                                               unsafe.Pointer
	*t23 = t25
	t26 = *t1                                                    fInterface
	return t26
4:                                                              if.done P:1 S:0
	t27 = &t18.tab [#0]                                              **itab
	t28 = &t5._type [#1]                                            **_type
	t29 = *t28                                                       *_type
	t30 = getitab(inter, t29, false:bool)                             *itab
	*t27 = t30
	t31 = &t18.data [#1]                                    *unsafe.Pointer
	t32 = &t3.data [#1]                                     *unsafe.Pointer
	t33 = *t32                                               unsafe.Pointer
	*t31 = t33
	t34 = *t1                                                    fInterface
	return t34

# Name: runtime.assertI2I2
# Package: runtime
# Location: /usr/local/go/src/runtime/iface.go:333:6
func assertI2I2(inter *interfacetype, i fInterface) (r fInterface, ok bool):
0:                                                                entry P:0 S:2
	t0 = new fInterface (i)                                     *fInterface
	*t0 = i
	t1 = new fInterface (r)                                     *fInterface
	t2 = convert unsafe.Pointer <- *fInterface (t0)          unsafe.Pointer
	t3 = convert *iface <- unsafe.Pointer (t2)                       *iface
	t4 = &t3.tab [#0]                                                **itab
	t5 = *t4                                                          *itab
	t6 = t5 == nil:*itab                                               bool
	if t6 goto 1 else 2
1:                                                              if.then P:1 S:0
	t7 = *t1                                                     fInterface
	return t7, false:bool
2:                                                              if.done P:1 S:2
	t8 = convert unsafe.Pointer <- *fInterface (t1)          unsafe.Pointer
	t9 = convert *iface <- unsafe.Pointer (t8)                       *iface
	t10 = &t5.inter [#0]                                    **interfacetype
	t11 = *t10                                               *interfacetype
	t12 = t11 == inter                                                 bool
	if t12 goto 3 else 4
3:                                                              if.then P:1 S:0
	t13 = &t9.tab [#0]                                               **itab
	*t13 = t5
	t14 = &t9.data [#1]                                     *unsafe.Pointer
	t15 = &t3.data [#1]                                     *unsafe.Pointer
	t16 = *t15                                               unsafe.Pointer
	*t14 = t16
	t17 = *t1                                                    fInterface
	return t17, true:bool
4:                                                              if.done P:1 S:2
	t18 = &t5._type [#1]                                            **_type
	t19 = *t18                                                       *_type
	t20 = getitab(inter, t19, true:bool)                              *itab
	t21 = t20 == nil:*itab                                             bool
	if t21 goto 5 else 6
5:                                                              if.then P:1 S:0
	t22 = &t9.data [#1]                                     *unsafe.Pointer
	*t22 = nil:unsafe.Pointer
	t23 = &t9.tab [#0]                                               **itab
	*t23 = nil:*itab
	t24 = *t1                                                    fInterface
	return t24, false:bool
6:                                                              if.done P:1 S:0
	t25 = &t9.tab [#0]                                               **itab
	*t25 = t20
	t26 = &t9.data [#1]                                     *unsafe.Pointer
	t27 = &t3.data [#1]                                     *unsafe.Pointer
	t28 = *t27                                               unsafe.Pointer
	*t26 = t28
	t29 = *t1                                                    fInterface
	return t29, true:bool

# Name: runtime.assertE2I
# Package: runtime
# Location: /usr/local/go/src/runtime/iface.go:359:6
func assertE2I(inter *interfacetype, e interface{}) (r fInterface):
0:                                                                entry P:0 S:2
	t0 = new interface{} (e)                                   *interface{}
	*t0 = e
	t1 = new fInterface (r)                                     *fInterface
	t2 = convert unsafe.Pointer <- *interface{} (t0)         unsafe.Pointer
	t3 = convert *eface <- unsafe.Pointer (t2)                       *eface
	t4 = &t3._type [#0]                                             **_type
	t5 = *t4                                                         *_type
	t6 = t5 == nil:*_type                                              bool
	if t6 goto 1 else 2
1:                                                              if.then P:1 S:0
	t7 = new TypeAssertionError (complit)               *TypeAssertionError
	t8 = &t7.interfaceString [#0]                                   *string
	t9 = &t7.concreteString [#1]                                    *string
	t10 = &t7.assertedString [#2]                                   *string
	t11 = &inter.typ [#0]                                            *_type
	t12 = &t11._string [#8]                                        **string
	t13 = *t12                                                      *string
	t14 = *t13                                                       string
	t15 = &t7.missingMethod [#3]                                    *string
	*t8 = "":string
	*t9 = "":string
	*t10 = t14
	*t15 = "":string
	t16 = make interface{} <- *TypeAssertionError (t7)          interface{}
	panic t16
2:                                                              if.done P:1 S:0
	t17 = convert unsafe.Pointer <- *fInterface (t1)         unsafe.Pointer
	t18 = convert *iface <- unsafe.Pointer (t17)                     *iface
	t19 = &t18.tab [#0]                                              **itab
	t20 = getitab(inter, t5, false:bool)                              *itab
	*t19 = t20
	t21 = &t18.data [#1]                                    *unsafe.Pointer
	t22 = &t3.data [#1]                                     *unsafe.Pointer
	t23 = *t22                                               unsafe.Pointer
	*t21 = t23
	t24 = *t1                                                    fInterface
	return t24

# Name: runtime.assertE2I2
# Package: runtime
# Location: /usr/local/go/src/runtime/iface.go:372:6
func assertE2I2(inter *interfacetype, e interface{}) (r fInterface, ok bool):
0:                                                                entry P:0 S:2
	t0 = new interface{} (e)                                   *interface{}
	*t0 = e
	t1 = new fInterface (r)                                     *fInterface
	t2 = convert unsafe.Pointer <- *interface{} (t0)         unsafe.Pointer
	t3 = convert *eface <- unsafe.Pointer (t2)                       *eface
	t4 = &t3._type [#0]                                             **_type
	t5 = *t4                                                         *_type
	t6 = t5 == nil:*_type                                              bool
	if t6 goto 1 else 2
1:                                                              if.then P:1 S:0
	t7 = *t1                                                     fInterface
	return t7, false:bool
2:                                                              if.done P:1 S:2
	t8 = getitab(inter, t5, true:bool)                                *itab
	t9 = t8 == nil:*itab                                               bool
	if t9 goto 3 else 4
3:                                                              if.then P:1 S:0
	t10 = *t1                                                    fInterface
	return t10, false:bool
4:                                                              if.done P:1 S:0
	t11 = convert unsafe.Pointer <- *fInterface (t1)         unsafe.Pointer
	t12 = convert *iface <- unsafe.Pointer (t11)                     *iface
	t13 = &t12.tab [#0]                                              **itab
	*t13 = t8
	t14 = &t12.data [#1]                                    *unsafe.Pointer
	t15 = &t3.data [#1]                                     *unsafe.Pointer
	t16 = *t15                                               unsafe.Pointer
	*t14 = t16
	t17 = *t1                                                    fInterface
	return t17, true:bool

# Name: runtime.reflect_ifaceE2I
# Package: runtime
# Location: /usr/local/go/src/runtime/iface.go:389:6
func reflect_ifaceE2I(inter *interfacetype, e interface{}, dst *fInterface):
0:                                                                entry P:0 S:0
	t0 = assertE2I(inter, e)                                     fInterface
	*dst = t0
	return

# Name: runtime.assertE2E
# Package: runtime
# Location: /usr/local/go/src/runtime/iface.go:393:6
func assertE2E(inter *interfacetype, e interface{}) interface{}:
0:                                                                entry P:0 S:2
	t0 = new interface{} (e)                                   *interface{}
	*t0 = e
	t1 = convert unsafe.Pointer <- *interface{} (t0)         unsafe.Pointer
	t2 = convert *eface <- unsafe.Pointer (t1)                       *eface
	t3 = &t2._type [#0]                                             **_type
	t4 = *t3                                                         *_type
	t5 = t4 == nil:*_type                                              bool
	if t5 goto 1 else 2
1:                                                              if.then P:1 S:0
	t6 = new TypeAssertionError (complit)               *TypeAssertionError
	t7 = &t6.interfaceString [#0]                                   *string
	t8 = &t6.concreteString [#1]                                    *string
	t9 = &t6.assertedString [#2]                                    *string
	t10 = &inter.typ [#0]                                            *_type
	t11 = &t10._string [#8]                                        **string
	t12 = *t11                                                      *string
	t13 = *t12                                                       string
	t14 = &t6.missingMethod [#3]                                    *string
	*t7 = "":string
	*t8 = "":string
	*t9 = t13
	*t14 = "":string
	t15 = make interface{} <- *TypeAssertionError (t6)          interface{}
	panic t15
2:                                                              if.done P:1 S:0
	t16 = *t0                                                   interface{}
	return t16

# Name: runtime.assertE2E2
# Package: runtime
# Location: /usr/local/go/src/runtime/iface.go:402:6
func assertE2E2(inter *interfacetype, e interface{}) (interface{}, bool):
0:                                                                entry P:0 S:2
	t0 = new interface{} (e)                                   *interface{}
	*t0 = e
	t1 = convert unsafe.Pointer <- *interface{} (t0)         unsafe.Pointer
	t2 = convert *eface <- unsafe.Pointer (t1)                       *eface
	t3 = &t2._type [#0]                                             **_type
	t4 = *t3                                                         *_type
	t5 = t4 == nil:*_type                                              bool
	if t5 goto 1 else 2
1:                                                              if.then P:1 S:0
	return nil:interface{}, false:bool
2:                                                              if.done P:1 S:0
	t6 = *t0                                                    interface{}
	return t6, true:bool

# Name: runtime.ifacethash
# Package: runtime
# Location: /usr/local/go/src/runtime/iface.go:410:6
func ifacethash(i fInterface) uint32:
0:                                                                entry P:0 S:2
	t0 = new fInterface (i)                                     *fInterface
	*t0 = i
	t1 = convert unsafe.Pointer <- *fInterface (t0)          unsafe.Pointer
	t2 = convert *iface <- unsafe.Pointer (t1)                       *iface
	t3 = &t2.tab [#0]                                                **itab
	t4 = *t3                                                          *itab
	t5 = t4 == nil:*itab                                               bool
	if t5 goto 1 else 2
1:                                                              if.then P:1 S:0
	return 0:uint32
2:                                                              if.done P:1 S:0
	t6 = &t4._type [#1]                                             **_type
	t7 = *t6                                                         *_type
	t8 = &t7.hash [#1]                                              *uint32
	t9 = *t8                                                         uint32
	return t9

# Name: runtime.efacethash
# Package: runtime
# Location: /usr/local/go/src/runtime/iface.go:419:6
func efacethash(e interface{}) uint32:
0:                                                                entry P:0 S:2
	t0 = new interface{} (e)                                   *interface{}
	*t0 = e
	t1 = convert unsafe.Pointer <- *interface{} (t0)         unsafe.Pointer
	t2 = convert *eface <- unsafe.Pointer (t1)                       *eface
	t3 = &t2._type [#0]                                             **_type
	t4 = *t3                                                         *_type
	t5 = t4 == nil:*_type                                              bool
	if t5 goto 1 else 2
1:                                                              if.then P:1 S:0
	return 0:uint32
2:                                                              if.done P:1 S:0
	t6 = &t4.hash [#1]                                              *uint32
	t7 = *t6                                                         uint32
	return t7

# Name: runtime.iterate_itabs
# Package: runtime
# Location: /usr/local/go/src/runtime/iface.go:428:6
func iterate_itabs(fn func(*itab)):
0:                                                                entry P:0 S:1
	jump 1
1:                                                      rangeindex.loop P:2 S:2
	t0 = phi [0: -1:int, 5: t1]                                         int
	t1 = t0 + 1:int                                                     int
	t2 = t1 < 1009:int                                                 bool
	if t2 goto 2 else 3
2:                                                      rangeindex.body P:1 S:1
	t3 = &hash[t1]                                                   **itab
	t4 = *t3                                                          *itab
	jump 5
3:                                                      rangeindex.done P:1 S:0
	return
4:                                                             for.body P:1 S:1
	t5 = fn(t8)                                                          ()
	t6 = &t8.link [#2]                                               **itab
	t7 = *t6                                                          *itab
	jump 5
5:                                                             for.loop P:2 S:2
	t8 = phi [2: t4, 4: t7] #h                                        *itab
	t9 = t8 != nil:*itab                                               bool
	if t9 goto 4 else 1

# Name: runtime.ifaceE2I2
# Package: runtime
# Location: /usr/local/go/src/runtime/iface.go:436:6
func ifaceE2I2(inter *interfacetype, e interface{}, r *fInterface) (ok bool):
0:                                                                entry P:0 S:0
	t0 = assertE2I2(inter, e)                       (r fInterface, ok bool)
	t1 = extract t0 #0                                           fInterface
	*r = t1
	t2 = extract t0 #1                                                 bool
	return t2

# Name: runtime.lock
# Package: runtime
# Location: /usr/local/go/src/runtime/lock_sema.go:38:6
func lock(l *mutex):
0:                                                                entry P:0 S:2
	t0 = getg()                                                          *g
	t1 = &t0.m [#21]                                                    **m
	t2 = *t1                                                             *m
	t3 = &t2.locks [#14]                                             *int32
	t4 = *t3                                                          int32
	t5 = t4 < 0:int32                                                  bool
	if t5 goto 1 else 2
1:                                                              if.then P:1 S:1
	t6 = gothrow("runtimelock: lo...":string)                          ()
	jump 2
2:                                                              if.done P:2 S:2
	t7 = &t0.m [#21]                                                    **m
	t8 = *t7                                                             *m
	t9 = &t8.locks [#14]                                             *int32
	t10 = *t9                                                         int32
	t11 = t10 + 1:int32                                               int32
	*t9 = t11
	t12 = &l.key [#0]                                              *uintptr
	t13 = casuintptr(t12, 0:uintptr, 1:uintptr)                        bool
	if t13 goto 3 else 4
3:                                                              if.then P:1 S:0
	return
4:                                                              if.done P:1 S:2
	t14 = &t0.m [#21]                                                   **m
	t15 = *t14                                                           *m
	t16 = &t15.waitsema [#37]                                      *uintptr
	t17 = *t16                                                      uintptr
	t18 = t17 == 0:uintptr                                             bool
	if t18 goto 5 else 6
5:                                                              if.then P:1 S:1
	t19 = &t0.m [#21]                                                   **m
	t20 = *t19                                                           *m
	t21 = &t20.waitsema [#37]                                      *uintptr
	t22 = semacreate()                                              uintptr
	*t21 = t22
	jump 6
6:                                                              if.done P:2 S:2
	t23 = *ncpu                                                       int32
	t24 = t23 > 1:int32                                                bool
	if t24 goto 7 else 8
7:                                                              if.then P:1 S:1
	jump 8
8:                                                              if.done P:2 S:1
	t25 = phi [6: 0:int, 7: 4:int] #spin                                int
	jump 9
9:                                                             for.body P:2 S:2
	t26 = phi [8: 0:int, 10: t32] #i                                    int
	t27 = &l.key [#0]                                              *uintptr
	t28 = atomicloaduintptr(t27)                                    uintptr
	t29 = t28 & 1:uintptr                                           uintptr
	t30 = t29 == 0:uintptr                                             bool
	if t30 goto 11 else 12
10:                                                            for.post P:5 S:1
	t31 = phi [20: t36, 15: t36, 17: t36, 19: t36, 21: 0:int] #i        int
	t32 = t31 + 1:int                                                   int
	jump 9
11:                                                             if.then P:1 S:2
	t33 = &l.key [#0]                                              *uintptr
	t34 = t28 | 1:uintptr                                           uintptr
	t35 = casuintptr(t33, t28, t34)                                    bool
	if t35 goto 13 else 14
12:                                                             if.done P:2 S:2
	t36 = phi [9: t26, 14: 0:int] #i                                    int
	t37 = t36 < t25                                                    bool
	if t37 goto 15 else 16
13:                                                             if.then P:1 S:0
	return
14:                                                             if.done P:1 S:1
	jump 12
15:                                                             if.then P:1 S:1
	t38 = procyield(30:uint32)                                           ()
	jump 10
16:                                                             if.else P:1 S:2
	t39 = t25 + 1:int                                                   int
	t40 = t36 < t39                                                    bool
	if t40 goto 17 else 18
17:                                                             if.then P:1 S:1
	t41 = osyield()                                                      ()
	jump 10
18:                                                            for.body P:2 S:2
	t42 = phi [16: t28, 20: t59] #v                                 uintptr
	t43 = &t0.m [#21]                                                   **m
	t44 = *t43                                                           *m
	t45 = &t44.nextwaitm [#36]                                          **m
	t46 = t42 &^ 1:uintptr                                          uintptr
	t47 = convert unsafe.Pointer <- uintptr (t46)            unsafe.Pointer
	t48 = convert *m <- unsafe.Pointer (t47)                             *m
	*t45 = t48
	t49 = &l.key [#0]                                              *uintptr
	t50 = &t0.m [#21]                                                   **m
	t51 = *t50                                                           *m
	t52 = convert unsafe.Pointer <- *m (t51)                 unsafe.Pointer
	t53 = convert uintptr <- unsafe.Pointer (t52)                   uintptr
	t54 = t53 | 1:uintptr                                           uintptr
	t55 = casuintptr(t49, t42, t54)                                    bool
	if t55 goto 19 else 20
19:                                                             if.then P:1 S:2
	t56 = t42 & 1:uintptr                                           uintptr
	t57 = t56 != 0:uintptr                                             bool
	if t57 goto 21 else 10
20:                                                             if.done P:1 S:2
	t58 = &l.key [#0]                                              *uintptr
	t59 = atomicloaduintptr(t58)                                    uintptr
	t60 = t59 & 1:uintptr                                           uintptr
	t61 = t60 == 0:uintptr                                             bool
	if t61 goto 10 else 18
21:                                                             if.then P:1 S:1
	t62 = semasleep(-1:int64)                                         int32
	jump 10

# Name: runtime.unlock
# Package: runtime
# Location: /usr/local/go/src/runtime/lock_sema.go:97:6
func unlock(l *mutex):
0:                                                                entry P:0 S:1
	t0 = getg()                                                          *g
	jump 1
1:                                                             for.body P:3 S:2
	t1 = phi [0: nil:*m, 3: t1, 4: t19] #mp                              *m
	t2 = &l.key [#0]                                               *uintptr
	t3 = atomicloaduintptr(t2)                                      uintptr
	t4 = t3 == 1:uintptr                                               bool
	if t4 goto 3 else 4
2:                                                             for.done P:2 S:2
	t5 = &t0.m [#21]                                                    **m
	t6 = *t5                                                             *m
	t7 = &t6.locks [#14]                                             *int32
	t8 = *t7                                                          int32
	t9 = t8 - 1:int32                                                 int32
	*t7 = t9
	t10 = &t0.m [#21]                                                   **m
	t11 = *t10                                                           *m
	t12 = &t11.locks [#14]                                           *int32
	t13 = *t12                                                        int32
	t14 = t13 < 0:int32                                                bool
	if t14 goto 6 else 7
3:                                                              if.then P:1 S:2
	t15 = &l.key [#0]                                              *uintptr
	t16 = casuintptr(t15, 1:uintptr, 0:uintptr)                        bool
	if t16 goto 2 else 1
4:                                                              if.else P:1 S:2
	t17 = t3 &^ 1:uintptr                                           uintptr
	t18 = convert unsafe.Pointer <- uintptr (t17)            unsafe.Pointer
	t19 = convert *m <- unsafe.Pointer (t18)                             *m
	t20 = &l.key [#0]                                              *uintptr
	t21 = &t19.nextwaitm [#36]                                          **m
	t22 = *t21                                                           *m
	t23 = convert unsafe.Pointer <- *m (t22)                 unsafe.Pointer
	t24 = convert uintptr <- unsafe.Pointer (t23)                   uintptr
	t25 = casuintptr(t20, t3, t24)                                     bool
	if t25 goto 5 else 1
5:                                                              if.then P:1 S:1
	t26 = semawakeup(t19)                                                ()
	jump 2
6:                                                              if.then P:1 S:1
	t27 = gothrow("runtimeunlock: ...":string)                         ()
	jump 7
7:                                                              if.done P:2 S:2
	t28 = &t0.m [#21]                                                   **m
	t29 = *t28                                                           *m
	t30 = &t29.locks [#14]                                           *int32
	t31 = *t30                                                        int32
	t32 = t31 == 0:int32                                               bool
	if t32 goto 10 else 9
8:                                                              if.then P:1 S:1
	t33 = &t0.stackguard0 [#1]                                     *uintptr
	*t33 = 18446744073709550302:uintptr
	jump 9
9:                                                              if.done P:3 S:0
	return
10:                                                           cond.true P:1 S:2
	t34 = &t0.preempt [#15]                                           *bool
	t35 = *t34                                                         bool
	if t35 goto 8 else 9

# Name: runtime.noteclear
# Package: runtime
# Location: /usr/local/go/src/runtime/lock_sema.go:127:6
func noteclear(n *note):
0:                                                                entry P:0 S:0
	t0 = &n.key [#0]                                               *uintptr
	*t0 = 0:uintptr
	return

# Name: runtime.notewakeup
# Package: runtime
# Location: /usr/local/go/src/runtime/lock_sema.go:131:6
func notewakeup(n *note):
0:                                                                entry P:0 S:1
	jump 1
1:                                                             for.body P:2 S:2
	t0 = &n.key [#0]                                               *uintptr
	t1 = atomicloaduintptr(t0)                                      uintptr
	t2 = &n.key [#0]                                               *uintptr
	t3 = casuintptr(t2, t1, 1:uintptr)                                 bool
	if t3 goto 2 else 1
2:                                                              if.then P:1 S:2
	t4 = t1 == 0:uintptr                                               bool
	if t4 goto 3 else 5
3:                                                          switch.done P:3 S:0
	return
4:                                                          switch.body P:1 S:1
	t5 = gothrow("notewakeup - doub...":string)                          ()
	jump 3
5:                                                          switch.next P:1 S:2
	t6 = t1 == 1:uintptr                                               bool
	if t6 goto 4 else 6
6:                                                          switch.next P:1 S:1
	t7 = convert unsafe.Pointer <- uintptr (t1)              unsafe.Pointer
	t8 = convert *m <- unsafe.Pointer (t7)                               *m
	t9 = semawakeup(t8)                                                  ()
	jump 3

# Name: runtime.notesleep
# Package: runtime
# Location: /usr/local/go/src/runtime/lock_sema.go:154:6
func notesleep(n *note):
0:                                                                entry P:0 S:2
	t0 = getg()                                                          *g
	t1 = &t0.m [#21]                                                    **m
	t2 = *t1                                                             *m
	t3 = &t2.g0 [#0]                                                    **g
	t4 = *t3                                                             *g
	t5 = t0 != t4                                                      bool
	if t5 goto 1 else 2
1:                                                              if.then P:1 S:1
	t6 = gothrow("notesleep not on g0":string)                           ()
	jump 2
2:                                                              if.done P:2 S:2
	t7 = &t0.m [#21]                                                    **m
	t8 = *t7                                                             *m
	t9 = &t8.waitsema [#37]                                        *uintptr
	t10 = *t9                                                       uintptr
	t11 = t10 == 0:uintptr                                             bool
	if t11 goto 3 else 4
3:                                                              if.then P:1 S:1
	t12 = &t0.m [#21]                                                   **m
	t13 = *t12                                                           *m
	t14 = &t13.waitsema [#37]                                      *uintptr
	t15 = semacreate()                                              uintptr
	*t14 = t15
	jump 4
4:                                                              if.done P:2 S:2
	t16 = &n.key [#0]                                              *uintptr
	t17 = &t0.m [#21]                                                   **m
	t18 = *t17                                                           *m
	t19 = convert unsafe.Pointer <- *m (t18)                 unsafe.Pointer
	t20 = convert uintptr <- unsafe.Pointer (t19)                   uintptr
	t21 = casuintptr(t16, 0:uintptr, t20)                              bool
	if t21 goto 6 else 5
5:                                                              if.then P:1 S:2
	t22 = &n.key [#0]                                              *uintptr
	t23 = *t22                                                      uintptr
	t24 = t23 != 1:uintptr                                             bool
	if t24 goto 7 else 8
6:                                                              if.done P:1 S:0
	t25 = &t0.m [#21]                                                   **m
	t26 = *t25                                                           *m
	t27 = &t26.blocked [#20]                                          *bool
	*t27 = true:bool
	t28 = semasleep(-1:int64)                                         int32
	t29 = &t0.m [#21]                                                   **m
	t30 = *t29                                                           *m
	t31 = &t30.blocked [#20]                                          *bool
	*t31 = false:bool
	return
7:                                                              if.then P:1 S:1
	t32 = gothrow("notesleep - waitm...":string)                         ()
	jump 8
8:                                                              if.done P:2 S:0
	return

# Name: runtime.notetsleep_internal
# Package: runtime
# Location: /usr/local/go/src/runtime/lock_sema.go:176:6
func notetsleep_internal(n *note, ns int64, gp *g, deadline int64) bool:
0:                                                                entry P:0 S:2
	t0 = getg()                                                          *g
	t1 = &n.key [#0]                                               *uintptr
	t2 = &t0.m [#21]                                                    **m
	t3 = *t2                                                             *m
	t4 = convert unsafe.Pointer <- *m (t3)                   unsafe.Pointer
	t5 = convert uintptr <- unsafe.Pointer (t4)                     uintptr
	t6 = casuintptr(t1, 0:uintptr, t5)                                 bool
	if t6 goto 2 else 1
1:                                                              if.then P:1 S:2
	t7 = &n.key [#0]                                               *uintptr
	t8 = *t7                                                        uintptr
	t9 = t8 != 1:uintptr                                               bool
	if t9 goto 3 else 4
2:                                                              if.done P:1 S:2
	t10 = ns < 0:int64                                                 bool
	if t10 goto 5 else 6
3:                                                              if.then P:1 S:1
	t11 = gothrow("notetsleep - wait...":string)                         ()
	jump 4
4:                                                              if.done P:2 S:0
	return true:bool
5:                                                              if.then P:1 S:0
	t12 = &t0.m [#21]                                                   **m
	t13 = *t12                                                           *m
	t14 = &t13.blocked [#20]                                          *bool
	*t14 = true:bool
	t15 = semasleep(-1:int64)                                         int32
	t16 = &t0.m [#21]                                                   **m
	t17 = *t16                                                           *m
	t18 = &t17.blocked [#20]                                          *bool
	*t18 = false:bool
	return true:bool
6:                                                              if.done P:1 S:1
	t19 = nanotime()                                                  int64
	t20 = t19 + ns                                                    int64
	jump 7
7:                                                             for.body P:2 S:2
	t21 = phi [6: ns, 9: t34] #ns                                     int64
	t22 = &t0.m [#21]                                                   **m
	t23 = *t22                                                           *m
	t24 = &t23.blocked [#20]                                          *bool
	*t24 = true:bool
	t25 = semasleep(t21)                                              int32
	t26 = t25 >= 0:int32                                               bool
	if t26 goto 8 else 9
8:                                                              if.then P:1 S:0
	t27 = &t0.m [#21]                                                   **m
	t28 = *t27                                                           *m
	t29 = &t28.blocked [#20]                                          *bool
	*t29 = false:bool
	return true:bool
9:                                                              if.done P:1 S:2
	t30 = &t0.m [#21]                                                   **m
	t31 = *t30                                                           *m
	t32 = &t31.blocked [#20]                                          *bool
	*t32 = false:bool
	t33 = nanotime()                                                  int64
	t34 = t20 - t33                                                   int64
	t35 = t34 <= 0:int64                                               bool
	if t35 goto 10 else 7
10:                                                            for.body P:3 S:2
	t36 = &n.key [#0]                                              *uintptr
	t37 = atomicloaduintptr(t36)                                    uintptr
	t38 = &t0.m [#21]                                                   **m
	t39 = *t38                                                           *m
	t40 = convert unsafe.Pointer <- *m (t39)                 unsafe.Pointer
	t41 = convert uintptr <- unsafe.Pointer (t40)                   uintptr
	t42 = t37 == t41                                                   bool
	if t42 goto 11 else 13
11:                                                         switch.body P:1 S:2
	t43 = &n.key [#0]                                              *uintptr
	t44 = casuintptr(t43, t37, 0:uintptr)                              bool
	if t44 goto 14 else 10
12:                                                         switch.body P:1 S:2
	t45 = &t0.m [#21]                                                   **m
	t46 = *t45                                                           *m
	t47 = &t46.blocked [#20]                                          *bool
	*t47 = true:bool
	t48 = semasleep(-1:int64)                                         int32
	t49 = t48 < 0:int32                                                bool
	if t49 goto 16 else 17
13:                                                         switch.next P:1 S:2
	t50 = t37 == 1:uintptr                                             bool
	if t50 goto 12 else 15
14:                                                             if.then P:1 S:0
	return false:bool
15:                                                         switch.next P:1 S:1
	t51 = gothrow("runtime: unexpect...":string)                         ()
	jump 10
16:                                                             if.then P:1 S:1
	t52 = gothrow("runtime: unable t...":string)                         ()
	jump 17
17:                                                             if.done P:2 S:0
	t53 = &t0.m [#21]                                                   **m
	t54 = *t53                                                           *m
	t55 = &t54.blocked [#20]                                          *bool
	*t55 = false:bool
	return true:bool

# Name: runtime.notetsleep
# Package: runtime
# Location: /usr/local/go/src/runtime/lock_sema.go:245:6
func notetsleep(n *note, ns int64) bool:
0:                                                                entry P:0 S:2
	t0 = getg()                                                          *g
	t1 = &t0.m [#21]                                                    **m
	t2 = *t1                                                             *m
	t3 = &t2.g0 [#0]                                                    **g
	t4 = *t3                                                             *g
	t5 = t0 != t4                                                      bool
	if t5 goto 3 else 2
1:                                                              if.then P:1 S:1
	t6 = gothrow("notetsleep not on g0":string)                          ()
	jump 2
2:                                                              if.done P:3 S:2
	t7 = &t0.m [#21]                                                    **m
	t8 = *t7                                                             *m
	t9 = &t8.waitsema [#37]                                        *uintptr
	t10 = *t9                                                       uintptr
	t11 = t10 == 0:uintptr                                             bool
	if t11 goto 4 else 5
3:                                                            cond.true P:1 S:2
	t12 = &t0.m [#21]                                                   **m
	t13 = *t12                                                           *m
	t14 = &t13.gcing [#13]                                           *int32
	t15 = *t14                                                        int32
	t16 = t15 == 0:int32                                               bool
	if t16 goto 1 else 2
4:                                                              if.then P:1 S:1
	t17 = &t0.m [#21]                                                   **m
	t18 = *t17                                                           *m
	t19 = &t18.waitsema [#37]                                      *uintptr
	t20 = semacreate()                                              uintptr
	*t19 = t20
	jump 5
5:                                                              if.done P:2 S:0
	t21 = notetsleep_internal(n, ns, nil:*g, 0:int64)                  bool
	return t21

# Name: runtime.notetsleepg
# Package: runtime
# Location: /usr/local/go/src/runtime/lock_sema.go:258:6
func notetsleepg(n *note, ns int64) bool:
0:                                                                entry P:0 S:2
	t0 = getg()                                                          *g
	t1 = &t0.m [#21]                                                    **m
	t2 = *t1                                                             *m
	t3 = &t2.g0 [#0]                                                    **g
	t4 = *t3                                                             *g
	t5 = t0 == t4                                                      bool
	if t5 goto 1 else 2
1:                                                              if.then P:1 S:1
	t6 = gothrow("notetsleepg on g0":string)                             ()
	jump 2
2:                                                              if.done P:2 S:2
	t7 = &t0.m [#21]                                                    **m
	t8 = *t7                                                             *m
	t9 = &t8.waitsema [#37]                                        *uintptr
	t10 = *t9                                                       uintptr
	t11 = t10 == 0:uintptr                                             bool
	if t11 goto 3 else 4
3:                                                              if.then P:1 S:1
	t12 = &t0.m [#21]                                                   **m
	t13 = *t12                                                           *m
	t14 = &t13.waitsema [#37]                                      *uintptr
	t15 = semacreate()                                              uintptr
	*t14 = t15
	jump 4
4:                                                              if.done P:2 S:0
	t16 = entersyscallblock()                                            ()
	t17 = notetsleep_internal(n, ns, nil:*g, 0:int64)                  bool
	t18 = exitsyscall()                                                  ()
	return t17

# Name: runtime.mallocgc
# Package: runtime
# Location: /usr/local/go/src/runtime/malloc.go:46:6
func mallocgc(size uintptr, typ *_type, flags uint32) unsafe.Pointer:
0:                                                                entry P:0 S:2
	t0 = size == 0:uintptr                                             bool
	if t0 goto 1 else 2
1:                                                              if.then P:1 S:0
	t1 = convert unsafe.Pointer <- *uintptr (zerobase)       unsafe.Pointer
	return t1
2:                                                              if.done P:1 S:2
	t2 = flags & 1:uint32                                            uint32
	t3 = t2 == 0:uint32                                                bool
	if t3 goto 5 else 4
3:                                                              if.then P:1 S:1
	t4 = gothrow("malloc missing type":string)                           ()
	jump 4
4:                                                              if.done P:3 S:2
	if false:untyped bool goto 6 else 7
5:                                                            cond.true P:1 S:2
	t5 = typ == nil:*_type                                             bool
	if t5 goto 3 else 4
6:                                                              if.then P:1 S:2
	t6 = acquirem()                                                      *m
	t7 = &t6.mallocing [#11]                                         *int32
	t8 = *t7                                                          int32
	t9 = t8 != 0:int32                                                 bool
	if t9 goto 8 else 9
7:                                                              if.done P:3 S:2
	t10 = gomcache()                                                *mcache
	t11 = size <= 32768:uintptr                                        bool
	if t11 goto 11 else 13
8:                                                              if.then P:1 S:1
	t12 = gothrow("malloc deadlock":string)                              ()
	jump 9
9:                                                              if.done P:2 S:2
	t13 = &t6.mallocing [#11]                                        *int32
	*t13 = 1:int32
	t14 = &t6.curg [#6]                                                 **g
	t15 = *t14                                                           *g
	t16 = t15 != nil:*g                                                bool
	if t16 goto 10 else 7
10:                                                             if.then P:1 S:1
	t17 = &t6.curg [#6]                                                 **g
	t18 = *t17                                                           *g
	t19 = &t18.stackguard0 [#1]                                    *uintptr
	*t19 = 18446744073709550509:uintptr
	jump 7
11:                                                             if.then P:1 S:2
	t20 = flags & 1:uint32                                           uint32
	t21 = t20 != 0:uint32                                              bool
	if t21 goto 17 else 16
12:                                                             if.done P:2 S:2
	t22 = phi [15: t50, 13: t46] #size                              uintptr
	t23 = phi [15: t51, 13: t44] #x                          unsafe.Pointer
	t24 = flags & 1:uint32                                           uint32
	t25 = t24 != 0:uint32                                              bool
	if t25 goto 46 else 45
13:                                                             if.else P:1 S:1
	t26 = acquirem()                                                     *m
	t27 = &t26.scalararg [#45]                                  *[4]uintptr
	t28 = &t27[0:int]                                              *uintptr
	*t28 = size
	t29 = &t26.scalararg [#45]                                  *[4]uintptr
	t30 = &t29[1:int]                                              *uintptr
	t31 = convert uintptr <- uint32 (flags)                         uintptr
	*t30 = t31
	t32 = onM(largeAlloc_m)                                              ()
	t33 = &t26.ptrarg [#46]                              *[4]unsafe.Pointer
	t34 = &t33[0:int]                                       *unsafe.Pointer
	t35 = *t34                                               unsafe.Pointer
	t36 = convert *mspan <- unsafe.Pointer (t35)                     *mspan
	t37 = &t26.ptrarg [#46]                              *[4]unsafe.Pointer
	t38 = &t37[0:int]                                       *unsafe.Pointer
	*t38 = nil:unsafe.Pointer
	t39 = releasem(t26)                                                  ()
	t40 = &t36.start [#2]                                           *pageID
	t41 = *t40                                                       pageID
	t42 = t41 << 13:uint64                                           pageID
	t43 = changetype uintptr <- pageID (t42)                        uintptr
	t44 = convert unsafe.Pointer <- uintptr (t43)            unsafe.Pointer
	t45 = &t36.elemsize [#11]                                      *uintptr
	t46 = *t45                                                      uintptr
	jump 12
14:                                                             if.then P:1 S:2
	t47 = &t10.tinysize [#3]                                       *uintptr
	t48 = *t47                                                      uintptr
	t49 = size <= t48                                                  bool
	if t49 goto 18 else 19
15:                                                             if.done P:5 S:1
	t50 = phi [36: 16:uintptr, 41: t153, 42: t153, 44: t153, 43: t153] #size uintptr
	t51 = phi [36: t132, 41: t187, 42: t187, 44: t187, 43: t187] #x unsafe.Pointer
	t52 = &t10.local_cachealloc [#1]                                *intptr
	t53 = convert intptr <- uintptr (t50)                            intptr
	t54 = *t52                                                       intptr
	t55 = t54 + t53                                                  intptr
	*t52 = t55
	jump 12
16:                                                             if.else P:2 S:2
	t56 = size <= 1016:uintptr                                         bool
	if t56 goto 37 else 39
17:                                                           cond.true P:1 S:2
	t57 = size < 16:uintptr                                            bool
	if t57 goto 14 else 16
18:                                                             if.then P:1 S:2
	t58 = &t10.tiny [#2]                                             **byte
	t59 = *t58                                                        *byte
	t60 = convert unsafe.Pointer <- *byte (t59)              unsafe.Pointer
	t61 = size & 7:uintptr                                          uintptr
	t62 = t61 == 0:uintptr                                             bool
	if t62 goto 20 else 22
19:                                                             if.done P:2 S:2
	t63 = &t10.alloc [#5]                                       *[67]*mspan
	t64 = &t63[2:int]                                               **mspan
	t65 = *t64                                                       *mspan
	t66 = &t65.freelist [#4]                                        **mlink
	t67 = *t66                                                       *mlink
	t68 = t67 == nil:*mlink                                            bool
	if t68 goto 33 else 34
20:                                                             if.then P:1 S:1
	t69 = roundup(t60, 8:uintptr)                            unsafe.Pointer
	jump 21
21:                                                             if.done P:4 S:2
	t70 = phi [20: t69, 23: t81, 24: t60, 25: t84] #tiny     unsafe.Pointer
	t71 = convert uintptr <- unsafe.Pointer (t70)                   uintptr
	t72 = &t10.tiny [#2]                                             **byte
	t73 = *t72                                                        *byte
	t74 = convert unsafe.Pointer <- *byte (t73)              unsafe.Pointer
	t75 = convert uintptr <- unsafe.Pointer (t74)                   uintptr
	t76 = t71 - t75                                                 uintptr
	t77 = size + t76                                                uintptr
	t78 = t77 <= t48                                                   bool
	if t78 goto 26 else 19
22:                                                             if.else P:1 S:2
	t79 = size & 3:uintptr                                          uintptr
	t80 = t79 == 0:uintptr                                             bool
	if t80 goto 23 else 24
23:                                                             if.then P:1 S:1
	t81 = roundup(t60, 4:uintptr)                            unsafe.Pointer
	jump 21
24:                                                             if.else P:1 S:2
	t82 = size & 1:uintptr                                          uintptr
	t83 = t82 == 0:uintptr                                             bool
	if t83 goto 25 else 21
25:                                                             if.then P:1 S:1
	t84 = roundup(t60, 2:uintptr)                            unsafe.Pointer
	jump 21
26:                                                             if.then P:1 S:2
	t85 = &t10.tiny [#2]                                             **byte
	t86 = add(t70, size)                                     unsafe.Pointer
	t87 = convert *byte <- unsafe.Pointer (t86)                       *byte
	*t85 = t87
	t88 = &t10.tinysize [#3]                                       *uintptr
	t89 = *t88                                                      uintptr
	t90 = t89 - t77                                                 uintptr
	*t88 = t90
	t91 = &t10.local_tinyallocs [#4]                               *uintptr
	t92 = *t91                                                      uintptr
	t93 = t92 + 1:uintptr                                           uintptr
	*t91 = t93
	if false:untyped bool goto 27 else 28
27:                                                             if.then P:1 S:2
	t94 = acquirem()                                                     *m
	t95 = &t94.mallocing [#11]                                       *int32
	t96 = *t95                                                        int32
	t97 = t96 == 0:int32                                               bool
	if t97 goto 29 else 30
28:                                                             if.done P:2 S:0
	return t70
29:                                                             if.then P:1 S:1
	t98 = gothrow("bad malloc":string)                                   ()
	jump 30
30:                                                             if.done P:2 S:2
	t99 = &t94.mallocing [#11]                                       *int32
	*t99 = 0:int32
	t100 = &t94.curg [#6]                                               **g
	t101 = *t100                                                         *g
	t102 = t101 != nil:*g                                              bool
	if t102 goto 31 else 32
31:                                                             if.then P:1 S:1
	t103 = &t94.curg [#6]                                               **g
	t104 = *t103                                                         *g
	t105 = &t104.stackguard0 [#1]                                  *uintptr
	t106 = &t94.curg [#6]                                               **g
	t107 = *t106                                                         *g
	t108 = &t107.stack [#0]                                          *stack
	t109 = &t108.lo [#0]                                           *uintptr
	t110 = *t109                                                    uintptr
	t111 = t110 + 512:uintptr                                       uintptr
	*t105 = t111
	jump 32
32:                                                             if.done P:2 S:1
	t112 = releasem(t94)                                                 ()
	t113 = releasem(t94)                                                 ()
	jump 28
33:                                                             if.then P:1 S:1
	t114 = acquirem()                                                    *m
	t115 = &t114.scalararg [#45]                                *[4]uintptr
	t116 = &t115[0:int]                                            *uintptr
	*t116 = 2:uintptr
	t117 = onM(mcacheRefill_m)                                           ()
	t118 = releasem(t114)                                                ()
	t119 = &t10.alloc [#5]                                      *[67]*mspan
	t120 = &t119[2:int]                                             **mspan
	t121 = *t120                                                     *mspan
	t122 = &t121.freelist [#4]                                      **mlink
	t123 = *t122                                                     *mlink
	jump 34
34:                                                             if.done P:2 S:2
	t124 = phi [19: t65, 33: t121] #s                                *mspan
	t125 = phi [19: t67, 33: t123] #v                                *mlink
	t126 = &t124.freelist [#4]                                      **mlink
	t127 = &t125.next [#0]                                          **mlink
	t128 = *t127                                                     *mlink
	*t126 = t128
	t129 = &t124.ref [#6]                                           *uint16
	t130 = *t129                                                     uint16
	t131 = t130 + 1:uint16                                           uint16
	*t129 = t131
	t132 = convert unsafe.Pointer <- *mlink (t125)           unsafe.Pointer
	t133 = convert *[2]uint64 <- unsafe.Pointer (t132)           *[2]uint64
	t134 = &t133[0:int]                                             *uint64
	*t134 = 0:uint64
	t135 = convert *[2]uint64 <- unsafe.Pointer (t132)           *[2]uint64
	t136 = &t135[1:int]                                             *uint64
	*t136 = 0:uint64
	t137 = 16:uintptr - size                                        uintptr
	t138 = t137 > t48                                                  bool
	if t138 goto 35 else 36
35:                                                             if.then P:1 S:1
	t139 = &t10.tiny [#2]                                            **byte
	t140 = add(t132, size)                                   unsafe.Pointer
	t141 = convert *byte <- unsafe.Pointer (t140)                     *byte
	*t139 = t141
	t142 = &t10.tinysize [#3]                                      *uintptr
	t143 = 16:uintptr - size                                        uintptr
	*t142 = t143
	jump 36
36:                                                             if.done P:2 S:1
	jump 15
37:                                                             if.then P:1 S:1
	t144 = size + 7:uintptr                                         uintptr
	t145 = t144 >> 3:uint64                                         uintptr
	t146 = convert int <- uintptr (t145)                                int
	t147 = &size_to_class8[t146]                                      *int8
	t148 = *t147                                                       int8
	jump 38
38:                                                             if.done P:2 S:2
	t149 = phi [37: t148, 39: t166] #sizeclass                         int8
	t150 = convert int <- int8 (t149)                                   int
	t151 = &class_to_size[t150]                                      *int32
	t152 = *t151                                                      int32
	t153 = convert uintptr <- int32 (t152)                          uintptr
	t154 = &t10.alloc [#5]                                      *[67]*mspan
	t155 = convert int <- int8 (t149)                                   int
	t156 = &t154[t155]                                              **mspan
	t157 = *t156                                                     *mspan
	t158 = &t157.freelist [#4]                                      **mlink
	t159 = *t158                                                     *mlink
	t160 = t159 == nil:*mlink                                          bool
	if t160 goto 40 else 41
39:                                                             if.else P:1 S:1
	t161 = size - 1024:uintptr                                      uintptr
	t162 = t161 + 127:uintptr                                       uintptr
	t163 = t162 >> 7:uint64                                         uintptr
	t164 = convert int <- uintptr (t163)                                int
	t165 = &size_to_class128[t164]                                    *int8
	t166 = *t165                                                       int8
	jump 38
40:                                                             if.then P:1 S:1
	t167 = acquirem()                                                    *m
	t168 = &t167.scalararg [#45]                                *[4]uintptr
	t169 = &t168[0:int]                                            *uintptr
	t170 = convert uintptr <- int8 (t149)                           uintptr
	*t169 = t170
	t171 = onM(mcacheRefill_m)                                           ()
	t172 = releasem(t167)                                                ()
	t173 = &t10.alloc [#5]                                      *[67]*mspan
	t174 = convert int <- int8 (t149)                                   int
	t175 = &t173[t174]                                              **mspan
	t176 = *t175                                                     *mspan
	t177 = &t176.freelist [#4]                                      **mlink
	t178 = *t177                                                     *mlink
	jump 41
41:                                                             if.done P:2 S:2
	t179 = phi [38: t157, 40: t176] #s                               *mspan
	t180 = phi [38: t159, 40: t178] #v                               *mlink
	t181 = &t179.freelist [#4]                                      **mlink
	t182 = &t180.next [#0]                                          **mlink
	t183 = *t182                                                     *mlink
	*t181 = t183
	t184 = &t179.ref [#6]                                           *uint16
	t185 = *t184                                                     uint16
	t186 = t185 + 1:uint16                                           uint16
	*t184 = t186
	t187 = convert unsafe.Pointer <- *mlink (t180)           unsafe.Pointer
	t188 = flags & 2:uint32                                          uint32
	t189 = t188 == 0:uint32                                            bool
	if t189 goto 42 else 15
42:                                                             if.then P:1 S:2
	t190 = &t180.next [#0]                                          **mlink
	*t190 = nil:*mlink
	t191 = t153 > 16:uintptr                                           bool
	if t191 goto 44 else 15
43:                                                             if.then P:1 S:1
	t192 = convert unsafe.Pointer <- *mlink (t180)           unsafe.Pointer
	t193 = memclr(t192, t153)                                            ()
	jump 15
44:                                                           cond.true P:1 S:2
	t194 = convert *[2]uintptr <- unsafe.Pointer (t187)         *[2]uintptr
	t195 = &t194[1:int]                                            *uintptr
	t196 = *t195                                                    uintptr
	t197 = t196 != 0:uintptr                                           bool
	if t197 goto 43 else 15
45:                                                             if.done P:1 S:2
	t198 = *deferType                                                *_type
	t199 = typ == t198                                                 bool
	if t199 goto 47 else 48
46:                                                              marked P:7 S:2
	if false:untyped bool goto 79 else 80
47:                                                             if.then P:1 S:1
	jump 48
48:                                                             if.done P:2 S:2
	t200 = phi [45: size, 47: 48:uintptr] #size0                    uintptr
	t201 = &mheap_.arena_start [#15]                                 **byte
	t202 = *t201                                                      *byte
	t203 = convert unsafe.Pointer <- *byte (t202)            unsafe.Pointer
	t204 = convert uintptr <- unsafe.Pointer (t203)                 uintptr
	t205 = convert uintptr <- unsafe.Pointer (t23)                  uintptr
	t206 = t205 - t204                                              uintptr
	t207 = t206 / 8:uintptr                                         uintptr
	t208 = t207 / 2:uintptr                                         uintptr
	t209 = t204 - t208                                              uintptr
	t210 = t209 - 1:uintptr                                         uintptr
	t211 = convert unsafe.Pointer <- uintptr (t210)          unsafe.Pointer
	t212 = convert *uint8 <- unsafe.Pointer (t211)                   *uint8
	t213 = t207 % 2:uintptr                                         uintptr
	t214 = t213 * 4:uintptr                                         uintptr
	if false:untyped bool goto 51 else 50
49:                                                             if.then P:1 S:1
	t215 = *t212                                                      uint8
	t216 = t215 >> t214                                               uint8
	t217 = t216 & 15:uint8                                            uint8
	t218 = println("runtime: bits =":string, t217)                       ()
	t219 = gothrow("bad bits in marka...":string)                        ()
	jump 50
50:                                                             if.done P:3 S:2
	t220 = t22 == 8:uintptr                                            bool
	if t220 goto 52 else 53
51:                                                           cond.true P:1 S:2
	t221 = *t212                                                      uint8
	t222 = t221 >> t214                                               uint8
	t223 = t222 & 15:uint8                                            uint8
	t224 = t223 != 1:uint8                                             bool
	if t224 goto 49 else 50
52:                                                             if.then P:1 S:1
	t225 = 8:uint8 << t214                                            uint8
	t226 = *t212                                                      uint8
	t227 = t226 | t225                                                uint8
	*t212 = t227
	jump 46
53:                                                             if.done P:1 S:2
	t228 = &typ.kind [#5]                                            *uint8
	t229 = *t228                                                      uint8
	t230 = t229 & 64:uint8                                            uint8
	t231 = t230 != 0:uint8                                             bool
	if t231 goto 54 else 56
54:                                                             if.then P:1 S:2
	t232 = &typ.size [#0]                                          *uintptr
	t233 = *t232                                                    uintptr
	t234 = t233 + 8:uintptr                                         uintptr
	t235 = t234 - 1:uintptr                                         uintptr
	t236 = t235 / 8:uintptr                                         uintptr
	t237 = t236 % 2:uintptr                                         uintptr
	t238 = t237 != 0:uintptr                                           bool
	if t238 goto 57 else 58
55:                                                             if.done P:2 S:2
	t239 = phi [63: t286, 56: t245] #ptrmask                         *uint8
	t240 = t22 == 16:uintptr                                           bool
	if t240 goto 64 else 65
56:                                                             if.else P:1 S:1
	t241 = &typ.gc [#7]                                         *[2]uintptr
	t242 = &t241[0:int]                                            *uintptr
	t243 = *t242                                                    uintptr
	t244 = convert unsafe.Pointer <- uintptr (t243)          unsafe.Pointer
	t245 = convert *uint8 <- unsafe.Pointer (t244)                   *uint8
	jump 55
57:                                                             if.then P:1 S:1
	t246 = t236 * 2:uintptr                                         uintptr
	jump 58
58:                                                             if.done P:2 S:2
	t247 = phi [54: t236, 57: t246] #masksize                       uintptr
	t248 = t247 * 4:uintptr                                         uintptr
	t249 = t248 / 8:uintptr                                         uintptr
	t250 = t249 + 1:uintptr                                         uintptr
	t251 = t250 > 64:uintptr                                           bool
	if t251 goto 61 else 60
59:                                                             if.then P:1 S:1
	t252 = acquirem()                                                    *m
	t253 = &t252.ptrarg [#46]                            *[4]unsafe.Pointer
	t254 = &t253[0:int]                                     *unsafe.Pointer
	*t254 = t23
	t255 = &t252.ptrarg [#46]                            *[4]unsafe.Pointer
	t256 = &t255[1:int]                                     *unsafe.Pointer
	t257 = convert unsafe.Pointer <- *_type (typ)            unsafe.Pointer
	*t256 = t257
	t258 = &t252.scalararg [#45]                                *[4]uintptr
	t259 = &t258[0:int]                                            *uintptr
	*t259 = t22
	t260 = &t252.scalararg [#45]                                *[4]uintptr
	t261 = &t260[1:int]                                            *uintptr
	*t261 = t200
	t262 = onM(unrollgcproginplace_m)                                    ()
	t263 = releasem(t252)                                                ()
	jump 46
60:                                                             if.done P:2 S:2
	t264 = &typ.gc [#7]                                         *[2]uintptr
	t265 = &t264[0:int]                                            *uintptr
	t266 = *t265                                                    uintptr
	t267 = convert unsafe.Pointer <- uintptr (t266)          unsafe.Pointer
	t268 = convert *uint8 <- unsafe.Pointer (t267)                   *uint8
	t269 = convert unsafe.Pointer <- *uint8 (t268)           unsafe.Pointer
	t270 = atomicloadp(t269)                                 unsafe.Pointer
	t271 = convert uintptr <- unsafe.Pointer (t270)                 uintptr
	t272 = t271 & 255:uintptr                                       uintptr
	t273 = t272 == 0:uintptr                                           bool
	if t273 goto 62 else 63
61:                                                           cond.true P:1 S:2
	t274 = &typ.gc [#7]                                         *[2]uintptr
	t275 = &t274[1:int]                                            *uintptr
	t276 = *t275                                                    uintptr
	t277 = t276 != 0:uintptr                                           bool
	if t277 goto 59 else 60
62:                                                             if.then P:1 S:1
	t278 = acquirem()                                                    *m
	t279 = &t278.ptrarg [#46]                            *[4]unsafe.Pointer
	t280 = &t279[0:int]                                     *unsafe.Pointer
	t281 = convert unsafe.Pointer <- *_type (typ)            unsafe.Pointer
	*t280 = t281
	t282 = onM(unrollgcprog_m)                                           ()
	t283 = releasem(t278)                                                ()
	jump 63
63:                                                             if.done P:2 S:1
	t284 = convert unsafe.Pointer <- *uint8 (t268)           unsafe.Pointer
	t285 = add(t284, 1:uintptr)                              unsafe.Pointer
	t286 = convert *uint8 <- unsafe.Pointer (t285)                   *uint8
	jump 55
64:                                                             if.then P:1 S:1
	t287 = *t239                                                      uint8
	t288 = t287 | 1:uint8                                             uint8
	*t212 = t288
	jump 46
65:                                                             if.done P:1 S:2
	t289 = &typ.size [#0]                                          *uintptr
	t290 = *t289                                                    uintptr
	t291 = t290 / 8:uintptr                                         uintptr
	t292 = t291 % 2:uintptr                                         uintptr
	t293 = t292 == 0:uintptr                                           bool
	if t293 goto 66 else 67
66:                                                             if.then P:1 S:1
	t294 = t291 / 2:uintptr                                         uintptr
	jump 67
67:                                                             if.done P:2 S:1
	t295 = phi [65: t291, 66: t294] #te                             uintptr
	jump 70
68:                                                            for.body P:1 S:2
	t296 = convert unsafe.Pointer <- *uint8 (t239)           unsafe.Pointer
	t297 = add(t296, t305)                                   unsafe.Pointer
	t298 = convert *uint8 <- unsafe.Pointer (t297)                   *uint8
	t299 = *t298                                                      uint8
	t300 = t305 + 1:uintptr                                         uintptr
	t301 = t300 == t295                                                bool
	if t301 goto 71 else 72
69:                                                            for.done P:1 S:2
	t302 = t200 % 16:uintptr                                        uintptr
	t303 = t302 == 0:uintptr                                           bool
	if t303 goto 78 else 46
70:                                                            for.loop P:2 S:2
	t304 = phi [67: t212, 76: t318] #xbits                           *uint8
	t305 = phi [67: 0:uintptr, 76: t308] #ti                        uintptr
	t306 = phi [67: 0:uintptr, 76: t319] #i                         uintptr
	t307 = t306 < t200                                                 bool
	if t307 goto 68 else 69
71:                                                             if.then P:1 S:1
	jump 72
72:                                                             if.done P:2 S:2
	t308 = phi [68: t300, 71: 0:uintptr] #ti                        uintptr
	t309 = t306 == 0:uintptr                                           bool
	if t309 goto 73 else 74
73:                                                             if.then P:1 S:1
	t310 = t299 | 1:uint8                                             uint8
	jump 74
74:                                                             if.done P:2 S:2
	t311 = phi [72: t299, 73: t310] #v                                uint8
	t312 = t306 + 8:uintptr                                         uintptr
	t313 = t312 == t200                                                bool
	if t313 goto 75 else 76
75:                                                             if.then P:1 S:1
	t314 = t311 &^ 192:uint8                                          uint8
	jump 76
76:                                                             if.done P:2 S:1
	t315 = phi [74: t311, 75: t314] #v                                uint8
	*t304 = t315
	t316 = convert unsafe.Pointer <- *uint8 (t304)           unsafe.Pointer
	t317 = add(t316, 18446744073709551615:uintptr)           unsafe.Pointer
	t318 = convert *byte <- unsafe.Pointer (t317)                     *byte
	t319 = t306 + 16:uintptr                                        uintptr
	jump 70
77:                                                             if.then P:1 S:1
	*t304 = 0:uint8
	jump 46
78:                                                           cond.true P:1 S:2
	t320 = t200 < t22                                                  bool
	if t320 goto 77 else 46
79:                                                             if.then P:1 S:1
	t321 = racemalloc(t23, t22)                                          ()
	jump 80
80:                                                             if.done P:2 S:2
	if false:untyped bool goto 81 else 82
81:                                                             if.then P:1 S:2
	t322 = acquirem()                                                    *m
	t323 = &t322.mallocing [#11]                                     *int32
	t324 = *t323                                                      int32
	t325 = t324 == 0:int32                                             bool
	if t325 goto 83 else 84
82:                                                             if.done P:2 S:2
	t326 = &debug.allocfreetrace [#0]                                *int32
	t327 = *t326                                                      int32
	t328 = t327 != 0:int32                                             bool
	if t328 goto 87 else 88
83:                                                             if.then P:1 S:1
	t329 = gothrow("bad malloc":string)                                  ()
	jump 84
84:                                                             if.done P:2 S:2
	t330 = &t322.mallocing [#11]                                     *int32
	*t330 = 0:int32
	t331 = &t322.curg [#6]                                              **g
	t332 = *t331                                                         *g
	t333 = t332 != nil:*g                                              bool
	if t333 goto 85 else 86
85:                                                             if.then P:1 S:1
	t334 = &t322.curg [#6]                                              **g
	t335 = *t334                                                         *g
	t336 = &t335.stackguard0 [#1]                                  *uintptr
	t337 = &t322.curg [#6]                                              **g
	t338 = *t337                                                         *g
	t339 = &t338.stack [#0]                                          *stack
	t340 = &t339.lo [#0]                                           *uintptr
	t341 = *t340                                                    uintptr
	t342 = t341 + 512:uintptr                                       uintptr
	*t336 = t342
	jump 86
86:                                                             if.done P:2 S:1
	t343 = releasem(t322)                                                ()
	t344 = releasem(t322)                                                ()
	jump 82
87:                                                             if.then P:1 S:1
	t345 = tracealloc(t23, t22, typ)                                     ()
	jump 88
88:                                                             if.done P:2 S:2
	t346 = *MemProfileRate                                              int
	t347 = t346 > 0:int                                                bool
	if t347 goto 89 else 90
89:                                                             if.then P:1 S:2
	t348 = convert uintptr <- int (t346)                            uintptr
	t349 = t22 < t348                                                  bool
	if t349 goto 93 else 92
90:                                                             if.done P:3 S:2
	t350 = &memstats.heap_alloc [#6]                                *uint64
	t351 = *t350                                                     uint64
	t352 = &memstats.next_gc [#21]                                  *uint64
	t353 = *t352                                                     uint64
	t354 = t351 >= t353                                                bool
	if t354 goto 94 else 95
91:                                                             if.then P:1 S:1
	t355 = &t10.next_sample [#0]                                     *int32
	t356 = convert int32 <- uintptr (t22)                             int32
	t357 = *t355                                                      int32
	t358 = t357 - t356                                                int32
	*t355 = t358
	jump 90
92:                                                             if.else P:2 S:1
	t359 = acquirem()                                                    *m
	t360 = profilealloc(t359, t23, t22)                                  ()
	t361 = releasem(t359)                                                ()
	jump 90
93:                                                           cond.true P:1 S:2
	t362 = convert int32 <- uintptr (t22)                             int32
	t363 = &t10.next_sample [#0]                                     *int32
	t364 = *t363                                                      int32
	t365 = t362 < t364                                                 bool
	if t365 goto 91 else 92
94:                                                             if.then P:1 S:1
	t366 = gogc(0:int32)                                                 ()
	jump 95
95:                                                             if.done P:2 S:0
	return t23

# Name: runtime.newobject
# Package: runtime
# Location: /usr/local/go/src/runtime/malloc.go:348:6
func newobject(typ *_type) unsafe.Pointer:
0:                                                                entry P:0 S:2
	t0 = &typ.kind [#5]                                              *uint8
	t1 = *t0                                                          uint8
	t2 = t1 & 128:uint8                                               uint8
	t3 = t2 != 0:uint8                                                 bool
	if t3 goto 1 else 2
1:                                                              if.then P:1 S:1
	t4 = 0:uint32 | 1:uint32                                         uint32
	jump 2
2:                                                              if.done P:2 S:0
	t5 = phi [0: 0:uint32, 1: t4] #flags                             uint32
	t6 = &typ.size [#0]                                            *uintptr
	t7 = *t6                                                        uintptr
	t8 = mallocgc(t7, typ, t5)                               unsafe.Pointer
	return t8

# Name: runtime.newarray
# Package: runtime
# Location: /usr/local/go/src/runtime/malloc.go:357:6
func newarray(typ *_type, n uintptr) unsafe.Pointer:
0:                                                                entry P:0 S:2
	t0 = &typ.kind [#5]                                              *uint8
	t1 = *t0                                                          uint8
	t2 = t1 & 128:uint8                                               uint8
	t3 = t2 != 0:uint8                                                 bool
	if t3 goto 1 else 2
1:                                                              if.then P:1 S:1
	t4 = 0:uint32 | 1:uint32                                         uint32
	jump 2
2:                                                              if.done P:2 S:2
	t5 = phi [0: 0:uint32, 1: t4] #flags                             uint32
	t6 = convert int <- uintptr (n)                                     int
	t7 = t6 < 0:int                                                    bool
	if t7 goto 3 else 5
3:                                                              if.then P:2 S:0
	t8 = make interface{} <- string ("runtime: allocati...":string) interface{}
	panic t8
4:                                                              if.done P:2 S:0
	t9 = &typ.size [#0]                                            *uintptr
	t10 = *t9                                                       uintptr
	t11 = t10 * n                                                   uintptr
	t12 = mallocgc(t11, typ, t5)                             unsafe.Pointer
	return t12
5:                                                           cond.false P:1 S:2
	t13 = &typ.size [#0]                                           *uintptr
	t14 = *t13                                                      uintptr
	t15 = t14 > 0:uintptr                                              bool
	if t15 goto 6 else 4
6:                                                            cond.true P:1 S:2
	t16 = *maxmem                                                   uintptr
	t17 = &typ.size [#0]                                           *uintptr
	t18 = *t17                                                      uintptr
	t19 = t16 / t18                                                 uintptr
	t20 = n > t19                                                      bool
	if t20 goto 3 else 4

# Name: runtime.rawmem
# Package: runtime
# Location: /usr/local/go/src/runtime/malloc.go:370:6
func rawmem(size uintptr) unsafe.Pointer:
0:                                                                entry P:0 S:0
	t0 = mallocgc(size, nil:*_type, 3:uint32)                unsafe.Pointer
	return t0

# Name: runtime.goroundupsize
# Package: runtime
# Location: /usr/local/go/src/runtime/malloc.go:375:6
func goroundupsize(size uintptr) uintptr:
0:                                                                entry P:0 S:2
	t0 = size < 32768:uintptr                                          bool
	if t0 goto 1 else 2
1:                                                              if.then P:1 S:2
	t1 = size <= 1016:uintptr                                          bool
	if t1 goto 3 else 4
2:                                                              if.done P:1 S:2
	t2 = size + 8192:uintptr                                        uintptr
	t3 = t2 < size                                                     bool
	if t3 goto 5 else 6
3:                                                              if.then P:1 S:0
	t4 = size + 7:uintptr                                           uintptr
	t5 = t4 >> 3:uint64                                             uintptr
	t6 = convert int <- uintptr (t5)                                    int
	t7 = &size_to_class8[t6]                                          *int8
	t8 = *t7                                                           int8
	t9 = convert int <- int8 (t8)                                       int
	t10 = &class_to_size[t9]                                         *int32
	t11 = *t10                                                        int32
	t12 = convert uintptr <- int32 (t11)                            uintptr
	return t12
4:                                                              if.done P:1 S:0
	t13 = size - 1024:uintptr                                       uintptr
	t14 = t13 + 127:uintptr                                         uintptr
	t15 = t14 >> 7:uint64                                           uintptr
	t16 = convert int <- uintptr (t15)                                  int
	t17 = &size_to_class128[t16]                                      *int8
	t18 = *t17                                                         int8
	t19 = convert int <- int8 (t18)                                     int
	t20 = &class_to_size[t19]                                        *int32
	t21 = *t20                                                        int32
	t22 = convert uintptr <- int32 (t21)                            uintptr
	return t22
5:                                                              if.then P:1 S:0
	return size
6:                                                              if.done P:1 S:0
	t23 = size + 8192:uintptr                                       uintptr
	t24 = t23 - 1:uintptr                                           uintptr
	t25 = t24 &^ 8191:uintptr                                       uintptr
	return t25

# Name: runtime.profilealloc
# Package: runtime
# Location: /usr/local/go/src/runtime/malloc.go:388:6
func profilealloc(mp *m, x unsafe.Pointer, size uintptr):
0:                                                                entry P:0 S:2
	t0 = &mp.mcache [#29]                                          **mcache
	t1 = *t0                                                        *mcache
	t2 = *MemProfileRate                                                int
	t3 = convert uintptr <- int (t2)                                uintptr
	t4 = size < t3                                                     bool
	if t4 goto 1 else 2
1:                                                              if.then P:1 S:2
	t5 = t2 > 1073741823:int                                           bool
	if t5 goto 3 else 4
2:                                                              if.done P:2 S:0
	t6 = mProf_Malloc(x, size)                                           ()
	return
3:                                                              if.then P:1 S:1
	jump 4
4:                                                              if.done P:2 S:2
	t7 = phi [1: t2, 3: 1073741823:int] #rate                           int
	t8 = fastrand1()                                                 uint32
	t9 = convert int32 <- uint32 (t8)                                 int32
	t10 = convert int32 <- int (t7)                                   int32
	t11 = 2:int32 * t10                                               int32
	t12 = t9 % t11                                                    int32
	t13 = convert int32 <- uintptr (size)                             int32
	t14 = &t1.next_sample [#0]                                       *int32
	t15 = *t14                                                        int32
	t16 = t13 - t15                                                   int32
	t17 = t12 - t16                                                   int32
	t18 = t17 < 0:int32                                                bool
	if t18 goto 5 else 6
5:                                                              if.then P:1 S:1
	jump 6
6:                                                              if.done P:2 S:1
	t19 = phi [4: t17, 5: 0:int32] #next                              int32
	t20 = &t1.next_sample [#0]                                       *int32
	*t20 = t19
	jump 2

# Name: runtime.gogc
# Package: runtime
# Location: /usr/local/go/src/runtime/malloc.go:413:6
func gogc(force int32):
0:                                                                entry P:0 S:2
	t0 = acquirem()                                                      *m
	t1 = getg()                                                          *g
	t2 = &t0.g0 [#0]                                                    **g
	t3 = *t2                                                             *g
	t4 = t1 == t3                                                      bool
	if t4 goto 1 else 6
1:                                                              if.then P:5 S:0
	t5 = releasem(t0)                                                    ()
	return
2:                                                              if.done P:1 S:2
	t6 = releasem(t0)                                                    ()
	t7 = semacquire(worldsema, false:bool)                               ()
	t8 = force == 0:int32                                              bool
	if t8 goto 9 else 8
3:                                                           cond.false P:1 S:2
	t9 = *gcpercent                                                   int32
	t10 = t9 < 0:int32                                                 bool
	if t10 goto 1 else 2
4:                                                           cond.false P:1 S:2
	t11 = *panicking                                                 uint32
	t12 = t11 != 0:uint32                                              bool
	if t12 goto 1 else 3
5:                                                           cond.false P:1 S:2
	t13 = &memstats.enablegc [#27]                                    *bool
	t14 = *t13                                                         bool
	if t14 goto 4 else 1
6:                                                           cond.false P:1 S:2
	t15 = &t0.locks [#14]                                            *int32
	t16 = *t15                                                        int32
	t17 = t16 > 1:int32                                                bool
	if t17 goto 1 else 5
7:                                                              if.then P:1 S:0
	t18 = semrelease(worldsema)                                          ()
	return
8:                                                              if.done P:2 S:2
	t19 = nanotime()                                                  int64
	t20 = acquirem()                                                     *m
	t21 = &t20.gcing [#13]                                           *int32
	*t21 = 1:int32
	t22 = releasem(t20)                                                  ()
	t23 = onM(stoptheworld)                                              ()
	t24 = acquirem()                                                     *m
	t25 = t20 != t24                                                   bool
	if t25 goto 10 else 11
9:                                                            cond.true P:1 S:2
	t26 = &memstats.heap_alloc [#6]                                 *uint64
	t27 = *t26                                                       uint64
	t28 = &memstats.next_gc [#21]                                   *uint64
	t29 = *t28                                                       uint64
	t30 = t27 < t29                                                    bool
	if t30 goto 7 else 8
10:                                                             if.then P:1 S:1
	t31 = gothrow("gogc: rescheduled":string)                            ()
	jump 11
11:                                                             if.done P:2 S:2
	t32 = clearpools()                                                   ()
	t33 = &debug.gctrace [#2]                                        *int32
	t34 = *t33                                                        int32
	t35 = t34 > 1:int32                                                bool
	if t35 goto 12 else 13
12:                                                             if.then P:1 S:1
	jump 13
13:                                                             if.done P:2 S:1
	t36 = phi [11: 1:int, 12: 2:int] #n                                 int
	jump 16
14:                                                            for.body P:1 S:2
	t37 = t43 > 0:int                                                  bool
	if t37 goto 17 else 18
15:                                                            for.done P:1 S:2
	t38 = &t20.gcing [#13]                                           *int32
	*t38 = 0:int32
	t39 = semrelease(worldsema)                                          ()
	t40 = onM(starttheworld)                                             ()
	t41 = releasem(t20)                                                  ()
	if true:untyped bool goto 23 else 22
16:                                                            for.loop P:2 S:2
	t42 = phi [13: t19, 20: t46] #startTime                           int64
	t43 = phi [13: 0:int, 20: t59] #i                                   int
	t44 = t43 < t36                                                    bool
	if t44 goto 14 else 15
17:                                                             if.then P:1 S:1
	t45 = nanotime()                                                  int64
	jump 18
18:                                                             if.done P:2 S:2
	t46 = phi [14: t42, 17: t45] #startTime                           int64
	t47 = &t20.scalararg [#45]                                  *[4]uintptr
	t48 = &t47[0:int]                                              *uintptr
	t49 = convert uint32 <- int64 (t46)                              uint32
	t50 = convert uintptr <- uint32 (t49)                           uintptr
	*t48 = t50
	t51 = &t20.scalararg [#45]                                  *[4]uintptr
	t52 = &t51[1:int]                                              *uintptr
	t53 = t46 >> 32:uint64                                            int64
	t54 = convert uintptr <- int64 (t53)                            uintptr
	*t52 = t54
	t55 = force >= 2:int32                                             bool
	if t55 goto 19 else 21
19:                                                             if.then P:1 S:1
	t56 = &t20.scalararg [#45]                                  *[4]uintptr
	t57 = &t56[2:int]                                              *uintptr
	*t57 = 1:uintptr
	jump 20
20:                                                             if.done P:2 S:1
	t58 = onM(gc_m)                                                      ()
	t59 = t43 + 1:int                                                   int
	jump 16
21:                                                             if.else P:1 S:1
	t60 = &t20.scalararg [#45]                                  *[4]uintptr
	t61 = &t60[2:int]                                              *uintptr
	*t61 = 0:uintptr
	jump 20
22:                                                             if.then P:1 S:1
	t62 = Gosched()                                                      ()
	jump 23
23:                                                             if.done P:2 S:0
	return

# Name: runtime.GC
# Package: runtime
# Location: /usr/local/go/src/runtime/malloc.go:487:6
func GC():
0:                                                                entry P:0 S:0
	t0 = gogc(2:int32)                                                   ()
	return

# Name: runtime.SetFinalizer
# Package: runtime
# Location: /usr/local/go/src/runtime/malloc.go:543:6
func SetFinalizer(obj interface{}, finalizer interface{}):
0:                                                                entry P:0 S:2
	t0 = new interface{} (obj)                                 *interface{}
	*t0 = obj
	t1 = new interface{} (finalizer)                           *interface{}
	*t1 = finalizer
	t2 = convert unsafe.Pointer <- *interface{} (t0)         unsafe.Pointer
	t3 = convert *eface <- unsafe.Pointer (t2)                       *eface
	t4 = &t3._type [#0]                                             **_type
	t5 = *t4                                                         *_type
	t6 = t5 == nil:*_type                                              bool
	if t6 goto 1 else 2
1:                                                              if.then P:1 S:1
	t7 = gothrow("runtime.SetFinali...":string)                          ()
	jump 2
2:                                                              if.done P:2 S:2
	t8 = &t5.kind [#5]                                               *uint8
	t9 = *t8                                                          uint8
	t10 = t9 & 31:uint8                                               uint8
	t11 = t10 != 22:uint8                                              bool
	if t11 goto 3 else 4
3:                                                              if.then P:1 S:1
	t12 = &t5._string [#8]                                         **string
	t13 = *t12                                                      *string
	t14 = *t13                                                       string
	t15 = "runtime.SetFinali...":string + t14                        string
	t16 = t15 + ", not pointer":string                               string
	t17 = gothrow(t16)                                                   ()
	jump 4
4:                                                              if.done P:2 S:2
	t18 = convert unsafe.Pointer <- *_type (t5)              unsafe.Pointer
	t19 = convert *ptrtype <- unsafe.Pointer (t18)                 *ptrtype
	t20 = &t19.elem [#1]                                            **_type
	t21 = *t20                                                       *_type
	t22 = t21 == nil:*_type                                            bool
	if t22 goto 5 else 6
5:                                                              if.then P:1 S:1
	t23 = gothrow("nil elem type!":string)                               ()
	jump 6
6:                                                              if.done P:2 S:2
	t24 = &t3.data [#1]                                     *unsafe.Pointer
	t25 = *t24                                               unsafe.Pointer
	t26 = findObject(t25)           (s *mspan, x unsafe.Pointer, n uintptr)
	t27 = extract t26 #0                                             *mspan
	t28 = extract t26 #1                                     unsafe.Pointer
	t29 = extract t26 #2                                            uintptr
	t30 = t28 == nil:unsafe.Pointer                                    bool
	if t30 goto 7 else 8
7:                                                              if.then P:1 S:2
	t31 = &t3.data [#1]                                     *unsafe.Pointer
	t32 = *t31                                               unsafe.Pointer
	t33 = convert unsafe.Pointer <- *uintptr (zerobase)      unsafe.Pointer
	t34 = t32 == t33                                                   bool
	if t34 goto 9 else 10
8:                                                              if.done P:2 S:2
	t35 = &t3.data [#1]                                     *unsafe.Pointer
	t36 = *t35                                               unsafe.Pointer
	t37 = t36 != t28                                                   bool
	if t37 goto 20 else 21
9:                                                              if.then P:1 S:0
	return
10:                                                             if.done P:1 S:2
	t38 = convert unsafe.Pointer <- *struct{} (noptrdata)    unsafe.Pointer
	t39 = convert uintptr <- unsafe.Pointer (t38)                   uintptr
	t40 = &t3.data [#1]                                     *unsafe.Pointer
	t41 = *t40                                               unsafe.Pointer
	t42 = convert uintptr <- unsafe.Pointer (t41)                   uintptr
	t43 = t39 <= t42                                                   bool
	if t43 goto 16 else 15
11:                                                             if.then P:4 S:0
	return
12:                                                             if.done P:2 S:1
	t44 = gothrow("runtime.SetFinali...":string)                         ()
	jump 8
13:                                                          cond.false P:2 S:2
	t45 = convert unsafe.Pointer <- *struct{} (noptrbss)     unsafe.Pointer
	t46 = convert uintptr <- unsafe.Pointer (t45)                   uintptr
	t47 = &t3.data [#1]                                     *unsafe.Pointer
	t48 = *t47                                               unsafe.Pointer
	t49 = convert uintptr <- unsafe.Pointer (t48)                   uintptr
	t50 = t46 <= t49                                                   bool
	if t50 goto 19 else 12
14:                                                          cond.false P:2 S:2
	t51 = convert unsafe.Pointer <- *[0]byte (bss)           unsafe.Pointer
	t52 = convert uintptr <- unsafe.Pointer (t51)                   uintptr
	t53 = &t3.data [#1]                                     *unsafe.Pointer
	t54 = *t53                                               unsafe.Pointer
	t55 = convert uintptr <- unsafe.Pointer (t54)                   uintptr
	t56 = t52 <= t55                                                   bool
	if t56 goto 18 else 13
15:                                                          cond.false P:2 S:2
	t57 = convert unsafe.Pointer <- *[0]byte (data)          unsafe.Pointer
	t58 = convert uintptr <- unsafe.Pointer (t57)                   uintptr
	t59 = &t3.data [#1]                                     *unsafe.Pointer
	t60 = *t59                                               unsafe.Pointer
	t61 = convert uintptr <- unsafe.Pointer (t60)                   uintptr
	t62 = t58 <= t61                                                   bool
	if t62 goto 17 else 14
16:                                                           cond.true P:1 S:2
	t63 = &t3.data [#1]                                     *unsafe.Pointer
	t64 = *t63                                               unsafe.Pointer
	t65 = convert uintptr <- unsafe.Pointer (t64)                   uintptr
	t66 = convert unsafe.Pointer <- *struct{} (enoptrdata)   unsafe.Pointer
	t67 = convert uintptr <- unsafe.Pointer (t66)                   uintptr
	t68 = t65 < t67                                                    bool
	if t68 goto 11 else 15
17:                                                           cond.true P:1 S:2
	t69 = &t3.data [#1]                                     *unsafe.Pointer
	t70 = *t69                                               unsafe.Pointer
	t71 = convert uintptr <- unsafe.Pointer (t70)                   uintptr
	t72 = convert unsafe.Pointer <- *[0]byte (edata)         unsafe.Pointer
	t73 = convert uintptr <- unsafe.Pointer (t72)                   uintptr
	t74 = t71 < t73                                                    bool
	if t74 goto 11 else 14
18:                                                           cond.true P:1 S:2
	t75 = &t3.data [#1]                                     *unsafe.Pointer
	t76 = *t75                                               unsafe.Pointer
	t77 = convert uintptr <- unsafe.Pointer (t76)                   uintptr
	t78 = convert unsafe.Pointer <- *[0]byte (ebss)          unsafe.Pointer
	t79 = convert uintptr <- unsafe.Pointer (t78)                   uintptr
	t80 = t77 < t79                                                    bool
	if t80 goto 11 else 13
19:                                                           cond.true P:1 S:2
	t81 = &t3.data [#1]                                     *unsafe.Pointer
	t82 = *t81                                               unsafe.Pointer
	t83 = convert uintptr <- unsafe.Pointer (t82)                   uintptr
	t84 = convert unsafe.Pointer <- *struct{} (enoptrbss)    unsafe.Pointer
	t85 = convert uintptr <- unsafe.Pointer (t84)                   uintptr
	t86 = t83 < t85                                                    bool
	if t86 goto 11 else 12
20:                                                             if.then P:1 S:2
	t87 = &t19.elem [#1]                                            **_type
	t88 = *t87                                                       *_type
	t89 = t88 == nil:*_type                                            bool
	if t89 goto 22 else 24
21:                                                             if.done P:3 S:2
	t90 = convert unsafe.Pointer <- *interface{} (t1)        unsafe.Pointer
	t91 = convert *eface <- unsafe.Pointer (t90)                     *eface
	t92 = &t91._type [#0]                                           **_type
	t93 = *t92                                                       *_type
	t94 = t93 == nil:*_type                                            bool
	if t94 goto 25 else 26
22:                                                             if.then P:3 S:1
	t95 = gothrow("runtime.SetFinali...":string)                         ()
	jump 21
23:                                                          cond.false P:1 S:2
	t96 = &t19.elem [#1]                                            **_type
	t97 = *t96                                                       *_type
	t98 = &t97.size [#0]                                           *uintptr
	t99 = *t98                                                      uintptr
	t100 = t99 >= 16:uintptr                                           bool
	if t100 goto 22 else 21
24:                                                          cond.false P:1 S:2
	t101 = &t19.elem [#1]                                           **_type
	t102 = *t101                                                     *_type
	t103 = &t102.kind [#5]                                           *uint8
	t104 = *t103                                                      uint8
	t105 = t104 & 128:uint8                                           uint8
	t106 = t105 == 0:uint8                                             bool
	if t106 goto 22 else 23
25:                                                             if.then P:1 S:0
	t107 = acquirem()                                                    *m
	t108 = &t107.ptrarg [#46]                            *[4]unsafe.Pointer
	t109 = &t108[0:int]                                     *unsafe.Pointer
	t110 = &t3.data [#1]                                    *unsafe.Pointer
	t111 = *t110                                             unsafe.Pointer
	*t109 = t111
	t112 = onM(removeFinalizer_m)                                        ()
	t113 = releasem(t107)                                                ()
	return
26:                                                             if.done P:1 S:2
	t114 = &t93.kind [#5]                                            *uint8
	t115 = *t114                                                      uint8
	t116 = t115 & 31:uint8                                            uint8
	t117 = t116 != 19:uint8                                            bool
	if t117 goto 27 else 28
27:                                                             if.then P:1 S:1
	t118 = &t93._string [#8]                                       **string
	t119 = *t118                                                    *string
	t120 = *t119                                                     string
	t121 = "runtime.SetFinali...":string + t120                      string
	t122 = t121 + ", not a function":string                          string
	t123 = gothrow(t122)                                                 ()
	jump 28
28:                                                             if.done P:2 S:2
	t124 = convert unsafe.Pointer <- *_type (t93)            unsafe.Pointer
	t125 = convert *functype <- unsafe.Pointer (t124)             *functype
	t126 = &t125.in [#2]                                            *[]byte
	t127 = convert unsafe.Pointer <- *[]byte (t126)          unsafe.Pointer
	t128 = convert *[]*_type <- unsafe.Pointer (t127)             *[]*_type
	t129 = *t128                                                   []*_type
	t130 = &t125.dotdotdot [#1]                                       *bool
	t131 = *t130                                                       bool
	if t131 goto 29 else 31
29:                                                             if.then P:2 S:1
	t132 = &t5._string [#8]                                        **string
	t133 = *t132                                                    *string
	t134 = *t133                                                     string
	t135 = "runtime.SetFinali...":string + t134                      string
	t136 = t135 + " to finalizer ":string                            string
	t137 = &t93._string [#8]                                       **string
	t138 = *t137                                                    *string
	t139 = *t138                                                     string
	t140 = t136 + t139                                               string
	t141 = gothrow(t140)                                                 ()
	jump 30
30:                                                             if.done P:2 S:2
	t142 = &t129[0:int]                                             **_type
	t143 = *t142                                                     *_type
	t144 = t143 == t5                                                  bool
	if t144 goto 35 else 34
31:                                                          cond.false P:1 S:2
	t145 = len(t129)                                                    int
	t146 = t145 != 1:int                                               bool
	if t146 goto 29 else 30
32:                                                         switch.done P:4 S:1
	t147 = phi [39: nil:*interfacetype, 42: t172, 37: nil:*interfacetype, 38: nil:*interfacetype] #ityp *interfacetype
	t148 = phi [39: false:bool, 42: t204, 37: false:bool, 38: false:bool] #ok bool
	t149 = &t5._string [#8]                                        **string
	t150 = *t149                                                    *string
	t151 = *t150                                                     string
	t152 = "runtime.SetFinali...":string + t151                      string
	t153 = t152 + " to finalizer ":string                            string
	t154 = &t93._string [#8]                                       **string
	t155 = *t154                                                    *string
	t156 = *t155                                                     string
	t157 = t153 + t156                                               string
	t158 = gothrow(t157)                                                 ()
	jump 35
33:                                                         switch.body P:1 S:2
	t159 = &t143.x [#9]                                      **uncommontype
	t160 = *t159                                              *uncommontype
	t161 = t160 == nil:*uncommontype                                   bool
	if t161 goto 38 else 41
34:                                                         switch.next P:1 S:2
	t162 = &t143.kind [#5]                                           *uint8
	t163 = *t162                                                      uint8
	t164 = t163 & 31:uint8                                            uint8
	t165 = t164 == 22:uint8                                            bool
	if t165 goto 33 else 37
35:                                                               okarg P:5 S:1
	t166 = &t125.out [#3]                                           *[]byte
	t167 = convert unsafe.Pointer <- *[]byte (t166)          unsafe.Pointer
	t168 = convert *[]*_type <- unsafe.Pointer (t167)             *[]*_type
	t169 = *t168                                                   []*_type
	t170 = len(t169)                                                    int
	jump 43
36:                                                         switch.body P:1 S:2
	t171 = convert unsafe.Pointer <- *_type (t143)           unsafe.Pointer
	t172 = convert *interfacetype <- unsafe.Pointer (t171)   *interfacetype
	t173 = &t172.mhdr [#1]                                          *[]byte
	t174 = *t173                                                     []byte
	t175 = len(t174)                                                    int
	t176 = t175 == 0:int                                               bool
	if t176 goto 35 else 42
37:                                                         switch.next P:1 S:2
	t177 = &t143.kind [#5]                                           *uint8
	t178 = *t177                                                      uint8
	t179 = t178 & 31:uint8                                            uint8
	t180 = t179 == 20:uint8                                            bool
	if t180 goto 36 else 32
38:                                                           cond.true P:4 S:2
	t181 = convert unsafe.Pointer <- *_type (t143)           unsafe.Pointer
	t182 = convert *ptrtype <- unsafe.Pointer (t181)               *ptrtype
	t183 = &t182.elem [#1]                                          **_type
	t184 = *t183                                                     *_type
	t185 = &t19.elem [#1]                                           **_type
	t186 = *t185                                                     *_type
	t187 = t184 == t186                                                bool
	if t187 goto 35 else 32
39:                                                          cond.false P:1 S:2
	t188 = &t5.x [#9]                                        **uncommontype
	t189 = *t188                                              *uncommontype
	t190 = &t189.name [#0]                                         **string
	t191 = *t190                                                    *string
	t192 = t191 == nil:*string                                         bool
	if t192 goto 38 else 32
40:                                                          cond.false P:1 S:2
	t193 = &t5.x [#9]                                        **uncommontype
	t194 = *t193                                              *uncommontype
	t195 = t194 == nil:*uncommontype                                   bool
	if t195 goto 38 else 39
41:                                                          cond.false P:1 S:2
	t196 = &t143.x [#9]                                      **uncommontype
	t197 = *t196                                              *uncommontype
	t198 = &t197.name [#0]                                         **string
	t199 = *t198                                                    *string
	t200 = t199 == nil:*string                                         bool
	if t200 goto 38 else 40
42:                                                             if.done P:1 S:2
	t201 = *t0                                                  interface{}
	t202 = assertE2I2(t172, t201)                   (r fInterface, ok bool)
	t203 = extract t202 #0                                       fInterface
	t204 = extract t202 #1                                             bool
	if t204 goto 35 else 32
43:                                                     rangeindex.loop P:2 S:2
	t205 = phi [35: 0:uintptr, 44: t217] #nret                      uintptr
	t206 = phi [35: -1:int, 44: t207]                                   int
	t207 = t206 + 1:int                                                 int
	t208 = t207 < t170                                                 bool
	if t208 goto 44 else 45
44:                                                     rangeindex.body P:1 S:1
	t209 = &t169[t207]                                              **_type
	t210 = *t209                                                     *_type
	t211 = &t210.align [#3]                                          *uint8
	t212 = *t211                                                      uint8
	t213 = convert uintptr <- uint8 (t212)                          uintptr
	t214 = round(t205, t213)                                        uintptr
	t215 = &t210.size [#0]                                         *uintptr
	t216 = *t215                                                    uintptr
	t217 = t214 + t216                                              uintptr
	jump 43
45:                                                     rangeindex.done P:1 S:2
	t218 = round(t205, 8:uintptr)                                   uintptr
	t219 = createfing()                                                  ()
	t220 = acquirem()                                                    *m
	t221 = &t220.ptrarg [#46]                            *[4]unsafe.Pointer
	t222 = &t221[0:int]                                     *unsafe.Pointer
	t223 = &t91.data [#1]                                   *unsafe.Pointer
	t224 = *t223                                             unsafe.Pointer
	*t222 = t224
	t225 = &t220.ptrarg [#46]                            *[4]unsafe.Pointer
	t226 = &t225[1:int]                                     *unsafe.Pointer
	t227 = &t3.data [#1]                                    *unsafe.Pointer
	t228 = *t227                                             unsafe.Pointer
	*t226 = t228
	t229 = &t220.scalararg [#45]                                *[4]uintptr
	t230 = &t229[0:int]                                            *uintptr
	*t230 = t218
	t231 = &t220.ptrarg [#46]                            *[4]unsafe.Pointer
	t232 = &t231[2:int]                                     *unsafe.Pointer
	t233 = convert unsafe.Pointer <- *_type (t143)           unsafe.Pointer
	*t232 = t233
	t234 = &t220.ptrarg [#46]                            *[4]unsafe.Pointer
	t235 = &t234[3:int]                                     *unsafe.Pointer
	t236 = convert unsafe.Pointer <- *ptrtype (t19)          unsafe.Pointer
	*t235 = t236
	t237 = onM(setFinalizer_m)                                           ()
	t238 = &t220.scalararg [#45]                                *[4]uintptr
	t239 = &t238[0:int]                                            *uintptr
	t240 = *t239                                                    uintptr
	t241 = t240 != 1:uintptr                                           bool
	if t241 goto 46 else 47
46:                                                             if.then P:1 S:1
	t242 = gothrow("runtime.SetFinali...":string)                        ()
	jump 47
47:                                                             if.done P:2 S:0
	t243 = releasem(t220)                                                ()
	return

# Name: runtime.round
# Package: runtime
# Location: /usr/local/go/src/runtime/malloc.go:658:6
func round(n uintptr, a uintptr) uintptr:
0:                                                                entry P:0 S:0
	t0 = n + a                                                      uintptr
	t1 = t0 - 1:uintptr                                             uintptr
	t2 = a - 1:uintptr                                              uintptr
	t3 = t1 &^ t2                                                   uintptr
	return t3

# Name: runtime.findObject
# Package: runtime
# Location: /usr/local/go/src/runtime/malloc.go:665:6
func findObject(v unsafe.Pointer) (s *mspan, x unsafe.Pointer, n uintptr):
0:                                                                entry P:0 S:2
	t0 = gomcache()                                                 *mcache
	t1 = &t0.local_nlookup [#9]                                    *uintptr
	t2 = *t1                                                        uintptr
	t3 = t2 + 1:uintptr                                             uintptr
	*t1 = t3
	if false:untyped bool goto 3 else 2
1:                                                              if.then P:1 S:1
	t4 = &mheap_.lock [#0]                                           *mutex
	t5 = lock(t4)                                                        ()
	t6 = purgecachedstats(t0)                                            ()
	t7 = &mheap_.lock [#0]                                           *mutex
	t8 = unlock(t7)                                                      ()
	jump 2
2:                                                              if.done P:3 S:2
	t9 = &mheap_.arena_start [#15]                                   **byte
	t10 = *t9                                                         *byte
	t11 = convert unsafe.Pointer <- *byte (t10)              unsafe.Pointer
	t12 = convert uintptr <- unsafe.Pointer (t11)                   uintptr
	t13 = &mheap_.arena_used [#16]                                   **byte
	t14 = *t13                                                        *byte
	t15 = convert unsafe.Pointer <- *byte (t14)              unsafe.Pointer
	t16 = convert uintptr <- unsafe.Pointer (t15)                   uintptr
	t17 = convert uintptr <- unsafe.Pointer (v)                     uintptr
	t18 = t17 < t12                                                    bool
	if t18 goto 4 else 6
3:                                                            cond.true P:1 S:2
	t19 = &t0.local_nlookup [#9]                                   *uintptr
	t20 = *t19                                                      uintptr
	t21 = t20 >= 1073741824:uintptr                                    bool
	if t21 goto 1 else 2
4:                                                              if.then P:2 S:0
	return nil:*mspan, nil:unsafe.Pointer, 0:uintptr
5:                                                              if.done P:1 S:2
	t22 = convert uintptr <- unsafe.Pointer (v)                     uintptr
	t23 = t22 >> 13:uint64                                          uintptr
	t24 = t12 >> 13:uint64                                          uintptr
	t25 = t23 - t24                                                 uintptr
	t26 = &mheap_.spans [#11]                                      ***mspan
	t27 = *t26                                                      **mspan
	t28 = convert unsafe.Pointer <- **mspan (t27)            unsafe.Pointer
	t29 = t25 * 8:uintptr                                           uintptr
	t30 = add(t28, t29)                                      unsafe.Pointer
	t31 = convert **mspan <- unsafe.Pointer (t30)                   **mspan
	t32 = *t31                                                       *mspan
	t33 = t32 == nil:*mspan                                            bool
	if t33 goto 7 else 8
6:                                                           cond.false P:1 S:2
	t34 = convert uintptr <- unsafe.Pointer (v)                     uintptr
	t35 = t34 >= t16                                                   bool
	if t35 goto 4 else 5
7:                                                              if.then P:1 S:0
	return t32, nil:unsafe.Pointer, 0:uintptr
8:                                                              if.done P:1 S:2
	t36 = &t32.start [#2]                                           *pageID
	t37 = *t36                                                       pageID
	t38 = changetype uintptr <- pageID (t37)                        uintptr
	t39 = t38 << 13:uint64                                          uintptr
	t40 = convert unsafe.Pointer <- uintptr (t39)            unsafe.Pointer
	t41 = convert uintptr <- unsafe.Pointer (v)                     uintptr
	t42 = convert uintptr <- unsafe.Pointer (t40)                   uintptr
	t43 = t41 < t42                                                    bool
	if t43 goto 9 else 12
9:                                                              if.then P:3 S:0
	return nil:*mspan, nil:unsafe.Pointer, 0:uintptr
10:                                                             if.done P:1 S:2
	t44 = &t32.elemsize [#11]                                      *uintptr
	t45 = *t44                                                      uintptr
	t46 = &t32.sizeclass [#7]                                        *uint8
	t47 = *t46                                                        uint8
	t48 = t47 != 0:uint8                                               bool
	if t48 goto 13 else 14
11:                                                          cond.false P:1 S:2
	t49 = &t32.state [#9]                                            *uint8
	t50 = *t49                                                        uint8
	t51 = t50 != 0:uint8                                               bool
	if t51 goto 9 else 10
12:                                                          cond.false P:1 S:2
	t52 = convert uintptr <- unsafe.Pointer (v)                     uintptr
	t53 = &t32.limit [#14]                                           **byte
	t54 = *t53                                                        *byte
	t55 = convert unsafe.Pointer <- *byte (t54)              unsafe.Pointer
	t56 = convert uintptr <- unsafe.Pointer (t55)                   uintptr
	t57 = t52 >= t56                                                   bool
	if t57 goto 9 else 11
13:                                                             if.then P:1 S:1
	t58 = convert uintptr <- unsafe.Pointer (v)                     uintptr
	t59 = convert uintptr <- unsafe.Pointer (t40)                   uintptr
	t60 = t58 - t59                                                 uintptr
	t61 = t60 / t45                                                 uintptr
	t62 = t61 * t45                                                 uintptr
	t63 = add(t40, t62)                                      unsafe.Pointer
	jump 14
14:                                                             if.done P:2 S:0
	t64 = phi [10: t40, 13: t63] #x                          unsafe.Pointer
	return t32, t64, t45

# Name: runtime.createfing
# Package: runtime
# Location: /usr/local/go/src/runtime/malloc.go:704:6
func createfing():
0:                                                                entry P:0 S:2
	t0 = *fingCreate                                                 uint32
	t1 = t0 == 0:uint32                                                bool
	if t1 goto 3 else 2
1:                                                              if.then P:1 S:1
	go runfinq()
	jump 2
2:                                                              if.done P:3 S:0
	return
3:                                                            cond.true P:1 S:2
	t2 = cas(fingCreate, 0:uint32, 1:uint32)                           bool
	if t2 goto 1 else 2

# Name: runtime.runfinq
# Package: runtime
# Location: /usr/local/go/src/runtime/malloc.go:712:6
func runfinq():
0:                                                                entry P:0 S:1
	jump 1
1:                                                             for.body P:3 S:2
	t0 = phi [0: nil:unsafe.Pointer, 2: t0, 6: t16] #frame   unsafe.Pointer
	t1 = phi [0: 0:uintptr, 2: t1, 6: t17] #framecap                uintptr
	t2 = phi [0: 0:int32, 2: t2, 6: t19] #i                           int32
	t3 = phi [0: nil:*finalizer, 2: t3, 6: t20] #f               *finalizer
	t4 = phi [0: 0:uintptr, 2: t4, 6: t21] #framesz                 uintptr
	t5 = phi [0: nil:*finblock, 2: t5, 6: t22] #next              *finblock
	t6 = phi [0: nil:*interfacetype, 2: t6, 6: t23] #ityp    *interfacetype
	t7 = lock(finlock)                                                   ()
	t8 = *finq                                                    *finblock
	*finq = nil:*finblock
	t9 = t8 == nil:*finblock                                           bool
	if t9 goto 2 else 3
2:                                                              if.then P:1 S:1
	t10 = getg()                                                         *g
	*fing = t10
	*fingwait = true:bool
	t11 = &t10.issystem [#14]                                         *bool
	*t11 = true:bool
	t12 = goparkunlock(finlock, "finalizer wait":string)                 ()
	t13 = &t10.issystem [#14]                                         *bool
	*t13 = false:bool
	jump 1
3:                                                              if.done P:1 S:2
	t14 = unlock(finlock)                                                ()
	if false:untyped bool goto 4 else 6
4:                                                              if.then P:1 S:1
	t15 = racefingo()                                                    ()
	jump 6
5:                                                             for.body P:1 S:1
	jump 9
6:                                                             for.loop P:3 S:2
	t16 = phi [3: t0, 8: t42, 4: t0] #frame                  unsafe.Pointer
	t17 = phi [3: t1, 8: t43, 4: t1] #framecap                      uintptr
	t18 = phi [3: t8, 8: t37, 4: t8] #fb                          *finblock
	t19 = phi [3: t2, 8: t44, 4: t2] #i                               int32
	t20 = phi [3: t3, 8: t45, 4: t3] #f                          *finalizer
	t21 = phi [3: t4, 8: t46, 4: t4] #framesz                       uintptr
	t22 = phi [3: t5, 8: t37, 4: t5] #next                        *finblock
	t23 = phi [3: t6, 8: t47, 4: t6] #ityp                   *interfacetype
	t24 = t18 != nil:*finblock                                         bool
	if t24 goto 5 else 1
7:                                                             for.body P:1 S:2
	t25 = &t18.fin [#4]                                       *[1]finalizer
	t26 = convert unsafe.Pointer <- *[1]finalizer (t25)      unsafe.Pointer
	t27 = convert uintptr <- int32 (t44)                            uintptr
	t28 = t27 * 40:uintptr                                          uintptr
	t29 = add(t26, t28)                                      unsafe.Pointer
	t30 = convert *finalizer <- unsafe.Pointer (t29)             *finalizer
	t31 = &t30.nret [#2]                                           *uintptr
	t32 = *t31                                                      uintptr
	t33 = 16:uintptr + t32                                          uintptr
	t34 = t43 < t33                                                    bool
	if t34 goto 10 else 11
8:                                                             for.done P:1 S:1
	t35 = &t18.cnt [#2]                                              *int32
	*t35 = 0:int32
	t36 = &t18.next [#1]                                         **finblock
	t37 = *t36                                                    *finblock
	t38 = lock(finlock)                                                  ()
	t39 = &t18.next [#1]                                         **finblock
	t40 = *finc                                                   *finblock
	*t39 = t40
	*finc = t18
	t41 = unlock(finlock)                                                ()
	jump 6
9:                                                             for.loop P:2 S:2
	t42 = phi [5: t16, 14: t52] #frame                       unsafe.Pointer
	t43 = phi [5: t17, 14: t53] #framecap                           uintptr
	t44 = phi [5: 0:int32, 14: t74] #i                                int32
	t45 = phi [5: t20, 14: t30] #f                               *finalizer
	t46 = phi [5: t21, 14: t33] #framesz                            uintptr
	t47 = phi [5: t23, 14: t64] #ityp                        *interfacetype
	t48 = &t18.cnt [#2]                                              *int32
	t49 = *t48                                                        int32
	t50 = t44 < t49                                                    bool
	if t50 goto 7 else 8
10:                                                             if.then P:1 S:1
	t51 = mallocgc(t33, nil:*_type, 1:uint32)                unsafe.Pointer
	jump 11
11:                                                             if.done P:2 S:2
	t52 = phi [7: t42, 10: t51] #frame                       unsafe.Pointer
	t53 = phi [7: t43, 10: t33] #framecap                           uintptr
	t54 = &t30.fint [#3]                                            **_type
	t55 = *t54                                                       *_type
	t56 = t55 == nil:*_type                                            bool
	if t56 goto 12 else 13
12:                                                             if.then P:1 S:1
	t57 = gothrow("missing type in r...":string)                         ()
	jump 13
13:                                                             if.done P:2 S:2
	t58 = &t30.fint [#3]                                            **_type
	t59 = *t58                                                       *_type
	t60 = &t59.kind [#5]                                             *uint8
	t61 = *t60                                                        uint8
	t62 = t61 & 31:uint8                                              uint8
	t63 = t62 == 22:uint8                                              bool
	if t63 goto 15 else 17
14:                                                         switch.done P:4 S:1
	t64 = phi [15: t47, 16: t81, 18: t47, 19: t81] #ityp     *interfacetype
	t65 = &t30.fn [#0]                                            **funcval
	t66 = *t65                                                     *funcval
	t67 = convert unsafe.Pointer <- *funcval (t66)           unsafe.Pointer
	t68 = convert uint32 <- uintptr (t33)                            uint32
	t69 = convert uint32 <- uintptr (t33)                            uint32
	t70 = reflectcall(t67, t52, t68, t69)                                ()
	t71 = &t30.fn [#0]                                            **funcval
	*t71 = nil:*funcval
	t72 = &t30.arg [#1]                                     *unsafe.Pointer
	*t72 = nil:unsafe.Pointer
	t73 = &t30.ot [#4]                                            **ptrtype
	*t73 = nil:*ptrtype
	t74 = t44 + 1:int32                                               int32
	jump 9
15:                                                         switch.body P:1 S:1
	t75 = convert *unsafe.Pointer <- unsafe.Pointer (t52)   *unsafe.Pointer
	t76 = &t30.arg [#1]                                     *unsafe.Pointer
	t77 = *t76                                               unsafe.Pointer
	*t75 = t77
	jump 14
16:                                                         switch.body P:1 S:2
	t78 = &t30.fint [#3]                                            **_type
	t79 = *t78                                                       *_type
	t80 = convert unsafe.Pointer <- *_type (t79)             unsafe.Pointer
	t81 = convert *interfacetype <- unsafe.Pointer (t80)     *interfacetype
	t82 = convert *eface <- unsafe.Pointer (t52)                     *eface
	t83 = &t82._type [#0]                                           **_type
	t84 = &t30.ot [#4]                                            **ptrtype
	t85 = *t84                                                     *ptrtype
	t86 = &t85.typ [#0]                                              *_type
	*t83 = t86
	t87 = convert *eface <- unsafe.Pointer (t52)                     *eface
	t88 = &t87.data [#1]                                    *unsafe.Pointer
	t89 = &t30.arg [#1]                                     *unsafe.Pointer
	t90 = *t89                                               unsafe.Pointer
	*t88 = t90
	t91 = &t81.mhdr [#1]                                            *[]byte
	t92 = *t91                                                       []byte
	t93 = len(t92)                                                      int
	t94 = t93 != 0:int                                                 bool
	if t94 goto 19 else 14
17:                                                         switch.next P:1 S:2
	t95 = t62 == 20:uint8                                              bool
	if t95 goto 16 else 18
18:                                                         switch.next P:1 S:1
	t96 = gothrow("bad kind in runfinq":string)                          ()
	jump 14
19:                                                             if.then P:1 S:1
	t97 = convert *fInterface <- unsafe.Pointer (t52)           *fInterface
	t98 = convert *interface{} <- unsafe.Pointer (t52)         *interface{}
	t99 = *t98                                                  interface{}
	t100 = assertE2I(t81, t99)                                   fInterface
	*t97 = t100
	jump 14

# Name: runtime.persistentalloc
# Package: runtime
# Location: /usr/local/go/src/runtime/malloc.go:797:6
func persistentalloc(size uintptr, align uintptr, stat *uint64) unsafe.Pointer:
0:                                                                entry P:0 S:2
	t0 = align != 0:uintptr                                            bool
	if t0 goto 1 else 3
1:                                                              if.then P:1 S:2
	t1 = align - 1:uintptr                                          uintptr
	t2 = align & t1                                                 uintptr
	t3 = t2 != 0:uintptr                                               bool
	if t3 goto 4 else 5
2:                                                              if.done P:3 S:2
	t4 = phi [5: align, 3: 8:uintptr, 6: align] #align              uintptr
	t5 = size >= 65536:uintptr                                         bool
	if t5 goto 7 else 8
3:                                                              if.else P:1 S:1
	jump 2
4:                                                              if.then P:1 S:1
	t6 = gothrow("persistentalloc: ...":string)                          ()
	jump 5
5:                                                              if.done P:2 S:2
	t7 = align > 8192:uintptr                                          bool
	if t7 goto 6 else 2
6:                                                              if.then P:1 S:1
	t8 = gothrow("persistentalloc: ...":string)                          ()
	jump 2
7:                                                              if.then P:1 S:0
	t9 = sysAlloc(size, stat)                                unsafe.Pointer
	return t9
8:                                                              if.done P:1 S:2
	t10 = &persistent.lock [#0]                                      *mutex
	t11 = lock(t10)                                                      ()
	t12 = &persistent.pos [#1]                              *unsafe.Pointer
	t13 = &persistent.pos [#1]                              *unsafe.Pointer
	t14 = *t13                                               unsafe.Pointer
	t15 = roundup(t14, t4)                                   unsafe.Pointer
	*t12 = t15
	t16 = &persistent.pos [#1]                              *unsafe.Pointer
	t17 = *t16                                               unsafe.Pointer
	t18 = convert uintptr <- unsafe.Pointer (t17)                   uintptr
	t19 = t18 + size                                                uintptr
	t20 = &persistent.end [#2]                              *unsafe.Pointer
	t21 = *t20                                               unsafe.Pointer
	t22 = convert uintptr <- unsafe.Pointer (t21)                   uintptr
	t23 = t19 > t22                                                    bool
	if t23 goto 9 else 10
9:                                                              if.then P:1 S:2
	t24 = &persistent.pos [#1]                              *unsafe.Pointer
	t25 = &memstats.other_sys [#20]                                 *uint64
	t26 = sysAlloc(262144:uintptr, t25)                      unsafe.Pointer
	*t24 = t26
	t27 = &persistent.pos [#1]                              *unsafe.Pointer
	t28 = *t27                                               unsafe.Pointer
	t29 = t28 == nil:unsafe.Pointer                                    bool
	if t29 goto 11 else 12
10:                                                             if.done P:2 S:2
	t30 = &persistent.pos [#1]                              *unsafe.Pointer
	t31 = *t30                                               unsafe.Pointer
	t32 = &persistent.pos [#1]                              *unsafe.Pointer
	t33 = &persistent.pos [#1]                              *unsafe.Pointer
	t34 = *t33                                               unsafe.Pointer
	t35 = add(t34, size)                                     unsafe.Pointer
	*t32 = t35
	t36 = &persistent.lock [#0]                                      *mutex
	t37 = unlock(t36)                                                    ()
	t38 = &memstats.other_sys [#20]                                 *uint64
	t39 = stat != t38                                                  bool
	if t39 goto 13 else 14
11:                                                             if.then P:1 S:1
	t40 = &persistent.lock [#0]                                      *mutex
	t41 = unlock(t40)                                                    ()
	t42 = gothrow("runtime: cannot a...":string)                         ()
	jump 12
12:                                                             if.done P:2 S:1
	t43 = &persistent.end [#2]                              *unsafe.Pointer
	t44 = &persistent.pos [#1]                              *unsafe.Pointer
	t45 = *t44                                               unsafe.Pointer
	t46 = add(t45, 262144:uintptr)                           unsafe.Pointer
	*t43 = t46
	jump 10
13:                                                             if.then P:1 S:1
	t47 = convert int64 <- uintptr (size)                             int64
	t48 = xadd64(stat, t47)                                          uint64
	t49 = &memstats.other_sys [#20]                                 *uint64
	t50 = convert int64 <- uintptr (size)                             int64
	t51 = -t50                                                        int64
	t52 = xadd64(t49, t51)                                           uint64
	jump 14
14:                                                             if.done P:2 S:0
	return t31

# Name: runtime.init#2
# Package: runtime
# Location: /usr/local/go/src/runtime/mem.go:64:6
# Locals:
#   0:	t0 MemStats
func init#2():
0:                                                                entry P:0 S:2
	t0 = local MemStats (memStats)                                *MemStats
	t1 = *sizeof_C_MStats                                           uintptr
	t2 = t1 != 5760:uintptr                                            bool
	if t2 goto 1 else 2
1:                                                              if.then P:1 S:1
	t3 = *sizeof_C_MStats                                           uintptr
	t4 = println(t3, 5760:uintptr)                                       ()
	t5 = gothrow("MStats vs MemStat...":string)                          ()
	jump 2
2:                                                              if.done P:2 S:0
	return

# Name: runtime.ReadMemStats
# Package: runtime
# Location: /usr/local/go/src/runtime/mem.go:73:6
func ReadMemStats(m *MemStats):
0:                                                                entry P:0 S:0
	t0 = semacquire(worldsema, false:bool)                               ()
	t1 = getg()                                                          *g
	t2 = &t1.m [#21]                                                    **m
	t3 = *t2                                                             *m
	t4 = &t3.gcing [#13]                                             *int32
	*t4 = 1:int32
	t5 = onM(stoptheworld)                                               ()
	t6 = &t1.m [#21]                                                    **m
	t7 = *t6                                                             *m
	t8 = &t7.ptrarg [#46]                                *[4]unsafe.Pointer
	t9 = &t8[0:int]                                         *unsafe.Pointer
	t10 = convert unsafe.Pointer <- *MemStats (m)            unsafe.Pointer
	t11 = noescape(t10)                                      unsafe.Pointer
	*t9 = t11
	t12 = onM(readmemstats_m)                                            ()
	t13 = &t1.m [#21]                                                   **m
	t14 = *t13                                                           *m
	t15 = &t14.gcing [#13]                                           *int32
	*t15 = 0:int32
	t16 = &t1.m [#21]                                                   **m
	t17 = *t16                                                           *m
	t18 = &t17.locks [#14]                                           *int32
	t19 = *t18                                                        int32
	t20 = t19 + 1:int32                                               int32
	*t18 = t20
	t21 = semrelease(worldsema)                                          ()
	t22 = onM(starttheworld)                                             ()
	t23 = &t1.m [#21]                                                   **m
	t24 = *t23                                                           *m
	t25 = &t24.locks [#14]                                           *int32
	t26 = *t25                                                        int32
	t27 = t26 - 1:int32                                               int32
	*t25 = t27
	return

# Name: runtime.writeHeapDump
# Package: runtime
# Location: /usr/local/go/src/runtime/mem.go:94:6
func writeHeapDump(fd uintptr):
0:                                                                entry P:0 S:0
	t0 = semacquire(worldsema, false:bool)                               ()
	t1 = getg()                                                          *g
	t2 = &t1.m [#21]                                                    **m
	t3 = *t2                                                             *m
	t4 = &t3.gcing [#13]                                             *int32
	*t4 = 1:int32
	t5 = onM(stoptheworld)                                               ()
	t6 = &t1.m [#21]                                                    **m
	t7 = *t6                                                             *m
	t8 = &t7.scalararg [#45]                                    *[4]uintptr
	t9 = &t8[0:int]                                                *uintptr
	*t9 = fd
	t10 = onM(writeheapdump_m)                                           ()
	t11 = &t1.m [#21]                                                   **m
	t12 = *t11                                                           *m
	t13 = &t12.gcing [#13]                                           *int32
	*t13 = 0:int32
	t14 = &t1.m [#21]                                                   **m
	t15 = *t14                                                           *m
	t16 = &t15.locks [#14]                                           *int32
	t17 = *t16                                                        int32
	t18 = t17 + 1:int32                                               int32
	*t16 = t18
	t19 = semrelease(worldsema)                                          ()
	t20 = onM(starttheworld)                                             ()
	t21 = &t1.m [#21]                                                   **m
	t22 = *t21                                                           *m
	t23 = &t22.locks [#14]                                           *int32
	t24 = *t23                                                        int32
	t25 = t24 - 1:int32                                               int32
	*t23 = t25
	return

# Name: runtime.gc_m_ptr
# Package: runtime
# Location: /usr/local/go/src/runtime/mgc0.go:10:6
func gc_m_ptr(ret *interface{}):
0:                                                                entry P:0 S:0
	t0 = make interface{} <- *m (nil:*m)                        interface{}
	*ret = t0
	return

# Name: runtime.gc_g_ptr
# Package: runtime
# Location: /usr/local/go/src/runtime/mgc0.go:15:6
func gc_g_ptr(ret *interface{}):
0:                                                                entry P:0 S:0
	t0 = make interface{} <- *g (nil:*g)                        interface{}
	*ret = t0
	return

# Name: runtime.gc_itab_ptr
# Package: runtime
# Location: /usr/local/go/src/runtime/mgc0.go:20:6
func gc_itab_ptr(ret *interface{}):
0:                                                                entry P:0 S:0
	t0 = make interface{} <- *itab (nil:*itab)                  interface{}
	*ret = t0
	return

# Name: runtime.gc_unixnanotime
# Package: runtime
# Location: /usr/local/go/src/runtime/mgc0.go:24:6
func gc_unixnanotime(now *int64):
0:                                                                entry P:0 S:0
	t0 = timenow()                                  (sec int64, nsec int32)
	t1 = extract t0 #0                                                int64
	t2 = extract t0 #1                                                int32
	t3 = t1 * 1000000000:int64                                        int64
	t4 = convert int64 <- int32 (t2)                                  int64
	t5 = t3 + t4                                                      int64
	*now = t5
	return

# Name: runtime.freeOSMemory
# Package: runtime
# Location: /usr/local/go/src/runtime/mgc0.go:29:6
func freeOSMemory():
0:                                                                entry P:0 S:0
	t0 = gogc(2:int32)                                                   ()
	t1 = onM(scavenge_m)                                                 ()
	return

# Name: runtime.registerPoolCleanup
# Package: runtime
# Location: /usr/local/go/src/runtime/mgc0.go:36:6
func registerPoolCleanup(f func()):
0:                                                                entry P:0 S:0
	*poolcleanup = f
	return

# Name: runtime.clearpools
# Package: runtime
# Location: /usr/local/go/src/runtime/mgc0.go:40:6
func clearpools():
0:                                                                entry P:0 S:2
	t0 = *poolcleanup                                                func()
	t1 = t0 != nil:func()                                              bool
	if t1 goto 1 else 2
1:                                                              if.then P:1 S:1
	t2 = *poolcleanup                                                func()
	t3 = t2()                                                            ()
	jump 2
2:                                                              if.done P:2 S:1
	jump 3
3:                                                      rangeindex.loop P:2 S:2
	t4 = phi [2: nil:*p, 12: t13] #p                                     *p
	t5 = phi [2: -1:int, 12: t10]                                       int
	t6 = phi [2: nil:*sudog, 12: t22] #sg                            *sudog
	t7 = phi [2: nil:*sudog, 12: t23] #sgnext                        *sudog
	t8 = phi [2: nil:*_defer, 12: t34] #d                           *_defer
	t9 = phi [2: nil:*_defer, 12: t35] #dlink                       *_defer
	t10 = t5 + 1:int                                                    int
	t11 = t10 < 257:int                                                bool
	if t11 goto 4 else 5
4:                                                      rangeindex.body P:1 S:2
	t12 = &allp[t10]                                                    **p
	t13 = *t12                                                           *p
	t14 = t13 == nil:*p                                                bool
	if t14 goto 5 else 6
5:                                                      rangeindex.done P:2 S:0
	return
6:                                                              if.done P:1 S:2
	t15 = &t13.mcache [#7]                                         **mcache
	t16 = *t15                                                      *mcache
	t17 = t16 != nil:*mcache                                           bool
	if t17 goto 7 else 8
7:                                                              if.then P:1 S:1
	t18 = &t16.tiny [#2]                                             **byte
	*t18 = nil:*byte
	t19 = &t16.tinysize [#3]                                       *uintptr
	*t19 = 0:uintptr
	t20 = &t16.sudogcache [#7]                                      **sudog
	t21 = *t20                                                       *sudog
	jump 11
8:                                                              if.done P:2 S:1
	t22 = phi [6: t6, 10: t30] #sg                                   *sudog
	t23 = phi [6: t7, 10: t31] #sgnext                               *sudog
	t24 = &t13.deferpool [#8]                                   *[5]*_defer
	t25 = *t24                                                   [5]*_defer
	jump 12
9:                                                             for.body P:1 S:1
	t26 = &t30.next [#2]                                            **sudog
	t27 = *t26                                                       *sudog
	t28 = &t30.next [#2]                                            **sudog
	*t28 = nil:*sudog
	jump 11
10:                                                            for.done P:1 S:1
	t29 = &t16.sudogcache [#7]                                      **sudog
	*t29 = nil:*sudog
	jump 8
11:                                                            for.loop P:2 S:2
	t30 = phi [7: t21, 9: t27] #sg                                   *sudog
	t31 = phi [7: nil:*sudog, 9: t27] #sgnext                        *sudog
	t32 = t30 != nil:*sudog                                            bool
	if t32 goto 9 else 10
12:                                                     rangeindex.loop P:2 S:2
	t33 = phi [8: -1:int, 15: t36]                                      int
	t34 = phi [8: t8, 15: t46] #d                                   *_defer
	t35 = phi [8: t9, 15: t47] #dlink                               *_defer
	t36 = t33 + 1:int                                                   int
	t37 = t36 < 5:int                                                  bool
	if t37 goto 13 else 3
13:                                                     rangeindex.body P:1 S:1
	t38 = &t13.deferpool [#8]                                   *[5]*_defer
	t39 = &t38[t36]                                                **_defer
	t40 = *t39                                                      *_defer
	jump 16
14:                                                            for.body P:1 S:1
	t41 = &t46.link [#6]                                           **_defer
	t42 = *t41                                                      *_defer
	t43 = &t46.link [#6]                                           **_defer
	*t43 = nil:*_defer
	jump 16
15:                                                            for.done P:1 S:1
	t44 = &t13.deferpool [#8]                                   *[5]*_defer
	t45 = &t44[t36]                                                **_defer
	*t45 = nil:*_defer
	jump 12
16:                                                            for.loop P:2 S:2
	t46 = phi [13: t40, 14: t42] #d                                 *_defer
	t47 = phi [13: nil:*_defer, 14: t42] #dlink                     *_defer
	t48 = t46 != nil:*_defer                                           bool
	if t48 goto 14 else 15

# Name: runtime.bgsweep
# Package: runtime
# Location: /usr/local/go/src/runtime/mgc0.go:82:6
func bgsweep():
0:                                                                entry P:0 S:1
	t0 = getg()                                                          *g
	t1 = &t0.issystem [#14]                                           *bool
	*t1 = true:bool
	jump 3
1:                                                             for.body P:1 S:1
	t2 = &sweep.nbgsweep [#3]                                       *uint32
	t3 = *t2                                                         uint32
	t4 = t3 + 1:uint32                                               uint32
	*t2 = t4
	t5 = Gosched()                                                       ()
	jump 3
2:                                                             for.done P:1 S:2
	t6 = lock(gclock)                                                    ()
	t7 = gosweepdone()                                                 bool
	if t7 goto 5 else 4
3:                                                             for.loop P:4 S:2
	t8 = gosweepone()                                               uintptr
	t9 = t8 != 18446744073709551615:uintptr                            bool
	if t9 goto 1 else 2
4:                                                              if.then P:1 S:1
	t10 = unlock(gclock)                                                 ()
	jump 3
5:                                                              if.done P:1 S:1
	t11 = &sweep.parked [#1]                                          *bool
	*t11 = true:bool
	t12 = goparkunlock(gclock, "GC sweep wait":string)                   ()
	jump 3

# Name: runtime.writebarrierptr
# Package: runtime
# Location: /usr/local/go/src/runtime/mgc0.go:105:6
func writebarrierptr(dst *uintptr, src uintptr):
0:                                                                entry P:0 S:0
	*dst = src
	return

# Name: runtime.writebarrierstring
# Package: runtime
# Location: /usr/local/go/src/runtime/mgc0.go:110:6
# Locals:
#   0:	t0 [2]uintptr
func writebarrierstring(dst *[2]uintptr, src [2]uintptr):
0:                                                                entry P:0 S:0
	t0 = local [2]uintptr (src)                                 *[2]uintptr
	*t0 = src
	t1 = &dst[0:int]                                               *uintptr
	t2 = &t0[0:int]                                                *uintptr
	t3 = *t2                                                        uintptr
	*t1 = t3
	t4 = &dst[1:int]                                               *uintptr
	t5 = &t0[1:int]                                                *uintptr
	t6 = *t5                                                        uintptr
	*t4 = t6
	return

# Name: runtime.writebarrierslice
# Package: runtime
# Location: /usr/local/go/src/runtime/mgc0.go:116:6
# Locals:
#   0:	t0 [3]uintptr
func writebarrierslice(dst *[3]uintptr, src [3]uintptr):
0:                                                                entry P:0 S:0
	t0 = local [3]uintptr (src)                                 *[3]uintptr
	*t0 = src
	t1 = &dst[0:int]                                               *uintptr
	t2 = &t0[0:int]                                                *uintptr
	t3 = *t2                                                        uintptr
	*t1 = t3
	t4 = &dst[1:int]                                               *uintptr
	t5 = &t0[1:int]                                                *uintptr
	t6 = *t5                                                        uintptr
	*t4 = t6
	t7 = &dst[2:int]                                               *uintptr
	t8 = &t0[2:int]                                                *uintptr
	t9 = *t8                                                        uintptr
	*t7 = t9
	return

# Name: runtime.writebarrieriface
# Package: runtime
# Location: /usr/local/go/src/runtime/mgc0.go:123:6
# Locals:
#   0:	t0 [2]uintptr
func writebarrieriface(dst *[2]uintptr, src [2]uintptr):
0:                                                                entry P:0 S:0
	t0 = local [2]uintptr (src)                                 *[2]uintptr
	*t0 = src
	t1 = &dst[0:int]                                               *uintptr
	t2 = &t0[0:int]                                                *uintptr
	t3 = *t2                                                        uintptr
	*t1 = t3
	t4 = &dst[1:int]                                               *uintptr
	t5 = &t0[1:int]                                                *uintptr
	t6 = *t5                                                        uintptr
	*t4 = t6
	return

# Name: runtime.writebarrierfat2
# Package: runtime
# Location: /usr/local/go/src/runtime/mgc0.go:129:6
# Locals:
#   0:	t0 [2]uintptr
func writebarrierfat2(dst *[2]uintptr, _ *byte, src [2]uintptr):
0:                                                                entry P:0 S:0
	t0 = local [2]uintptr (src)                                 *[2]uintptr
	*t0 = src
	t1 = &dst[0:int]                                               *uintptr
	t2 = &t0[0:int]                                                *uintptr
	t3 = *t2                                                        uintptr
	*t1 = t3
	t4 = &dst[1:int]                                               *uintptr
	t5 = &t0[1:int]                                                *uintptr
	t6 = *t5                                                        uintptr
	*t4 = t6
	return

# Name: runtime.writebarrierfat3
# Package: runtime
# Location: /usr/local/go/src/runtime/mgc0.go:135:6
# Locals:
#   0:	t0 [3]uintptr
func writebarrierfat3(dst *[3]uintptr, _ *byte, src [3]uintptr):
0:                                                                entry P:0 S:0
	t0 = local [3]uintptr (src)                                 *[3]uintptr
	*t0 = src
	t1 = &dst[0:int]                                               *uintptr
	t2 = &t0[0:int]                                                *uintptr
	t3 = *t2                                                        uintptr
	*t1 = t3
	t4 = &dst[1:int]                                               *uintptr
	t5 = &t0[1:int]                                                *uintptr
	t6 = *t5                                                        uintptr
	*t4 = t6
	t7 = &dst[2:int]                                               *uintptr
	t8 = &t0[2:int]                                                *uintptr
	t9 = *t8                                                        uintptr
	*t7 = t9
	return

# Name: runtime.writebarrierfat4
# Package: runtime
# Location: /usr/local/go/src/runtime/mgc0.go:142:6
# Locals:
#   0:	t0 [4]uintptr
func writebarrierfat4(dst *[4]uintptr, _ *byte, src [4]uintptr):
0:                                                                entry P:0 S:0
	t0 = local [4]uintptr (src)                                 *[4]uintptr
	*t0 = src
	t1 = &dst[0:int]                                               *uintptr
	t2 = &t0[0:int]                                                *uintptr
	t3 = *t2                                                        uintptr
	*t1 = t3
	t4 = &dst[1:int]                                               *uintptr
	t5 = &t0[1:int]                                                *uintptr
	t6 = *t5                                                        uintptr
	*t4 = t6
	t7 = &dst[2:int]                                               *uintptr
	t8 = &t0[2:int]                                                *uintptr
	t9 = *t8                                                        uintptr
	*t7 = t9
	t10 = &dst[3:int]                                              *uintptr
	t11 = &t0[3:int]                                               *uintptr
	t12 = *t11                                                      uintptr
	*t10 = t12
	return

# Name: runtime.writebarrierfat
# Package: runtime
# Location: /usr/local/go/src/runtime/mgc0.go:150:6
func writebarrierfat(typ *_type, dst unsafe.Pointer, src unsafe.Pointer):
0:                                                                entry P:0 S:0
	t0 = &typ.size [#0]                                            *uintptr
	t1 = *t0                                                        uintptr
	t2 = memmove(dst, src, t1)                                           ()
	return

# Name: runtime.newBucket
# Package: runtime
# Location: /usr/local/go/src/runtime/mprof.go:99:6
func newBucket(typ bucketType, nstk int) *bucket:
0:                                                                entry P:0 S:2
	t0 = convert uintptr <- int (nstk)                              uintptr
	t1 = t0 * 8:uintptr                                             uintptr
	t2 = 48:uintptr + t1                                            uintptr
	t3 = typ == 1:bucketType                                           bool
	if t3 goto 2 else 4
1:                                                          switch.done P:3 S:0
	t4 = phi [2: t13, 3: t14, 5: t2] #size                          uintptr
	t5 = &memstats.buckhash_sys [#18]                               *uint64
	t6 = persistentalloc(t4, 0:uintptr, t5)                  unsafe.Pointer
	t7 = convert *bucket <- unsafe.Pointer (t6)                     *bucket
	t8 = *bucketmem                                                 uintptr
	t9 = t8 + t4                                                    uintptr
	*bucketmem = t9
	t10 = &t7.typ [#2]                                          *bucketType
	*t10 = typ
	t11 = &t7.nstk [#5]                                            *uintptr
	t12 = convert uintptr <- int (nstk)                             uintptr
	*t11 = t12
	return t7
2:                                                          switch.body P:1 S:1
	t13 = t2 + 96:uintptr                                           uintptr
	jump 1
3:                                                          switch.body P:1 S:1
	t14 = t2 + 16:uintptr                                           uintptr
	jump 1
4:                                                          switch.next P:1 S:2
	t15 = typ == 2:bucketType                                          bool
	if t15 goto 3 else 5
5:                                                          switch.next P:1 S:1
	t16 = gothrow("invalid profile b...":string)                         ()
	jump 1

# Name: (*runtime.bucket).stk
# Package: runtime
# Location: /usr/local/go/src/runtime/mprof.go:118:18
func (b *bucket) stk() []uintptr:
0:                                                                entry P:0 S:0
	t0 = convert unsafe.Pointer <- *bucket (b)               unsafe.Pointer
	t1 = add(t0, 48:uintptr)                                 unsafe.Pointer
	t2 = convert *[32]uintptr <- unsafe.Pointer (t1)           *[32]uintptr
	t3 = &b.nstk [#5]                                              *uintptr
	t4 = *t3                                                        uintptr
	t5 = &b.nstk [#5]                                              *uintptr
	t6 = *t5                                                        uintptr
	t7 = slice t2[:t4:t6]                                         []uintptr
	return t7

# Name: (*runtime.bucket).mp
# Package: runtime
# Location: /usr/local/go/src/runtime/mprof.go:124:18
func (b *bucket) mp() *memRecord:
0:                                                                entry P:0 S:2
	t0 = &b.typ [#2]                                            *bucketType
	t1 = *t0                                                     bucketType
	t2 = t1 != 1:bucketType                                            bool
	if t2 goto 1 else 2
1:                                                              if.then P:1 S:1
	t3 = gothrow("bad use of bucket.mp":string)                          ()
	jump 2
2:                                                              if.done P:2 S:0
	t4 = convert unsafe.Pointer <- *bucket (b)               unsafe.Pointer
	t5 = &b.nstk [#5]                                              *uintptr
	t6 = *t5                                                        uintptr
	t7 = t6 * 8:uintptr                                             uintptr
	t8 = 48:uintptr + t7                                            uintptr
	t9 = add(t4, t8)                                         unsafe.Pointer
	t10 = convert *memRecord <- unsafe.Pointer (t9)              *memRecord
	return t10

# Name: (*runtime.bucket).bp
# Package: runtime
# Location: /usr/local/go/src/runtime/mprof.go:133:18
func (b *bucket) bp() *blockRecord:
0:                                                                entry P:0 S:2
	t0 = &b.typ [#2]                                            *bucketType
	t1 = *t0                                                     bucketType
	t2 = t1 != 2:bucketType                                            bool
	if t2 goto 1 else 2
1:                                                              if.then P:1 S:1
	t3 = gothrow("bad use of bucket.bp":string)                          ()
	jump 2
2:                                                              if.done P:2 S:0
	t4 = convert unsafe.Pointer <- *bucket (b)               unsafe.Pointer
	t5 = &b.nstk [#5]                                              *uintptr
	t6 = *t5                                                        uintptr
	t7 = t6 * 8:uintptr                                             uintptr
	t8 = 48:uintptr + t7                                            uintptr
	t9 = add(t4, t8)                                         unsafe.Pointer
	t10 = convert *blockRecord <- unsafe.Pointer (t9)          *blockRecord
	return t10

# Name: runtime.stkbucket
# Package: runtime
# Location: /usr/local/go/src/runtime/mprof.go:142:6
func stkbucket(typ bucketType, size uintptr, stk []uintptr, alloc bool) *bucket:
0:                                                                entry P:0 S:2
	t0 = *buckhash                                         *[179999]*bucket
	t1 = t0 == nil:*[179999]*bucket                                    bool
	if t1 goto 1 else 2
1:                                                              if.then P:1 S:2
	t2 = &memstats.buckhash_sys [#18]                               *uint64
	t3 = sysAlloc(1439992:uintptr, t2)                       unsafe.Pointer
	t4 = convert *[179999]*bucket <- unsafe.Pointer (t3)   *[179999]*bucket
	*buckhash = t4
	t5 = *buckhash                                         *[179999]*bucket
	t6 = t5 == nil:*[179999]*bucket                                    bool
	if t6 goto 3 else 2
2:                                                              if.done P:3 S:1
	t7 = len(stk)                                                       int
	jump 4
3:                                                              if.then P:1 S:1
	t8 = gothrow("runtime: cannot a...":string)                          ()
	jump 2
4:                                                      rangeindex.loop P:2 S:2
	t9 = phi [2: 0:uintptr, 5: t19] #h                              uintptr
	t10 = phi [2: -1:int, 5: t11]                                       int
	t11 = t10 + 1:int                                                   int
	t12 = t11 < t7                                                     bool
	if t12 goto 5 else 6
5:                                                      rangeindex.body P:1 S:1
	t13 = &stk[t11]                                                *uintptr
	t14 = *t13                                                      uintptr
	t15 = t9 + t14                                                  uintptr
	t16 = t15 << 10:uint64                                          uintptr
	t17 = t15 + t16                                                 uintptr
	t18 = t17 >> 6:uint64                                           uintptr
	t19 = t17 ^ t18                                                 uintptr
	jump 4
6:                                                      rangeindex.done P:1 S:1
	t20 = t9 + size                                                 uintptr
	t21 = t20 << 10:uint64                                          uintptr
	t22 = t20 + t21                                                 uintptr
	t23 = t22 >> 6:uint64                                           uintptr
	t24 = t22 ^ t23                                                 uintptr
	t25 = t24 << 3:uint64                                           uintptr
	t26 = t24 + t25                                                 uintptr
	t27 = t26 >> 11:uint64                                          uintptr
	t28 = t26 ^ t27                                                 uintptr
	t29 = t28 % 179999:uintptr                                      uintptr
	t30 = convert int <- uintptr (t29)                                  int
	t31 = *buckhash                                        *[179999]*bucket
	t32 = &t31[t30]                                                **bucket
	t33 = *t32                                                      *bucket
	jump 9
7:                                                             for.body P:1 S:2
	t34 = &t37.typ [#2]                                         *bucketType
	t35 = *t34                                                   bucketType
	t36 = t35 == typ                                                   bool
	if t36 goto 14 else 11
8:                                                             for.done P:1 S:2
	if alloc goto 16 else 15
9:                                                             for.loop P:2 S:2
	t37 = phi [6: t33, 11: t40] #b                                  *bucket
	t38 = t37 != nil:*bucket                                           bool
	if t38 goto 7 else 8
10:                                                             if.then P:1 S:0
	return t37
11:                                                             if.done P:4 S:1
	t39 = &t37.next [#0]                                           **bucket
	t40 = *t39                                                      *bucket
	jump 9
12:                                                           cond.true P:1 S:2
	t41 = (*bucket).stk(t37)                                      []uintptr
	t42 = eqslice(t41, stk)                                            bool
	if t42 goto 10 else 11
13:                                                           cond.true P:1 S:2
	t43 = &t37.size [#4]                                           *uintptr
	t44 = *t43                                                      uintptr
	t45 = t44 == size                                                  bool
	if t45 goto 12 else 11
14:                                                           cond.true P:1 S:2
	t46 = &t37.hash [#3]                                           *uintptr
	t47 = *t46                                                      uintptr
	t48 = t47 == t28                                                   bool
	if t48 goto 13 else 11
15:                                                             if.then P:1 S:0
	return nil:*bucket
16:                                                             if.done P:1 S:2
	t49 = len(stk)                                                      int
	t50 = newBucket(typ, t49)                                       *bucket
	t51 = (*bucket).stk(t50)                                      []uintptr
	t52 = copy(t51, stk)                                                int
	t53 = &t50.hash [#3]                                           *uintptr
	*t53 = t28
	t54 = &t50.size [#4]                                           *uintptr
	*t54 = size
	t55 = &t50.next [#0]                                           **bucket
	t56 = *buckhash                                        *[179999]*bucket
	t57 = &t56[t30]                                                **bucket
	t58 = *t57                                                      *bucket
	*t55 = t58
	t59 = *buckhash                                        *[179999]*bucket
	t60 = &t59[t30]                                                **bucket
	*t60 = t50
	t61 = typ == 1:bucketType                                          bool
	if t61 goto 17 else 19
17:                                                             if.then P:1 S:1
	t62 = &t50.allnext [#1]                                        **bucket
	t63 = *mbuckets                                                 *bucket
	*t62 = t63
	*mbuckets = t50
	jump 18
18:                                                             if.done P:2 S:0
	return t50
19:                                                             if.else P:1 S:1
	t64 = &t50.allnext [#1]                                        **bucket
	t65 = *bbuckets                                                 *bucket
	*t64 = t65
	*bbuckets = t50
	jump 18

# Name: runtime.eqslice
# Package: runtime
# Location: /usr/local/go/src/runtime/mprof.go:195:6
func eqslice(x []uintptr, y []uintptr) bool:
0:                                                                entry P:0 S:2
	t0 = len(x)                                                         int
	t1 = len(y)                                                         int
	t2 = t0 != t1                                                      bool
	if t2 goto 1 else 2
1:                                                              if.then P:1 S:0
	return false:bool
2:                                                              if.done P:1 S:1
	t3 = len(x)                                                         int
	jump 3
3:                                                      rangeindex.loop P:2 S:2
	t4 = phi [2: -1:int, 4: t5]                                         int
	t5 = t4 + 1:int                                                     int
	t6 = t5 < t3                                                       bool
	if t6 goto 4 else 5
4:                                                      rangeindex.body P:1 S:2
	t7 = &x[t5]                                                    *uintptr
	t8 = *t7                                                        uintptr
	t9 = &y[t5]                                                    *uintptr
	t10 = *t9                                                       uintptr
	t11 = t8 != t10                                                    bool
	if t11 goto 6 else 3
5:                                                      rangeindex.done P:1 S:0
	return true:bool
6:                                                              if.then P:1 S:0
	return false:bool

# Name: runtime.mprof_GC
# Package: runtime
# Location: /usr/local/go/src/runtime/mprof.go:207:6
func mprof_GC():
0:                                                                entry P:0 S:1
	t0 = *mbuckets                                                  *bucket
	jump 3
1:                                                             for.body P:1 S:1
	t1 = (*bucket).mp(t40)                                       *memRecord
	t2 = &t1.allocs [#0]                                           *uintptr
	t3 = &t1.prev_allocs [#4]                                      *uintptr
	t4 = *t3                                                        uintptr
	t5 = *t2                                                        uintptr
	t6 = t5 + t4                                                    uintptr
	*t2 = t6
	t7 = &t1.frees [#1]                                            *uintptr
	t8 = &t1.prev_frees [#5]                                       *uintptr
	t9 = *t8                                                        uintptr
	t10 = *t7                                                       uintptr
	t11 = t10 + t9                                                  uintptr
	*t7 = t11
	t12 = &t1.alloc_bytes [#2]                                     *uintptr
	t13 = &t1.prev_alloc_bytes [#6]                                *uintptr
	t14 = *t13                                                      uintptr
	t15 = *t12                                                      uintptr
	t16 = t15 + t14                                                 uintptr
	*t12 = t16
	t17 = &t1.free_bytes [#3]                                      *uintptr
	t18 = &t1.prev_free_bytes [#7]                                 *uintptr
	t19 = *t18                                                      uintptr
	t20 = *t17                                                      uintptr
	t21 = t20 + t19                                                 uintptr
	*t17 = t21
	t22 = &t1.prev_allocs [#4]                                     *uintptr
	t23 = &t1.recent_allocs [#8]                                   *uintptr
	t24 = *t23                                                      uintptr
	*t22 = t24
	t25 = &t1.prev_frees [#5]                                      *uintptr
	t26 = &t1.recent_frees [#9]                                    *uintptr
	t27 = *t26                                                      uintptr
	*t25 = t27
	t28 = &t1.prev_alloc_bytes [#6]                                *uintptr
	t29 = &t1.recent_alloc_bytes [#10]                             *uintptr
	t30 = *t29                                                      uintptr
	*t28 = t30
	t31 = &t1.prev_free_bytes [#7]                                 *uintptr
	t32 = &t1.recent_free_bytes [#11]                              *uintptr
	t33 = *t32                                                      uintptr
	*t31 = t33
	t34 = &t1.recent_allocs [#8]                                   *uintptr
	*t34 = 0:uintptr
	t35 = &t1.recent_frees [#9]                                    *uintptr
	*t35 = 0:uintptr
	t36 = &t1.recent_alloc_bytes [#10]                             *uintptr
	*t36 = 0:uintptr
	t37 = &t1.recent_free_bytes [#11]                              *uintptr
	*t37 = 0:uintptr
	t38 = &t40.allnext [#1]                                        **bucket
	t39 = *t38                                                      *bucket
	jump 3
2:                                                             for.done P:1 S:0
	return
3:                                                             for.loop P:2 S:2
	t40 = phi [0: t0, 1: t39] #b                                    *bucket
	t41 = t40 != nil:*bucket                                           bool
	if t41 goto 1 else 2

# Name: runtime.mProf_GC
# Package: runtime
# Location: /usr/local/go/src/runtime/mprof.go:228:6
func mProf_GC():
0:                                                                entry P:0 S:0
	t0 = lock(proflock)                                                  ()
	t1 = mprof_GC()                                                      ()
	t2 = unlock(proflock)                                                ()
	return

# Name: runtime.mProf_Malloc
# Package: runtime
# Location: /usr/local/go/src/runtime/mprof.go:235:6
func mProf_Malloc(p unsafe.Pointer, size uintptr):
0:                                                                entry P:0 S:0
	t0 = new [32]uintptr (stk)                                 *[32]uintptr
	t1 = &t0[0:int]                                                *uintptr
	t2 = callers(4:int, t1, 32:int)                                     int
	t3 = lock(proflock)                                                  ()
	t4 = slice t0[:t2]                                            []uintptr
	t5 = stkbucket(1:bucketType, size, t4, true:bool)               *bucket
	t6 = (*bucket).mp(t5)                                        *memRecord
	t7 = &t6.recent_allocs [#8]                                    *uintptr
	t8 = *t7                                                        uintptr
	t9 = t8 + 1:uintptr                                             uintptr
	*t7 = t9
	t10 = &t6.recent_alloc_bytes [#10]                             *uintptr
	t11 = *t10                                                      uintptr
	t12 = t11 + size                                                uintptr
	*t10 = t12
	t13 = unlock(proflock)                                               ()
	t14 = setprofilebucket(p, t5)                                        ()
	return

# Name: runtime.setprofilebucket
# Package: runtime
# Location: /usr/local/go/src/runtime/mprof.go:254:6
func setprofilebucket(p unsafe.Pointer, b *bucket):
0:                                                                entry P:0 S:0
	t0 = getg()                                                          *g
	t1 = &t0.m [#21]                                                    **m
	t2 = *t1                                                             *m
	t3 = &t2.ptrarg [#46]                                *[4]unsafe.Pointer
	t4 = &t3[0:int]                                         *unsafe.Pointer
	*t4 = p
	t5 = &t0.m [#21]                                                    **m
	t6 = *t5                                                             *m
	t7 = &t6.ptrarg [#46]                                *[4]unsafe.Pointer
	t8 = &t7[1:int]                                         *unsafe.Pointer
	t9 = convert unsafe.Pointer <- *bucket (b)               unsafe.Pointer
	*t8 = t9
	t10 = onM(setprofilebucket_m)                                        ()
	return

# Name: runtime.mProf_Free
# Package: runtime
# Location: /usr/local/go/src/runtime/mprof.go:262:6
func mProf_Free(b *bucket, size uintptr, freed bool):
0:                                                                entry P:0 S:2
	t0 = lock(proflock)                                                  ()
	t1 = (*bucket).mp(b)                                         *memRecord
	if freed goto 1 else 3
1:                                                              if.then P:1 S:1
	t2 = &t1.recent_frees [#9]                                     *uintptr
	t3 = *t2                                                        uintptr
	t4 = t3 + 1:uintptr                                             uintptr
	*t2 = t4
	t5 = &t1.recent_free_bytes [#11]                               *uintptr
	t6 = *t5                                                        uintptr
	t7 = t6 + size                                                  uintptr
	*t5 = t7
	jump 2
2:                                                              if.done P:2 S:0
	t8 = unlock(proflock)                                                ()
	return
3:                                                              if.else P:1 S:1
	t9 = &t1.prev_frees [#5]                                       *uintptr
	t10 = *t9                                                       uintptr
	t11 = t10 + 1:uintptr                                           uintptr
	*t9 = t11
	t12 = &t1.prev_free_bytes [#7]                                 *uintptr
	t13 = *t12                                                      uintptr
	t14 = t13 + size                                                uintptr
	*t12 = t14
	jump 2

# Name: runtime.SetBlockProfileRate
# Package: runtime
# Location: /usr/local/go/src/runtime/mprof.go:283:6
func SetBlockProfileRate(rate int):
0:                                                                entry P:0 S:2
	t0 = rate <= 0:int                                                 bool
	if t0 goto 1 else 3
1:                                                              if.then P:1 S:1
	jump 2
2:                                                              if.done P:4 S:0
	t1 = phi [1: 0:int64, 4: 1:int64, 5: t10, 6: 1:int64] #r          int64
	t2 = convert uint64 <- int64 (t1)                                uint64
	t3 = atomicstore64(blockprofilerate, t2)                             ()
	return
3:                                                              if.else P:1 S:2
	t4 = rate == 1:int                                                 bool
	if t4 goto 4 else 5
4:                                                              if.then P:1 S:1
	jump 2
5:                                                              if.else P:1 S:2
	t5 = convert float64 <- int (rate)                              float64
	t6 = tickspersecond()                                             int64
	t7 = convert float64 <- int64 (t6)                              float64
	t8 = t5 * t7                                                    float64
	t9 = t8 / 1000000000:float64                                    float64
	t10 = convert int64 <- float64 (t9)                               int64
	t11 = t10 == 0:int64                                               bool
	if t11 goto 6 else 2
6:                                                              if.then P:1 S:1
	jump 2

# Name: runtime.blockevent
# Package: runtime
# Location: /usr/local/go/src/runtime/mprof.go:300:6
func blockevent(cycles int64, skip int):
0:                                                                entry P:0 S:2
	t0 = cycles <= 0:int64                                             bool
	if t0 goto 1 else 2
1:                                                              if.then P:1 S:1
	jump 2
2:                                                              if.done P:2 S:2
	t1 = phi [0: cycles, 1: 1:int64] #cycles                          int64
	t2 = atomicload64(blockprofilerate)                              uint64
	t3 = convert int64 <- uint64 (t2)                                 int64
	t4 = t3 <= 0:int64                                                 bool
	if t4 goto 3 else 5
3:                                                              if.then P:2 S:0
	return
4:                                                              if.done P:2 S:2
	t5 = getg()                                                          *g
	t6 = new [32]uintptr (stk)                                 *[32]uintptr
	t7 = &t5.m [#21]                                                    **m
	t8 = *t7                                                             *m
	t9 = &t8.curg [#6]                                                  **g
	t10 = *t9                                                            *g
	t11 = t10 == nil:*g                                                bool
	if t11 goto 7 else 10
5:                                                           cond.false P:1 S:2
	t12 = t3 > t1                                                      bool
	if t12 goto 6 else 4
6:                                                            cond.true P:1 S:2
	t13 = fastrand1()                                                uint32
	t14 = convert int64 <- uint32 (t13)                               int64
	t15 = t14 % t3                                                    int64
	t16 = t15 > t1                                                     bool
	if t16 goto 3 else 4
7:                                                              if.then P:2 S:1
	t17 = &t6[0:int]                                               *uintptr
	t18 = callers(skip, t17, 32:int)                                    int
	jump 8
8:                                                              if.done P:2 S:0
	t19 = phi [7: t18, 9: t37] #nstk                                    int
	t20 = lock(proflock)                                                 ()
	t21 = slice t6[:t19]                                          []uintptr
	t22 = stkbucket(2:bucketType, 0:uintptr, t21, true:bool)        *bucket
	t23 = (*bucket).bp(t22)                                    *blockRecord
	t24 = &t23.count [#0]                                            *int64
	t25 = *t24                                                        int64
	t26 = t25 + 1:int64                                               int64
	*t24 = t26
	t27 = (*bucket).bp(t22)                                    *blockRecord
	t28 = &t27.cycles [#1]                                           *int64
	t29 = *t28                                                        int64
	t30 = t29 + t1                                                    int64
	*t28 = t30
	t31 = unlock(proflock)                                               ()
	return
9:                                                              if.else P:1 S:1
	t32 = &t5.m [#21]                                                   **m
	t33 = *t32                                                           *m
	t34 = &t33.curg [#6]                                                **g
	t35 = *t34                                                           *g
	t36 = &t6[0:int]                                               *uintptr
	t37 = gcallers(t35, skip, t36, 32:int)                              int
	jump 8
10:                                                          cond.false P:1 S:2
	t38 = &t5.m [#21]                                                   **m
	t39 = *t38                                                           *m
	t40 = &t39.curg [#6]                                                **g
	t41 = *t40                                                           *g
	t42 = t41 == t5                                                    bool
	if t42 goto 7 else 9

# Name: (*runtime.StackRecord).Stack
# Package: runtime
# Location: /usr/local/go/src/runtime/mprof.go:332:23
func (r *StackRecord) Stack() []uintptr:
0:                                                                entry P:0 S:1
	t0 = &r.Stack0 [#0]                                        *[32]uintptr
	t1 = *t0                                                    [32]uintptr
	jump 1
1:                                                      rangeindex.loop P:2 S:2
	t2 = phi [0: -1:int, 2: t3]                                         int
	t3 = t2 + 1:int                                                     int
	t4 = t3 < 32:int                                                   bool
	if t4 goto 2 else 3
2:                                                      rangeindex.body P:1 S:2
	t5 = t1[t3]                                                     uintptr
	t6 = t5 == 0:uintptr                                               bool
	if t6 goto 4 else 1
3:                                                      rangeindex.done P:1 S:0
	t7 = &r.Stack0 [#0]                                        *[32]uintptr
	t8 = slice t7[0:int:]                                         []uintptr
	return t8
4:                                                              if.then P:1 S:0
	t9 = &r.Stack0 [#0]                                        *[32]uintptr
	t10 = slice t9[0:int:t3]                                      []uintptr
	return t10

# Name: (*runtime.MemProfileRecord).InUseBytes
# Package: runtime
# Location: /usr/local/go/src/runtime/mprof.go:366:28
func (r *MemProfileRecord) InUseBytes() int64:
0:                                                                entry P:0 S:0
	t0 = &r.AllocBytes [#0]                                          *int64
	t1 = *t0                                                          int64
	t2 = &r.FreeBytes [#1]                                           *int64
	t3 = *t2                                                          int64
	t4 = t1 - t3                                                      int64
	return t4

# Name: (*runtime.MemProfileRecord).InUseObjects
# Package: runtime
# Location: /usr/local/go/src/runtime/mprof.go:369:28
func (r *MemProfileRecord) InUseObjects() int64:
0:                                                                entry P:0 S:0
	t0 = &r.AllocObjects [#2]                                        *int64
	t1 = *t0                                                          int64
	t2 = &r.FreeObjects [#3]                                         *int64
	t3 = *t2                                                          int64
	t4 = t1 - t3                                                      int64
	return t4

# Name: (*runtime.MemProfileRecord).Stack
# Package: runtime
# Location: /usr/local/go/src/runtime/mprof.go:375:28
func (r *MemProfileRecord) Stack() []uintptr:
0:                                                                entry P:0 S:1
	t0 = &r.Stack0 [#4]                                        *[32]uintptr
	t1 = *t0                                                    [32]uintptr
	jump 1
1:                                                      rangeindex.loop P:2 S:2
	t2 = phi [0: -1:int, 2: t3]                                         int
	t3 = t2 + 1:int                                                     int
	t4 = t3 < 32:int                                                   bool
	if t4 goto 2 else 3
2:                                                      rangeindex.body P:1 S:2
	t5 = t1[t3]                                                     uintptr
	t6 = t5 == 0:uintptr                                               bool
	if t6 goto 4 else 1
3:                                                      rangeindex.done P:1 S:0
	t7 = &r.Stack0 [#4]                                        *[32]uintptr
	t8 = slice t7[0:int:]                                         []uintptr
	return t8
4:                                                              if.then P:1 S:0
	t9 = &r.Stack0 [#4]                                        *[32]uintptr
	t10 = slice t9[0:int:t3]                                      []uintptr
	return t10

# Name: runtime.MemProfile
# Package: runtime
# Location: /usr/local/go/src/runtime/mprof.go:396:6
func MemProfile(p []MemProfileRecord, inuseZero bool) (n int, ok bool):
0:                                                                entry P:0 S:1
	t0 = lock(proflock)                                                  ()
	t1 = *mbuckets                                                  *bucket
	jump 3
1:                                                             for.body P:1 S:2
	t2 = (*bucket).mp(t5)                                        *memRecord
	if inuseZero goto 4 else 6
2:                                                             for.done P:1 S:2
	if t4 goto 10 else 11
3:                                                             for.loop P:2 S:2
	t3 = phi [0: 0:int, 8: t8] #n                                       int
	t4 = phi [0: true:bool, 8: t17] #clear                             bool
	t5 = phi [0: t1, 8: t19] #b                                     *bucket
	t6 = t5 != nil:*bucket                                             bool
	if t6 goto 1 else 2
4:                                                              if.then P:2 S:1
	t7 = t3 + 1:int                                                     int
	jump 5
5:                                                              if.done P:2 S:2
	t8 = phi [6: t3, 4: t7] #n                                          int
	t9 = &t2.allocs [#0]                                           *uintptr
	t10 = *t9                                                       uintptr
	t11 = t10 != 0:uintptr                                             bool
	if t11 goto 7 else 9
6:                                                           cond.false P:1 S:2
	t12 = &t2.alloc_bytes [#2]                                     *uintptr
	t13 = *t12                                                      uintptr
	t14 = &t2.free_bytes [#3]                                      *uintptr
	t15 = *t14                                                      uintptr
	t16 = t13 != t15                                                   bool
	if t16 goto 4 else 5
7:                                                              if.then P:2 S:1
	jump 8
8:                                                              if.done P:2 S:1
	t17 = phi [9: t4, 7: false:bool] #clear                            bool
	t18 = &t5.allnext [#1]                                         **bucket
	t19 = *t18                                                      *bucket
	jump 3
9:                                                           cond.false P:1 S:2
	t20 = &t2.frees [#1]                                           *uintptr
	t21 = *t20                                                      uintptr
	t22 = t21 != 0:uintptr                                             bool
	if t22 goto 7 else 8
10:                                                             if.then P:1 S:1
	t23 = mprof_GC()                                                     ()
	t24 = mprof_GC()                                                     ()
	t25 = *mbuckets                                                 *bucket
	jump 13
11:                                                             if.done P:2 S:2
	t26 = phi [2: t3, 13: t30] #n                                       int
	t27 = len(p)                                                        int
	t28 = t26 <= t27                                                   bool
	if t28 goto 17 else 18
12:                                                            for.body P:1 S:2
	t29 = (*bucket).mp(t31)                                      *memRecord
	if inuseZero goto 14 else 16
13:                                                            for.loop P:2 S:2
	t30 = phi [10: 0:int, 15: t34] #n                                   int
	t31 = phi [10: t25, 15: t36] #b                                 *bucket
	t32 = t31 != nil:*bucket                                           bool
	if t32 goto 12 else 11
14:                                                             if.then P:2 S:1
	t33 = t30 + 1:int                                                   int
	jump 15
15:                                                             if.done P:2 S:1
	t34 = phi [16: t30, 14: t33] #n                                     int
	t35 = &t31.allnext [#1]                                        **bucket
	t36 = *t35                                                      *bucket
	jump 13
16:                                                          cond.false P:1 S:2
	t37 = &t29.alloc_bytes [#2]                                    *uintptr
	t38 = *t37                                                      uintptr
	t39 = &t29.free_bytes [#3]                                     *uintptr
	t40 = *t39                                                      uintptr
	t41 = t38 != t40                                                   bool
	if t41 goto 14 else 15
17:                                                             if.then P:1 S:1
	t42 = *mbuckets                                                 *bucket
	jump 20
18:                                                             if.done P:2 S:0
	t43 = phi [11: false:bool, 20: true:bool] #ok                      bool
	t44 = unlock(proflock)                                               ()
	return t26, t43
19:                                                            for.body P:1 S:2
	t45 = (*bucket).mp(t47)                                      *memRecord
	if inuseZero goto 21 else 23
20:                                                            for.loop P:2 S:2
	t46 = phi [17: 0:int, 22: t52] #idx                                 int
	t47 = phi [17: t42, 22: t54] #b                                 *bucket
	t48 = t47 != nil:*bucket                                           bool
	if t48 goto 19 else 18
21:                                                             if.then P:2 S:1
	t49 = &p[t46]                                         *MemProfileRecord
	t50 = record(t49, t47)                                               ()
	t51 = t46 + 1:int                                                   int
	jump 22
22:                                                             if.done P:2 S:1
	t52 = phi [23: t46, 21: t51] #idx                                   int
	t53 = &t47.allnext [#1]                                        **bucket
	t54 = *t53                                                      *bucket
	jump 20
23:                                                          cond.false P:1 S:2
	t55 = &t45.alloc_bytes [#2]                                    *uintptr
	t56 = *t55                                                      uintptr
	t57 = &t45.free_bytes [#3]                                     *uintptr
	t58 = *t57                                                      uintptr
	t59 = t56 != t58                                                   bool
	if t59 goto 21 else 22

# Name: runtime.record
# Package: runtime
# Location: /usr/local/go/src/runtime/mprof.go:439:6
func record(r *MemProfileRecord, b *bucket):
0:                                                                entry P:0 S:1
	t0 = (*bucket).mp(b)                                         *memRecord
	t1 = &r.AllocBytes [#0]                                          *int64
	t2 = &t0.alloc_bytes [#2]                                      *uintptr
	t3 = *t2                                                        uintptr
	t4 = convert int64 <- uintptr (t3)                                int64
	*t1 = t4
	t5 = &r.FreeBytes [#1]                                           *int64
	t6 = &t0.free_bytes [#3]                                       *uintptr
	t7 = *t6                                                        uintptr
	t8 = convert int64 <- uintptr (t7)                                int64
	*t5 = t8
	t9 = &r.AllocObjects [#2]                                        *int64
	t10 = &t0.allocs [#0]                                          *uintptr
	t11 = *t10                                                      uintptr
	t12 = convert int64 <- uintptr (t11)                              int64
	*t9 = t12
	t13 = &r.FreeObjects [#3]                                        *int64
	t14 = &t0.frees [#1]                                           *uintptr
	t15 = *t14                                                      uintptr
	t16 = convert int64 <- uintptr (t15)                              int64
	*t13 = t16
	t17 = &r.Stack0 [#4]                                       *[32]uintptr
	t18 = slice t17[:]                                            []uintptr
	t19 = (*bucket).stk(b)                                        []uintptr
	t20 = copy(t18, t19)                                                int
	t21 = &b.nstk [#5]                                             *uintptr
	t22 = *t21                                                      uintptr
	t23 = convert int <- uintptr (t22)                                  int
	jump 3
1:                                                             for.body P:1 S:1
	t24 = &r.Stack0 [#4]                                       *[32]uintptr
	t25 = &t24[t27]                                                *uintptr
	*t25 = 0:uintptr
	t26 = t27 + 1:int                                                   int
	jump 3
2:                                                             for.done P:1 S:0
	return
3:                                                             for.loop P:2 S:2
	t27 = phi [0: t23, 1: t26] #i                                       int
	t28 = t27 < 32:int                                                 bool
	if t28 goto 1 else 2

# Name: runtime.iterate_memprof
# Package: runtime
# Location: /usr/local/go/src/runtime/mprof.go:451:6
func iterate_memprof(fn func(*bucket, uintptr, *uintptr, uintptr, uintptr, uintptr)):
0:                                                                entry P:0 S:1
	t0 = lock(proflock)                                                  ()
	t1 = *mbuckets                                                  *bucket
	jump 3
1:                                                             for.body P:1 S:1
	t2 = (*bucket).mp(t17)                                       *memRecord
	t3 = &t17.nstk [#5]                                            *uintptr
	t4 = *t3                                                        uintptr
	t5 = (*bucket).stk(t17)                                       []uintptr
	t6 = &t5[0:int]                                                *uintptr
	t7 = &t17.size [#4]                                            *uintptr
	t8 = *t7                                                        uintptr
	t9 = &t2.allocs [#0]                                           *uintptr
	t10 = *t9                                                       uintptr
	t11 = &t2.frees [#1]                                           *uintptr
	t12 = *t11                                                      uintptr
	t13 = fn(t17, t4, t6, t8, t10, t12)                                  ()
	t14 = &t17.allnext [#1]                                        **bucket
	t15 = *t14                                                      *bucket
	jump 3
2:                                                             for.done P:1 S:0
	t16 = unlock(proflock)                                               ()
	return
3:                                                             for.loop P:2 S:2
	t17 = phi [0: t1, 1: t15] #b                                    *bucket
	t18 = t17 != nil:*bucket                                           bool
	if t18 goto 1 else 2

# Name: runtime.BlockProfile
# Package: runtime
# Location: /usr/local/go/src/runtime/mprof.go:475:6
func BlockProfile(p []BlockProfileRecord) (n int, ok bool):
0:                                                                entry P:0 S:1
	t0 = lock(proflock)                                                  ()
	t1 = *bbuckets                                                  *bucket
	jump 3
1:                                                             for.body P:1 S:1
	t2 = t7 + 1:int                                                     int
	t3 = &t8.allnext [#1]                                          **bucket
	t4 = *t3                                                        *bucket
	jump 3
2:                                                             for.done P:1 S:2
	t5 = len(p)                                                         int
	t6 = t7 <= t5                                                      bool
	if t6 goto 4 else 5
3:                                                             for.loop P:2 S:2
	t7 = phi [0: 0:int, 1: t2] #n                                       int
	t8 = phi [0: t1, 1: t4] #b                                      *bucket
	t9 = t8 != nil:*bucket                                             bool
	if t9 goto 1 else 2
4:                                                              if.then P:1 S:1
	t10 = *bbuckets                                                 *bucket
	jump 7
5:                                                              if.done P:2 S:0
	t11 = phi [2: false:bool, 7: true:bool] #ok                        bool
	t12 = unlock(proflock)                                               ()
	return t7, t11
6:                                                             for.body P:1 S:1
	t13 = (*bucket).bp(t27)                                    *blockRecord
	t14 = &t26[0:int]                                   *BlockProfileRecord
	t15 = &t14.Count [#0]                                            *int64
	t16 = &t13.count [#0]                                            *int64
	t17 = *t16                                                        int64
	*t15 = t17
	t18 = &t14.Cycles [#1]                                           *int64
	t19 = &t13.cycles [#1]                                           *int64
	t20 = *t19                                                        int64
	*t18 = t20
	t21 = &t14.StackRecord [#2]                                *StackRecord
	t22 = &t21.Stack0 [#0]                                     *[32]uintptr
	t23 = slice t22[:]                                            []uintptr
	t24 = (*bucket).stk(t27)                                      []uintptr
	t25 = copy(t23, t24)                                                int
	jump 10
7:                                                             for.loop P:2 S:2
	t26 = phi [4: p, 9: t33] #p                        []BlockProfileRecord
	t27 = phi [4: t10, 9: t35] #b                                   *bucket
	t28 = t27 != nil:*bucket                                           bool
	if t28 goto 6 else 5
8:                                                             for.body P:1 S:1
	t29 = &t14.StackRecord [#2]                                *StackRecord
	t30 = &t29.Stack0 [#0]                                     *[32]uintptr
	t31 = &t30[t36]                                                *uintptr
	*t31 = 0:uintptr
	t32 = t36 + 1:int                                                   int
	jump 10
9:                                                             for.done P:1 S:1
	t33 = slice t26[1:int:]                            []BlockProfileRecord
	t34 = &t27.allnext [#1]                                        **bucket
	t35 = *t34                                                      *bucket
	jump 7
10:                                                            for.loop P:2 S:2
	t36 = phi [6: t25, 8: t32] #i                                       int
	t37 = t36 < 32:int                                                 bool
	if t37 goto 8 else 9

# Name: runtime.ThreadCreateProfile
# Package: runtime
# Location: /usr/local/go/src/runtime/mprof.go:504:6
func ThreadCreateProfile(p []StackRecord) (n int, ok bool):
0:                                                                entry P:0 S:1
	t0 = convert unsafe.Pointer <- **m (allm)                unsafe.Pointer
	t1 = atomicloadp(t0)                                     unsafe.Pointer
	t2 = convert *m <- unsafe.Pointer (t1)                               *m
	jump 3
1:                                                             for.body P:1 S:1
	t3 = t8 + 1:int                                                     int
	t4 = &t9.alllink [#26]                                              **m
	t5 = *t4                                                             *m
	jump 3
2:                                                             for.done P:1 S:2
	t6 = len(p)                                                         int
	t7 = t8 <= t6                                                      bool
	if t7 goto 4 else 5
3:                                                             for.loop P:2 S:2
	t8 = phi [0: 0:int, 1: t3] #n                                       int
	t9 = phi [0: t2, 1: t5] #mp                                          *m
	t10 = t9 != nil:*m                                                 bool
	if t10 goto 1 else 2
4:                                                              if.then P:1 S:1
	jump 7
5:                                                              if.done P:2 S:0
	t11 = phi [2: false:bool, 7: true:bool] #ok                        bool
	return t8, t11
6:                                                             for.body P:1 S:1
	t12 = &t15.createstack [#31]                               *[32]uintptr
	t13 = *t12                                                  [32]uintptr
	jump 8
7:                                                             for.loop P:2 S:2
	t14 = phi [4: 0:int, 10: t26] #i                                    int
	t15 = phi [4: t2, 10: t28] #mp                                       *m
	t16 = t15 != nil:*m                                                bool
	if t16 goto 6 else 5
8:                                                      rangeindex.loop P:2 S:2
	t17 = phi [6: -1:int, 9: t18]                                       int
	t18 = t17 + 1:int                                                   int
	t19 = t18 < 32:int                                                 bool
	if t19 goto 9 else 10
9:                                                      rangeindex.body P:1 S:1
	t20 = &p[t14]                                              *StackRecord
	t21 = &t20.Stack0 [#0]                                     *[32]uintptr
	t22 = &t21[t18]                                                *uintptr
	t23 = &t15.createstack [#31]                               *[32]uintptr
	t24 = &t23[t18]                                                *uintptr
	t25 = *t24                                                      uintptr
	*t22 = t25
	jump 8
10:                                                     rangeindex.done P:1 S:1
	t26 = t14 + 1:int                                                   int
	t27 = &t15.alllink [#26]                                            **m
	t28 = *t27                                                           *m
	jump 7

# Name: runtime.GoroutineProfile$1
# Package: runtime
# Location: /usr/local/go/src/runtime/mprof.go:545:8
# Parent: GoroutineProfile
# Free variables:
#   0:	pc *uintptr
#   1:	sp *uintptr
#   2:	gp **g
#   3:	r *[]StackRecord
func GoroutineProfile$1():
0:                                                                entry P:0 S:0
	t0 = *pc                                                        uintptr
	t1 = *sp                                                        uintptr
	t2 = *gp                                                             *g
	t3 = *r                                                   []StackRecord
	t4 = &t3[0:int]                                            *StackRecord
	t5 = saveg(t0, t1, t2, t4)                                           ()
	return

# Name: runtime.GoroutineProfile
# Package: runtime
# Location: /usr/local/go/src/runtime/mprof.go:530:6
func GoroutineProfile(p []StackRecord) (n int, ok bool):
0:                                                                entry P:0 S:2
	t0 = new []StackRecord (p)                               *[]StackRecord
	*t0 = p
	t1 = NumGoroutine()                                                 int
	t2 = *t0                                                  []StackRecord
	t3 = len(t2)                                                        int
	t4 = t1 <= t3                                                      bool
	if t4 goto 1 else 2
1:                                                              if.then P:1 S:2
	t5 = new *g (gp)                                                    **g
	t6 = getg()                                                          *g
	*t5 = t6
	t7 = semacquire(worldsema, false:bool)                               ()
	t8 = *t5                                                             *g
	t9 = &t8.m [#21]                                                    **m
	t10 = *t9                                                            *m
	t11 = &t10.gcing [#13]                                           *int32
	*t11 = 1:int32
	t12 = onM(stoptheworld)                                              ()
	t13 = NumGoroutine()                                                int
	t14 = *t0                                                 []StackRecord
	t15 = len(t14)                                                      int
	t16 = t13 <= t15                                                   bool
	if t16 goto 3 else 4
2:                                                              if.done P:2 S:0
	t17 = phi [0: t1, 4: t13] #n                                        int
	t18 = phi [0: false:bool, 4: t33] #ok                              bool
	return t17, t18
3:                                                              if.then P:1 S:1
	t19 = new []StackRecord (r)                              *[]StackRecord
	t20 = *t0                                                 []StackRecord
	*t19 = t20
	t21 = new uintptr (sp)                                         *uintptr
	t22 = convert unsafe.Pointer <- *[]StackRecord (t0)      unsafe.Pointer
	t23 = getcallersp(t22)                                          uintptr
	*t21 = t23
	t24 = new uintptr (pc)                                         *uintptr
	t25 = convert unsafe.Pointer <- *[]StackRecord (t0)      unsafe.Pointer
	t26 = getcallerpc(t25)                                          uintptr
	*t24 = t26
	t27 = make closure GoroutineProfile$1 [t24, t21, t5, t19]        func()
	t28 = onM(t27)                                                       ()
	t29 = *t19                                                []StackRecord
	t30 = slice t29[1:int:]                                   []StackRecord
	*t19 = t30
	t31 = *allgs                                                       []*g
	t32 = len(t31)                                                      int
	jump 5
4:                                                              if.done P:2 S:1
	t33 = phi [1: false:bool, 5: true:bool] #ok                        bool
	t34 = *t5                                                            *g
	t35 = &t34.m [#21]                                                  **m
	t36 = *t35                                                           *m
	t37 = &t36.gcing [#13]                                           *int32
	*t37 = 0:int32
	t38 = semrelease(worldsema)                                          ()
	t39 = onM(starttheworld)                                             ()
	jump 2
5:                                                      rangeindex.loop P:4 S:2
	t40 = phi [3: -1:int, 6: t41, 7: t41, 8: t41]                       int
	t41 = t40 + 1:int                                                   int
	t42 = t41 < t32                                                    bool
	if t42 goto 6 else 4
6:                                                      rangeindex.body P:1 S:2
	t43 = &t31[t41]                                                     **g
	t44 = *t43                                                           *g
	t45 = *t5                                                            *g
	t46 = t44 == t45                                                   bool
	if t46 goto 5 else 8
7:                                                              if.done P:1 S:1
	t47 = *t19                                                []StackRecord
	t48 = &t47[0:int]                                          *StackRecord
	t49 = saveg(18446744073709551615:uintptr, 18446744073709551615:uintptr, t44, t48) ()
	t50 = *t19                                                []StackRecord
	t51 = slice t50[1:int:]                                   []StackRecord
	*t19 = t51
	jump 5
8:                                                           cond.false P:1 S:2
	t52 = readgstatus(t44)                                           uint32
	t53 = t52 == 6:uint32                                              bool
	if t53 goto 5 else 7

# Name: runtime.saveg
# Package: runtime
# Location: /usr/local/go/src/runtime/mprof.go:566:6
func saveg(pc uintptr, sp uintptr, gp *g, r *StackRecord):
0:                                                                entry P:0 S:2
	t0 = &r.Stack0 [#0]                                        *[32]uintptr
	t1 = &t0[0:int]                                                *uintptr
	t2 = gentraceback(pc, sp, 0:uintptr, gp, 0:int, t1, 32:int, nil:func(*stkframe, unsafe.Pointer) bool, nil:unsafe.Pointer, 0:uint) int
	t3 = t2 < 32:int                                                   bool
	if t3 goto 1 else 2
1:                                                              if.then P:1 S:1
	t4 = &r.Stack0 [#0]                                        *[32]uintptr
	t5 = &t4[t2]                                                   *uintptr
	*t5 = 0:uintptr
	jump 2
2:                                                              if.done P:2 S:0
	return

# Name: runtime.Stack$1
# Package: runtime
# Location: /usr/local/go/src/runtime/mprof.go:590:7
# Parent: Stack
# Free variables:
#   0:	buf *[]byte
#   1:	gp **g
#   2:	pc *uintptr
#   3:	sp *uintptr
#   4:	all *bool
#   5:	n *int
func Stack$1():
0:                                                                entry P:0 S:2
	t0 = getg()                                                          *g
	t1 = &t0.writebuf [#24]                                         *[]byte
	t2 = *buf                                                        []byte
	t3 = *buf                                                        []byte
	t4 = len(t3)                                                        int
	t5 = slice t2[0:int:0:int:t4]                                    []byte
	*t1 = t5
	t6 = *gp                                                             *g
	t7 = goroutineheader(t6)                                             ()
	t8 = *pc                                                        uintptr
	t9 = *sp                                                        uintptr
	t10 = *gp                                                            *g
	t11 = traceback(t8, t9, 0:uintptr, t10)                              ()
	t12 = *all                                                         bool
	if t12 goto 1 else 2
1:                                                              if.then P:1 S:1
	t13 = *gp                                                            *g
	t14 = tracebackothers(t13)                                           ()
	jump 2
2:                                                              if.done P:2 S:0
	t15 = &t0.writebuf [#24]                                        *[]byte
	t16 = *t15                                                       []byte
	t17 = len(t16)                                                      int
	*n = t17
	t18 = &t0.writebuf [#24]                                        *[]byte
	*t18 = nil:[]byte
	return

# Name: runtime.Stack
# Package: runtime
# Location: /usr/local/go/src/runtime/mprof.go:577:6
func Stack(buf []byte, all bool) int:
0:                                                                entry P:0 S:2
	t0 = new []byte (buf)                                           *[]byte
	*t0 = buf
	t1 = new bool (all)                                               *bool
	*t1 = all
	t2 = *t1                                                           bool
	if t2 goto 1 else 2
1:                                                              if.then P:1 S:1
	t3 = semacquire(worldsema, false:bool)                               ()
	t4 = getg()                                                          *g
	t5 = &t4.m [#21]                                                    **m
	t6 = *t5                                                             *m
	t7 = &t6.gcing [#13]                                             *int32
	*t7 = 1:int32
	t8 = onM(stoptheworld)                                               ()
	jump 2
2:                                                              if.done P:2 S:2
	t9 = new int (n)                                                   *int
	*t9 = 0:int
	t10 = *t0                                                        []byte
	t11 = len(t10)                                                      int
	t12 = t11 > 0:int                                                  bool
	if t12 goto 3 else 4
3:                                                              if.then P:1 S:1
	t13 = new *g (gp)                                                   **g
	t14 = getg()                                                         *g
	*t13 = t14
	t15 = new uintptr (sp)                                         *uintptr
	t16 = convert unsafe.Pointer <- *[]byte (t0)             unsafe.Pointer
	t17 = getcallersp(t16)                                          uintptr
	*t15 = t17
	t18 = new uintptr (pc)                                         *uintptr
	t19 = convert unsafe.Pointer <- *[]byte (t0)             unsafe.Pointer
	t20 = getcallerpc(t19)                                          uintptr
	*t18 = t20
	t21 = make closure Stack$1 [t0, t13, t18, t15, t1, t9]           func()
	t22 = onM(t21)                                                       ()
	jump 4
4:                                                              if.done P:2 S:2
	t23 = *t1                                                          bool
	if t23 goto 5 else 6
5:                                                              if.then P:1 S:1
	t24 = getg()                                                         *g
	t25 = &t24.m [#21]                                                  **m
	t26 = *t25                                                           *m
	t27 = &t26.gcing [#13]                                           *int32
	*t27 = 0:int32
	t28 = semrelease(worldsema)                                          ()
	t29 = onM(starttheworld)                                             ()
	jump 6
6:                                                              if.done P:2 S:0
	t30 = *t9                                                           int
	return t30

# Name: runtime.tracealloc$1
# Package: runtime
# Location: /usr/local/go/src/runtime/mprof.go:629:7
# Parent: tracealloc
# Free variables:
#   0:	pc *uintptr
#   1:	sp *uintptr
#   2:	gp **g
func tracealloc$1():
0:                                                                entry P:0 S:0
	t0 = *pc                                                        uintptr
	t1 = *sp                                                        uintptr
	t2 = *gp                                                             *g
	t3 = traceback(t0, t1, 0:uintptr, t2)                                ()
	return

# Name: runtime.tracealloc
# Package: runtime
# Location: /usr/local/go/src/runtime/mprof.go:616:6
func tracealloc(p unsafe.Pointer, size uintptr, typ *_type):
0:                                                                entry P:0 S:2
	t0 = new unsafe.Pointer (p)                             *unsafe.Pointer
	*t0 = p
	t1 = lock(tracelock)                                                 ()
	t2 = new *g (gp)                                                    **g
	t3 = getg()                                                          *g
	*t2 = t3
	t4 = *t2                                                             *g
	t5 = &t4.m [#21]                                                    **m
	t6 = *t5                                                             *m
	t7 = &t6.traceback [#42]                                         *uint8
	*t7 = 2:uint8
	t8 = typ == nil:*_type                                             bool
	if t8 goto 1 else 3
1:                                                              if.then P:1 S:1
	t9 = *t0                                                 unsafe.Pointer
	t10 = convert hex <- uintptr (size)                                 hex
	t11 = print("tracealloc(":string, t9, ", ":string, t10, ")\n":string) ()
	jump 2
2:                                                              if.done P:2 S:2
	t12 = *t2                                                            *g
	t13 = &t12.m [#21]                                                  **m
	t14 = *t13                                                           *m
	t15 = &t14.curg [#6]                                                **g
	t16 = *t15                                                           *g
	t17 = t16 == nil:*g                                                bool
	if t17 goto 4 else 7
3:                                                              if.else P:1 S:1
	t18 = *t0                                                unsafe.Pointer
	t19 = convert hex <- uintptr (size)                                 hex
	t20 = &typ._string [#8]                                        **string
	t21 = *t20                                                      *string
	t22 = *t21                                                       string
	t23 = print("tracealloc(":string, t18, ", ":string, t19, ", ":string, t22, ")\n":string) ()
	jump 2
4:                                                              if.then P:2 S:1
	t24 = *t2                                                            *g
	t25 = goroutineheader(t24)                                           ()
	t26 = new uintptr (pc)                                         *uintptr
	t27 = convert unsafe.Pointer <- *unsafe.Pointer (t0)     unsafe.Pointer
	t28 = getcallerpc(t27)                                          uintptr
	*t26 = t28
	t29 = new uintptr (sp)                                         *uintptr
	t30 = convert unsafe.Pointer <- *unsafe.Pointer (t0)     unsafe.Pointer
	t31 = getcallersp(t30)                                          uintptr
	*t29 = t31
	t32 = make closure tracealloc$1 [t26, t29, t2]                   func()
	t33 = onM(t32)                                                       ()
	jump 5
5:                                                              if.done P:2 S:0
	t34 = print("\n":string)                                             ()
	t35 = *t2                                                            *g
	t36 = &t35.m [#21]                                                  **m
	t37 = *t36                                                           *m
	t38 = &t37.traceback [#42]                                       *uint8
	*t38 = 0:uint8
	t39 = unlock(tracelock)                                              ()
	return
6:                                                              if.else P:1 S:1
	t40 = *t2                                                            *g
	t41 = &t40.m [#21]                                                  **m
	t42 = *t41                                                           *m
	t43 = &t42.curg [#6]                                                **g
	t44 = *t43                                                           *g
	t45 = goroutineheader(t44)                                           ()
	t46 = *t2                                                            *g
	t47 = &t46.m [#21]                                                  **m
	t48 = *t47                                                           *m
	t49 = &t48.curg [#6]                                                **g
	t50 = *t49                                                           *g
	t51 = traceback(18446744073709551615:uintptr, 18446744073709551615:uintptr, 0:uintptr, t50) ()
	jump 5
7:                                                           cond.false P:1 S:2
	t52 = *t2                                                            *g
	t53 = *t2                                                            *g
	t54 = &t53.m [#21]                                                  **m
	t55 = *t54                                                           *m
	t56 = &t55.curg [#6]                                                **g
	t57 = *t56                                                           *g
	t58 = t52 == t57                                                   bool
	if t58 goto 4 else 6

# Name: runtime.tracefree$1
# Package: runtime
# Location: /usr/local/go/src/runtime/mprof.go:649:6
# Parent: tracefree
# Free variables:
#   0:	pc *uintptr
#   1:	sp *uintptr
#   2:	gp **g
func tracefree$1():
0:                                                                entry P:0 S:0
	t0 = *pc                                                        uintptr
	t1 = *sp                                                        uintptr
	t2 = *gp                                                             *g
	t3 = traceback(t0, t1, 0:uintptr, t2)                                ()
	return

# Name: runtime.tracefree
# Package: runtime
# Location: /usr/local/go/src/runtime/mprof.go:641:6
func tracefree(p unsafe.Pointer, size uintptr):
0:                                                                entry P:0 S:0
	t0 = new unsafe.Pointer (p)                             *unsafe.Pointer
	*t0 = p
	t1 = lock(tracelock)                                                 ()
	t2 = new *g (gp)                                                    **g
	t3 = getg()                                                          *g
	*t2 = t3
	t4 = *t2                                                             *g
	t5 = &t4.m [#21]                                                    **m
	t6 = *t5                                                             *m
	t7 = &t6.traceback [#42]                                         *uint8
	*t7 = 2:uint8
	t8 = *t0                                                 unsafe.Pointer
	t9 = convert hex <- uintptr (size)                                  hex
	t10 = print("tracefree(":string, t8, ", ":string, t9, ")\n":string)  ()
	t11 = *t2                                                            *g
	t12 = goroutineheader(t11)                                           ()
	t13 = new uintptr (pc)                                         *uintptr
	t14 = convert unsafe.Pointer <- *unsafe.Pointer (t0)     unsafe.Pointer
	t15 = getcallerpc(t14)                                          uintptr
	*t13 = t15
	t16 = new uintptr (sp)                                         *uintptr
	t17 = convert unsafe.Pointer <- *unsafe.Pointer (t0)     unsafe.Pointer
	t18 = getcallersp(t17)                                          uintptr
	*t16 = t18
	t19 = make closure tracefree$1 [t13, t16, t2]                    func()
	t20 = onM(t19)                                                       ()
	t21 = print("\n":string)                                             ()
	t22 = *t2                                                            *g
	t23 = &t22.m [#21]                                                  **m
	t24 = *t23                                                           *m
	t25 = &t24.traceback [#42]                                       *uint8
	*t25 = 0:uint8
	t26 = unlock(tracelock)                                              ()
	return

# Name: runtime.tracegc
# Package: runtime
# Location: /usr/local/go/src/runtime/mprof.go:657:6
func tracegc():
0:                                                                entry P:0 S:0
	t0 = lock(tracelock)                                                 ()
	t1 = getg()                                                          *g
	t2 = &t1.m [#21]                                                    **m
	t3 = *t2                                                             *m
	t4 = &t3.traceback [#42]                                         *uint8
	*t4 = 2:uint8
	t5 = print("tracegc()\n":string)                                     ()
	t6 = tracebackothers(t1)                                             ()
	t7 = print("end tracegc\n":string)                                   ()
	t8 = print("\n":string)                                              ()
	t9 = &t1.m [#21]                                                    **m
	t10 = *t9                                                            *m
	t11 = &t10.traceback [#42]                                       *uint8
	*t11 = 0:uint8
	t12 = unlock(tracelock)                                              ()
	return

# Name: runtime.netpollServerInit
# Package: runtime
# Location: /usr/local/go/src/runtime/netpoll.go:74:6
func netpollServerInit():
0:                                                                entry P:0 S:0
	t0 = onM(netpollinit)                                                ()
	return

# Name: runtime.netpollOpen$1
# Package: runtime
# Location: /usr/local/go/src/runtime/netpoll.go:97:6
# Parent: netpollOpen
# Free variables:
#   0:	errno *int32
#   1:	fd *uintptr
#   2:	pd **pollDesc
func netpollOpen$1():
0:                                                                entry P:0 S:0
	t0 = *fd                                                        uintptr
	t1 = *pd                                                      *pollDesc
	t2 = netpollopen(t0, t1)                                          int32
	*errno = t2
	return

# Name: runtime.netpollOpen
# Package: runtime
# Location: /usr/local/go/src/runtime/netpoll.go:78:6
func netpollOpen(fd uintptr) (*pollDesc, int):
0:                                                                entry P:0 S:2
	t0 = new uintptr (fd)                                          *uintptr
	*t0 = fd
	t1 = new *pollDesc (pd)                                      **pollDesc
	t2 = (*pollCache).alloc(pollcache)                            *pollDesc
	*t1 = t2
	t3 = *t1                                                      *pollDesc
	t4 = &t3.lock [#1]                                               *mutex
	t5 = lock(t4)                                                        ()
	t6 = *t1                                                      *pollDesc
	t7 = &t6.wg [#8]                                               *uintptr
	t8 = *t7                                                        uintptr
	t9 = t8 != 0:uintptr                                               bool
	if t9 goto 3 else 2
1:                                                              if.then P:1 S:1
	t10 = gothrow("netpollOpen: bloc...":string)                         ()
	jump 2
2:                                                              if.done P:3 S:2
	t11 = *t1                                                     *pollDesc
	t12 = &t11.rg [#5]                                             *uintptr
	t13 = *t12                                                      uintptr
	t14 = t13 != 0:uintptr                                             bool
	if t14 goto 6 else 5
3:                                                            cond.true P:1 S:2
	t15 = *t1                                                     *pollDesc
	t16 = &t15.wg [#8]                                             *uintptr
	t17 = *t16                                                      uintptr
	t18 = t17 != 1:uintptr                                             bool
	if t18 goto 1 else 2
4:                                                              if.then P:1 S:1
	t19 = gothrow("netpollOpen: bloc...":string)                         ()
	jump 5
5:                                                              if.done P:3 S:0
	t20 = *t1                                                     *pollDesc
	t21 = &t20.fd [#2]                                             *uintptr
	t22 = *t0                                                       uintptr
	*t21 = t22
	t23 = *t1                                                     *pollDesc
	t24 = &t23.closing [#3]                                           *bool
	*t24 = false:bool
	t25 = *t1                                                     *pollDesc
	t26 = &t25.seq [#4]                                            *uintptr
	t27 = *t26                                                      uintptr
	t28 = t27 + 1:uintptr                                           uintptr
	*t26 = t28
	t29 = *t1                                                     *pollDesc
	t30 = &t29.rg [#5]                                             *uintptr
	*t30 = 0:uintptr
	t31 = *t1                                                     *pollDesc
	t32 = &t31.rd [#7]                                               *int64
	*t32 = 0:int64
	t33 = *t1                                                     *pollDesc
	t34 = &t33.wg [#8]                                             *uintptr
	*t34 = 0:uintptr
	t35 = *t1                                                     *pollDesc
	t36 = &t35.wd [#10]                                              *int64
	*t36 = 0:int64
	t37 = *t1                                                     *pollDesc
	t38 = &t37.lock [#1]                                             *mutex
	t39 = unlock(t38)                                                    ()
	t40 = new int32 (errno)                                          *int32
	t41 = make closure netpollOpen$1 [t40, t0, t1]                   func()
	t42 = onM(t41)                                                       ()
	t43 = *t1                                                     *pollDesc
	t44 = *t40                                                        int32
	t45 = convert int <- int32 (t44)                                    int
	return t43, t45
6:                                                            cond.true P:1 S:2
	t46 = *t1                                                     *pollDesc
	t47 = &t46.rg [#5]                                             *uintptr
	t48 = *t47                                                      uintptr
	t49 = t48 != 1:uintptr                                             bool
	if t49 goto 4 else 5

# Name: runtime.netpollClose$1
# Package: runtime
# Location: /usr/local/go/src/runtime/netpoll.go:113:6
# Parent: netpollClose
# Free variables:
#   0:	pd **pollDesc
func netpollClose$1():
0:                                                                entry P:0 S:0
	t0 = *pd                                                      *pollDesc
	t1 = &t0.fd [#2]                                               *uintptr
	t2 = *t1                                                        uintptr
	t3 = netpollclose(t2)                                             int32
	return

# Name: runtime.netpollClose
# Package: runtime
# Location: /usr/local/go/src/runtime/netpoll.go:103:6
func netpollClose(pd *pollDesc):
0:                                                                entry P:0 S:2
	t0 = new *pollDesc (pd)                                      **pollDesc
	*t0 = pd
	t1 = *t0                                                      *pollDesc
	t2 = &t1.closing [#3]                                             *bool
	t3 = *t2                                                           bool
	if t3 goto 2 else 1
1:                                                              if.then P:1 S:1
	t4 = gothrow("netpollClose: clo...":string)                          ()
	jump 2
2:                                                              if.done P:2 S:2
	t5 = *t0                                                      *pollDesc
	t6 = &t5.wg [#8]                                               *uintptr
	t7 = *t6                                                        uintptr
	t8 = t7 != 0:uintptr                                               bool
	if t8 goto 5 else 4
3:                                                              if.then P:1 S:1
	t9 = gothrow("netpollClose: blo...":string)                          ()
	jump 4
4:                                                              if.done P:3 S:2
	t10 = *t0                                                     *pollDesc
	t11 = &t10.rg [#5]                                             *uintptr
	t12 = *t11                                                      uintptr
	t13 = t12 != 0:uintptr                                             bool
	if t13 goto 8 else 7
5:                                                            cond.true P:1 S:2
	t14 = *t0                                                     *pollDesc
	t15 = &t14.wg [#8]                                             *uintptr
	t16 = *t15                                                      uintptr
	t17 = t16 != 1:uintptr                                             bool
	if t17 goto 3 else 4
6:                                                              if.then P:1 S:1
	t18 = gothrow("netpollClose: blo...":string)                         ()
	jump 7
7:                                                              if.done P:3 S:0
	t19 = make closure netpollClose$1 [t0]                           func()
	t20 = onM(t19)                                                       ()
	t21 = *t0                                                     *pollDesc
	t22 = (*pollCache).free(pollcache, t21)                              ()
	return
8:                                                            cond.true P:1 S:2
	t23 = *t0                                                     *pollDesc
	t24 = &t23.rg [#5]                                             *uintptr
	t25 = *t24                                                      uintptr
	t26 = t25 != 1:uintptr                                             bool
	if t26 goto 6 else 7

# Name: (*runtime.pollCache).free
# Package: runtime
# Location: /usr/local/go/src/runtime/netpoll.go:119:21
func (c *pollCache) free(pd *pollDesc):
0:                                                                entry P:0 S:0
	t0 = &c.lock [#0]                                                *mutex
	t1 = lock(t0)                                                        ()
	t2 = &pd.link [#0]                                           **pollDesc
	t3 = &c.first [#1]                                           **pollDesc
	t4 = *t3                                                      *pollDesc
	*t2 = t4
	t5 = &c.first [#1]                                           **pollDesc
	*t5 = pd
	t6 = &c.lock [#0]                                                *mutex
	t7 = unlock(t6)                                                      ()
	return

# Name: runtime.netpollReset
# Package: runtime
# Location: /usr/local/go/src/runtime/netpoll.go:126:6
func netpollReset(pd *pollDesc, mode int) int:
0:                                                                entry P:0 S:2
	t0 = convert int32 <- int (mode)                                  int32
	t1 = netpollcheckerr(pd, t0)                                        int
	t2 = t1 != 0:int                                                   bool
	if t2 goto 1 else 2
1:                                                              if.then P:1 S:0
	return t1
2:                                                              if.done P:1 S:2
	t3 = mode == 114:int                                               bool
	if t3 goto 3 else 5
3:                                                              if.then P:1 S:1
	t4 = &pd.rg [#5]                                               *uintptr
	*t4 = 0:uintptr
	jump 4
4:                                                              if.done P:3 S:0
	return 0:int
5:                                                              if.else P:1 S:2
	t5 = mode == 119:int                                               bool
	if t5 goto 6 else 4
6:                                                              if.then P:1 S:1
	t6 = &pd.wg [#8]                                               *uintptr
	*t6 = 0:uintptr
	jump 4

# Name: runtime.netpollWait$1
# Package: runtime
# Location: /usr/local/go/src/runtime/netpoll.go:146:7
# Parent: netpollWait
# Free variables:
#   0:	pd **pollDesc
#   1:	mode *int
func netpollWait$1():
0:                                                                entry P:0 S:0
	t0 = *pd                                                      *pollDesc
	t1 = *mode                                                          int
	t2 = netpollarm(t0, t1)                                              ()
	return

# Name: runtime.netpollWait
# Package: runtime
# Location: /usr/local/go/src/runtime/netpoll.go:139:6
func netpollWait(pd *pollDesc, mode int) int:
0:                                                                entry P:0 S:2
	t0 = new *pollDesc (pd)                                      **pollDesc
	*t0 = pd
	t1 = new int (mode)                                                *int
	*t1 = mode
	t2 = *t0                                                      *pollDesc
	t3 = *t1                                                            int
	t4 = convert int32 <- int (t3)                                    int32
	t5 = netpollcheckerr(t2, t4)                                        int
	t6 = t5 != 0:int                                                   bool
	if t6 goto 1 else 2
1:                                                              if.then P:1 S:0
	return t5
2:                                                              if.done P:1 S:2
	if false:untyped bool goto 3 else 6
3:                                                              if.then P:1 S:1
	t7 = make closure netpollWait$1 [t0, t1]                         func()
	t8 = onM(t7)                                                         ()
	jump 6
4:                                                             for.body P:1 S:2
	t9 = *t0                                                      *pollDesc
	t10 = *t1                                                           int
	t11 = convert int32 <- int (t10)                                  int32
	t12 = netpollcheckerr(t9, t11)                                      int
	t13 = t12 != 0:int                                                 bool
	if t13 goto 7 else 6
5:                                                             for.done P:1 S:0
	return 0:int
6:                                                             for.loop P:3 S:2
	t14 = *t0                                                     *pollDesc
	t15 = *t1                                                           int
	t16 = convert int32 <- int (t15)                                  int32
	t17 = netpollblock(t14, t16, false:bool)                           bool
	if t17 goto 5 else 4
7:                                                              if.then P:1 S:0
	return t12

# Name: runtime.netpollWaitCanceled
# Package: runtime
# Location: /usr/local/go/src/runtime/netpoll.go:162:6
func netpollWaitCanceled(pd *pollDesc, mode int):
0:                                                                entry P:0 S:1
	jump 2
1:                                                             for.done P:1 S:0
	return
2:                                                             for.loop P:2 S:2
	t0 = convert int32 <- int (mode)                                  int32
	t1 = netpollblock(pd, t0, true:bool)                               bool
	if t1 goto 1 else 2

# Name: runtime.netpollSetDeadline
# Package: runtime
# Location: /usr/local/go/src/runtime/netpoll.go:169:6
func netpollSetDeadline(pd *pollDesc, d int64, mode int):
0:                                                                entry P:0 S:2
	t0 = &pd.lock [#1]                                               *mutex
	t1 = lock(t0)                                                        ()
	t2 = &pd.closing [#3]                                             *bool
	t3 = *t2                                                           bool
	if t3 goto 1 else 2
1:                                                              if.then P:1 S:0
	t4 = &pd.lock [#1]                                               *mutex
	t5 = unlock(t4)                                                      ()
	return
2:                                                              if.done P:1 S:2
	t6 = &pd.seq [#4]                                              *uintptr
	t7 = *t6                                                        uintptr
	t8 = t7 + 1:uintptr                                             uintptr
	*t6 = t8
	t9 = &pd.rt [#6]                                                 *timer
	t10 = &t9.f [#3]                            *func(interface{}, uintptr)
	t11 = *t10                                   func(interface{}, uintptr)
	t12 = t11 != nil:func(interface{}, uintptr)                        bool
	if t12 goto 3 else 4
3:                                                              if.then P:1 S:1
	t13 = &pd.rt [#6]                                                *timer
	t14 = deltimer(t13)                                                bool
	t15 = &pd.rt [#6]                                                *timer
	t16 = &t15.f [#3]                           *func(interface{}, uintptr)
	*t16 = nil:func(interface{}, uintptr)
	jump 4
4:                                                              if.done P:2 S:2
	t17 = &pd.wt [#9]                                                *timer
	t18 = &t17.f [#3]                           *func(interface{}, uintptr)
	t19 = *t18                                   func(interface{}, uintptr)
	t20 = t19 != nil:func(interface{}, uintptr)                        bool
	if t20 goto 5 else 6
5:                                                              if.then P:1 S:1
	t21 = &pd.wt [#9]                                                *timer
	t22 = deltimer(t21)                                                bool
	t23 = &pd.wt [#9]                                                *timer
	t24 = &t23.f [#3]                           *func(interface{}, uintptr)
	*t24 = nil:func(interface{}, uintptr)
	jump 6
6:                                                              if.done P:2 S:2
	t25 = d != 0:int64                                                 bool
	if t25 goto 9 else 8
7:                                                              if.then P:1 S:1
	jump 8
8:                                                              if.done P:3 S:2
	t26 = phi [6: d, 9: d, 7: -1:int64] #d                            int64
	t27 = mode == 114:int                                              bool
	if t27 goto 10 else 12
9:                                                            cond.true P:1 S:2
	t28 = nanotime()                                                  int64
	t29 = d <= t28                                                     bool
	if t29 goto 7 else 8
10:                                                             if.then P:2 S:1
	t30 = &pd.rd [#7]                                                *int64
	*t30 = t26
	jump 11
11:                                                             if.done P:2 S:2
	t31 = mode == 119:int                                              bool
	if t31 goto 13 else 15
12:                                                          cond.false P:1 S:2
	t32 = mode == 233:int                                              bool
	if t32 goto 10 else 11
13:                                                             if.then P:2 S:1
	t33 = &pd.wd [#10]                                               *int64
	*t33 = t26
	jump 14
14:                                                             if.done P:2 S:2
	t34 = &pd.rd [#7]                                                *int64
	t35 = *t34                                                        int64
	t36 = t35 > 0:int64                                                bool
	if t36 goto 19 else 18
15:                                                          cond.false P:1 S:2
	t37 = mode == 233:int                                              bool
	if t37 goto 13 else 14
16:                                                             if.then P:1 S:1
	t38 = &pd.rt [#6]                                                *timer
	t39 = &t38.f [#3]                           *func(interface{}, uintptr)
	*t39 = netpollDeadline
	t40 = &pd.rt [#6]                                                *timer
	t41 = &t40.when [#1]                                             *int64
	t42 = &pd.rd [#7]                                                *int64
	t43 = *t42                                                        int64
	*t41 = t43
	t44 = &pd.rt [#6]                                                *timer
	t45 = &t44.arg [#4]                                        *interface{}
	t46 = make interface{} <- *pollDesc (pd)                    interface{}
	*t45 = t46
	t47 = &pd.rt [#6]                                                *timer
	t48 = &t47.seq [#5]                                            *uintptr
	t49 = &pd.seq [#4]                                             *uintptr
	t50 = *t49                                                      uintptr
	*t48 = t50
	t51 = &pd.rt [#6]                                                *timer
	t52 = addtimer(t51)                                                  ()
	jump 17
17:                                                             if.done P:3 S:2
	t53 = new *g (wg)                                                   **g
	t54 = convert unsafe.Pointer <- **g (t53)                unsafe.Pointer
	t55 = atomicstorep(t54, nil:unsafe.Pointer)                          ()
	t56 = &pd.rd [#7]                                                *int64
	t57 = *t56                                                        int64
	t58 = t57 < 0:int64                                                bool
	if t58 goto 23 else 24
18:                                                             if.else P:2 S:2
	t59 = &pd.rd [#7]                                                *int64
	t60 = *t59                                                        int64
	t61 = t60 > 0:int64                                                bool
	if t61 goto 20 else 21
19:                                                           cond.true P:1 S:2
	t62 = &pd.rd [#7]                                                *int64
	t63 = *t62                                                        int64
	t64 = &pd.wd [#10]                                               *int64
	t65 = *t64                                                        int64
	t66 = t63 == t65                                                   bool
	if t66 goto 16 else 18
20:                                                             if.then P:1 S:1
	t67 = &pd.rt [#6]                                                *timer
	t68 = &t67.f [#3]                           *func(interface{}, uintptr)
	*t68 = netpollReadDeadline
	t69 = &pd.rt [#6]                                                *timer
	t70 = &t69.when [#1]                                             *int64
	t71 = &pd.rd [#7]                                                *int64
	t72 = *t71                                                        int64
	*t70 = t72
	t73 = &pd.rt [#6]                                                *timer
	t74 = &t73.arg [#4]                                        *interface{}
	t75 = make interface{} <- *pollDesc (pd)                    interface{}
	*t74 = t75
	t76 = &pd.rt [#6]                                                *timer
	t77 = &t76.seq [#5]                                            *uintptr
	t78 = &pd.seq [#4]                                             *uintptr
	t79 = *t78                                                      uintptr
	*t77 = t79
	t80 = &pd.rt [#6]                                                *timer
	t81 = addtimer(t80)                                                  ()
	jump 21
21:                                                             if.done P:2 S:2
	t82 = &pd.wd [#10]                                               *int64
	t83 = *t82                                                        int64
	t84 = t83 > 0:int64                                                bool
	if t84 goto 22 else 17
22:                                                             if.then P:1 S:1
	t85 = &pd.wt [#9]                                                *timer
	t86 = &t85.f [#3]                           *func(interface{}, uintptr)
	*t86 = netpollWriteDeadline
	t87 = &pd.wt [#9]                                                *timer
	t88 = &t87.when [#1]                                             *int64
	t89 = &pd.wd [#10]                                               *int64
	t90 = *t89                                                        int64
	*t88 = t90
	t91 = &pd.wt [#9]                                                *timer
	t92 = &t91.arg [#4]                                        *interface{}
	t93 = make interface{} <- *pollDesc (pd)                    interface{}
	*t92 = t93
	t94 = &pd.wt [#9]                                                *timer
	t95 = &t94.seq [#5]                                            *uintptr
	t96 = &pd.seq [#4]                                             *uintptr
	t97 = *t96                                                      uintptr
	*t95 = t97
	t98 = &pd.wt [#9]                                                *timer
	t99 = addtimer(t98)                                                  ()
	jump 17
23:                                                             if.then P:1 S:1
	t100 = netpollunblock(pd, 114:int32, false:bool)                     *g
	jump 24
24:                                                             if.done P:2 S:2
	t101 = phi [17: nil:*g, 23: t100] #rg                                *g
	t102 = &pd.wd [#10]                                              *int64
	t103 = *t102                                                      int64
	t104 = t103 < 0:int64                                              bool
	if t104 goto 25 else 26
25:                                                             if.then P:1 S:1
	t105 = netpollunblock(pd, 119:int32, false:bool)                     *g
	*t53 = t105
	jump 26
26:                                                             if.done P:2 S:2
	t106 = &pd.lock [#1]                                             *mutex
	t107 = unlock(t106)                                                  ()
	t108 = t101 != nil:*g                                              bool
	if t108 goto 27 else 28
27:                                                             if.then P:1 S:1
	t109 = goready(t101)                                                 ()
	jump 28
28:                                                             if.done P:2 S:2
	t110 = *t53                                                          *g
	t111 = t110 != nil:*g                                              bool
	if t111 goto 29 else 30
29:                                                             if.then P:1 S:1
	t112 = *t53                                                          *g
	t113 = goready(t112)                                                 ()
	jump 30
30:                                                             if.done P:2 S:0
	return

# Name: runtime.netpollUnblock
# Package: runtime
# Location: /usr/local/go/src/runtime/netpoll.go:238:6
func netpollUnblock(pd *pollDesc):
0:                                                                entry P:0 S:2
	t0 = &pd.lock [#1]                                               *mutex
	t1 = lock(t0)                                                        ()
	t2 = &pd.closing [#3]                                             *bool
	t3 = *t2                                                           bool
	if t3 goto 1 else 2
1:                                                              if.then P:1 S:1
	t4 = gothrow("netpollUnblock: a...":string)                          ()
	jump 2
2:                                                              if.done P:2 S:2
	t5 = &pd.closing [#3]                                             *bool
	*t5 = true:bool
	t6 = &pd.seq [#4]                                              *uintptr
	t7 = *t6                                                        uintptr
	t8 = t7 + 1:uintptr                                             uintptr
	*t6 = t8
	t9 = new *g (rg)                                                    **g
	t10 = convert unsafe.Pointer <- **g (t9)                 unsafe.Pointer
	t11 = atomicstorep(t10, nil:unsafe.Pointer)                          ()
	t12 = netpollunblock(pd, 114:int32, false:bool)                      *g
	*t9 = t12
	t13 = netpollunblock(pd, 119:int32, false:bool)                      *g
	t14 = &pd.rt [#6]                                                *timer
	t15 = &t14.f [#3]                           *func(interface{}, uintptr)
	t16 = *t15                                   func(interface{}, uintptr)
	t17 = t16 != nil:func(interface{}, uintptr)                        bool
	if t17 goto 3 else 4
3:                                                              if.then P:1 S:1
	t18 = &pd.rt [#6]                                                *timer
	t19 = deltimer(t18)                                                bool
	t20 = &pd.rt [#6]                                                *timer
	t21 = &t20.f [#3]                           *func(interface{}, uintptr)
	*t21 = nil:func(interface{}, uintptr)
	jump 4
4:                                                              if.done P:2 S:2
	t22 = &pd.wt [#9]                                                *timer
	t23 = &t22.f [#3]                           *func(interface{}, uintptr)
	t24 = *t23                                   func(interface{}, uintptr)
	t25 = t24 != nil:func(interface{}, uintptr)                        bool
	if t25 goto 5 else 6
5:                                                              if.then P:1 S:1
	t26 = &pd.wt [#9]                                                *timer
	t27 = deltimer(t26)                                                bool
	t28 = &pd.wt [#9]                                                *timer
	t29 = &t28.f [#3]                           *func(interface{}, uintptr)
	*t29 = nil:func(interface{}, uintptr)
	jump 6
6:                                                              if.done P:2 S:2
	t30 = &pd.lock [#1]                                              *mutex
	t31 = unlock(t30)                                                    ()
	t32 = *t9                                                            *g
	t33 = t32 != nil:*g                                                bool
	if t33 goto 7 else 8
7:                                                              if.then P:1 S:1
	t34 = *t9                                                            *g
	t35 = goready(t34)                                                   ()
	jump 8
8:                                                              if.done P:2 S:2
	t36 = t13 != nil:*g                                                bool
	if t36 goto 9 else 10
9:                                                              if.then P:1 S:1
	t37 = goready(t13)                                                   ()
	jump 10
10:                                                             if.done P:2 S:0
	return

# Name: runtime.netpollfd
# Package: runtime
# Location: /usr/local/go/src/runtime/netpoll.go:266:6
func netpollfd(pd *pollDesc) uintptr:
0:                                                                entry P:0 S:0
	t0 = &pd.fd [#2]                                               *uintptr
	t1 = *t0                                                        uintptr
	return t1

# Name: runtime.netpolluser
# Package: runtime
# Location: /usr/local/go/src/runtime/netpoll.go:270:6
func netpolluser(pd *pollDesc) *unsafe.Pointer:
0:                                                                entry P:0 S:0
	t0 = &pd.user [#11]                                     *unsafe.Pointer
	return t0

# Name: runtime.netpollclosing
# Package: runtime
# Location: /usr/local/go/src/runtime/netpoll.go:274:6
func netpollclosing(pd *pollDesc) bool:
0:                                                                entry P:0 S:0
	t0 = &pd.closing [#3]                                             *bool
	t1 = *t0                                                           bool
	return t1

# Name: runtime.netpolllock
# Package: runtime
# Location: /usr/local/go/src/runtime/netpoll.go:278:6
func netpolllock(pd *pollDesc):
0:                                                                entry P:0 S:0
	t0 = &pd.lock [#1]                                               *mutex
	t1 = lock(t0)                                                        ()
	return

# Name: runtime.netpollunlock
# Package: runtime
# Location: /usr/local/go/src/runtime/netpoll.go:282:6
func netpollunlock(pd *pollDesc):
0:                                                                entry P:0 S:0
	t0 = &pd.lock [#1]                                               *mutex
	t1 = unlock(t0)                                                      ()
	return

# Name: runtime.netpollready
# Package: runtime
# Location: /usr/local/go/src/runtime/netpoll.go:287:6
func netpollready(gpp **g, pd *pollDesc, mode int32):
0:                                                                entry P:0 S:2
	t0 = mode == 114:int32                                             bool
	if t0 goto 1 else 3
1:                                                              if.then P:2 S:1
	t1 = netpollunblock(pd, 114:int32, true:bool)                        *g
	jump 2
2:                                                              if.done P:2 S:2
	t2 = phi [3: nil:*g, 1: t1] #rg                                      *g
	t3 = mode == 119:int32                                             bool
	if t3 goto 4 else 6
3:                                                           cond.false P:1 S:2
	t4 = mode == 233:int32                                             bool
	if t4 goto 1 else 2
4:                                                              if.then P:2 S:1
	t5 = netpollunblock(pd, 119:int32, true:bool)                        *g
	jump 5
5:                                                              if.done P:2 S:2
	t6 = phi [6: nil:*g, 4: t5] #wg                                      *g
	t7 = t2 != nil:*g                                                  bool
	if t7 goto 7 else 8
6:                                                           cond.false P:1 S:2
	t8 = mode == 233:int32                                             bool
	if t8 goto 4 else 5
7:                                                              if.then P:1 S:1
	t9 = &t2.schedlink [#13]                                            **g
	t10 = *gpp                                                           *g
	*t9 = t10
	*gpp = t2
	jump 8
8:                                                              if.done P:2 S:2
	t11 = t6 != nil:*g                                                 bool
	if t11 goto 9 else 10
9:                                                              if.then P:1 S:1
	t12 = &t6.schedlink [#13]                                           **g
	t13 = *gpp                                                           *g
	*t12 = t13
	*gpp = t6
	jump 10
10:                                                             if.done P:2 S:0
	return

# Name: runtime.netpollcheckerr
# Package: runtime
# Location: /usr/local/go/src/runtime/netpoll.go:305:6
func netpollcheckerr(pd *pollDesc, mode int32) int:
0:                                                                entry P:0 S:2
	t0 = &pd.closing [#3]                                             *bool
	t1 = *t0                                                           bool
	if t1 goto 1 else 2
1:                                                              if.then P:1 S:0
	return 1:int
2:                                                              if.done P:1 S:2
	t2 = mode == 114:int32                                             bool
	if t2 goto 6 else 5
3:                                                              if.then P:2 S:0
	return 2:int
4:                                                              if.done P:2 S:0
	return 0:int
5:                                                           cond.false P:2 S:2
	t3 = mode == 119:int32                                             bool
	if t3 goto 7 else 4
6:                                                            cond.true P:1 S:2
	t4 = &pd.rd [#7]                                                 *int64
	t5 = *t4                                                          int64
	t6 = t5 < 0:int64                                                  bool
	if t6 goto 3 else 5
7:                                                            cond.true P:1 S:2
	t7 = &pd.wd [#10]                                                *int64
	t8 = *t7                                                          int64
	t9 = t8 < 0:int64                                                  bool
	if t9 goto 3 else 4

# Name: runtime.netpollblockcommit
# Package: runtime
# Location: /usr/local/go/src/runtime/netpoll.go:315:6
func netpollblockcommit(gp *g, gpp unsafe.Pointer) bool:
0:                                                                entry P:0 S:0
	t0 = convert *uintptr <- unsafe.Pointer (gpp)                  *uintptr
	t1 = convert unsafe.Pointer <- *g (gp)                   unsafe.Pointer
	t2 = convert uintptr <- unsafe.Pointer (t1)                     uintptr
	t3 = casuintptr(t0, 2:uintptr, t2)                                 bool
	return t3

# Name: runtime.netpollblock
# Package: runtime
# Location: /usr/local/go/src/runtime/netpoll.go:321:6
func netpollblock(pd *pollDesc, mode int32, waitio bool) bool:
0:                                                                entry P:0 S:2
	t0 = &pd.rg [#5]                                               *uintptr
	t1 = mode == 119:int32                                             bool
	if t1 goto 1 else 2
1:                                                              if.then P:1 S:1
	t2 = &pd.wg [#8]                                               *uintptr
	jump 2
2:                                                             for.body P:3 S:2
	t3 = phi [0: t0, 6: t3, 1: t2] #gpp                            *uintptr
	t4 = *t3                                                        uintptr
	t5 = t4 == 1:uintptr                                               bool
	if t5 goto 3 else 4
3:                                                              if.then P:1 S:0
	*t3 = 0:uintptr
	return true:bool
4:                                                              if.done P:1 S:2
	t6 = t4 != 0:uintptr                                               bool
	if t6 goto 5 else 6
5:                                                              if.then P:1 S:1
	t7 = gothrow("netpollblock: dou...":string)                          ()
	jump 6
6:                                                              if.done P:2 S:2
	t8 = casuintptr(t3, 0:uintptr, 2:uintptr)                          bool
	if t8 goto 7 else 2
7:                                                              if.then P:1 S:2
	if waitio goto 8 else 10
8:                                                              if.then P:2 S:1
	t9 = new func(gp *g, gpp unsafe.Pointer) bool (f) *func(gp *g, gpp unsafe.Pointer) bool
	*t9 = netpollblockcommit
	t10 = convert unsafe.Pointer <- *func(gp *g, gpp unsafe.Pointer) bool (t9) unsafe.Pointer
	t11 = convert **unsafe.Pointer <- unsafe.Pointer (t10) **unsafe.Pointer
	t12 = *t11                                              *unsafe.Pointer
	t13 = *t12                                               unsafe.Pointer
	t14 = convert unsafe.Pointer <- *uintptr (t3)            unsafe.Pointer
	t15 = gopark(t13, t14, "IO wait":string)                             ()
	jump 9
9:                                                              if.done P:2 S:2
	t16 = xchguintptr(t3, 0:uintptr)                                uintptr
	t17 = t16 > 2:uintptr                                              bool
	if t17 goto 11 else 12
10:                                                          cond.false P:1 S:2
	t18 = netpollcheckerr(pd, mode)                                     int
	t19 = t18 == 0:int                                                 bool
	if t19 goto 8 else 9
11:                                                             if.then P:1 S:1
	t20 = gothrow("netpollblock: cor...":string)                         ()
	jump 12
12:                                                             if.done P:2 S:0
	t21 = t16 == 1:uintptr                                             bool
	return t21

# Name: runtime.netpollunblock
# Package: runtime
# Location: /usr/local/go/src/runtime/netpoll.go:357:6
func netpollunblock(pd *pollDesc, mode int32, ioready bool) *g:
0:                                                                entry P:0 S:2
	t0 = &pd.rg [#5]                                               *uintptr
	t1 = mode == 119:int32                                             bool
	if t1 goto 1 else 2
1:                                                              if.then P:1 S:1
	t2 = &pd.wg [#8]                                               *uintptr
	jump 2
2:                                                             for.body P:3 S:2
	t3 = phi [0: t0, 9: t3, 1: t2] #gpp                            *uintptr
	t4 = *t3                                                        uintptr
	t5 = t4 == 1:uintptr                                               bool
	if t5 goto 3 else 4
3:                                                              if.then P:1 S:0
	return nil:*g
4:                                                              if.done P:1 S:2
	t6 = t4 == 0:uintptr                                               bool
	if t6 goto 7 else 6
5:                                                              if.then P:1 S:0
	return nil:*g
6:                                                              if.done P:2 S:2
	if ioready goto 8 else 9
7:                                                            cond.true P:1 S:2
	if ioready goto 6 else 5
8:                                                              if.then P:1 S:1
	jump 9
9:                                                              if.done P:2 S:2
	t7 = phi [6: 0:uintptr, 8: 1:uintptr] #new                      uintptr
	t8 = casuintptr(t3, t4, t7)                                        bool
	if t8 goto 10 else 2
10:                                                             if.then P:1 S:2
	t9 = t4 == 1:uintptr                                               bool
	if t9 goto 11 else 13
11:                                                             if.then P:2 S:1
	jump 12
12:                                                             if.done P:2 S:0
	t10 = phi [13: t4, 11: 0:uintptr] #old                          uintptr
	t11 = convert unsafe.Pointer <- uintptr (t10)            unsafe.Pointer
	t12 = convert *g <- unsafe.Pointer (t11)                             *g
	return t12
13:                                                          cond.false P:1 S:2
	t13 = t4 == 2:uintptr                                              bool
	if t13 goto 11 else 12

# Name: runtime.netpolldeadlineimpl
# Package: runtime
# Location: /usr/local/go/src/runtime/netpoll.go:386:6
func netpolldeadlineimpl(pd *pollDesc, seq uintptr, read bool, write bool):
0:                                                                entry P:0 S:2
	t0 = &pd.lock [#1]                                               *mutex
	t1 = lock(t0)                                                        ()
	t2 = &pd.seq [#4]                                              *uintptr
	t3 = *t2                                                        uintptr
	t4 = seq != t3                                                     bool
	if t4 goto 1 else 2
1:                                                              if.then P:1 S:0
	t5 = &pd.lock [#1]                                               *mutex
	t6 = unlock(t5)                                                      ()
	return
2:                                                              if.done P:1 S:2
	if read goto 3 else 4
3:                                                              if.then P:1 S:2
	t7 = &pd.rd [#7]                                                 *int64
	t8 = *t7                                                          int64
	t9 = t8 <= 0:int64                                                 bool
	if t9 goto 5 else 7
4:                                                              if.done P:2 S:2
	t10 = phi [2: nil:*g, 6: t17] #rg                                    *g
	if write goto 8 else 9
5:                                                              if.then P:2 S:1
	t11 = gothrow("netpolldeadlineim...":string)                         ()
	jump 6
6:                                                              if.done P:2 S:1
	t12 = &pd.rd [#7]                                                *int64
	*t12 = -1:int64
	t13 = &pd.rt [#6]                                                *timer
	t14 = &t13.f [#3]                           *func(interface{}, uintptr)
	t15 = convert unsafe.Pointer <- *func(interface{}, uintptr) (t14) unsafe.Pointer
	t16 = atomicstorep(t15, nil:unsafe.Pointer)                          ()
	t17 = netpollunblock(pd, 114:int32, false:bool)                      *g
	jump 4
7:                                                           cond.false P:1 S:2
	t18 = &pd.rt [#6]                                                *timer
	t19 = &t18.f [#3]                           *func(interface{}, uintptr)
	t20 = *t19                                   func(interface{}, uintptr)
	t21 = t20 == nil:func(interface{}, uintptr)                        bool
	if t21 goto 5 else 6
8:                                                              if.then P:1 S:2
	t22 = &pd.wd [#10]                                               *int64
	t23 = *t22                                                        int64
	t24 = t23 <= 0:int64                                               bool
	if t24 goto 10 else 12
9:                                                              if.done P:2 S:2
	t25 = phi [4: nil:*g, 11: t35] #wg                                   *g
	t26 = &pd.lock [#1]                                              *mutex
	t27 = unlock(t26)                                                    ()
	t28 = t10 != nil:*g                                                bool
	if t28 goto 14 else 15
10:                                                             if.then P:2 S:1
	t29 = gothrow("netpolldeadlineim...":string)                         ()
	jump 11
11:                                                             if.done P:3 S:1
	t30 = &pd.wd [#10]                                               *int64
	*t30 = -1:int64
	t31 = &pd.wt [#9]                                                *timer
	t32 = &t31.f [#3]                           *func(interface{}, uintptr)
	t33 = convert unsafe.Pointer <- *func(interface{}, uintptr) (t32) unsafe.Pointer
	t34 = atomicstorep(t33, nil:unsafe.Pointer)                          ()
	t35 = netpollunblock(pd, 119:int32, false:bool)                      *g
	jump 9
12:                                                          cond.false P:1 S:2
	t36 = &pd.wt [#9]                                                *timer
	t37 = &t36.f [#3]                           *func(interface{}, uintptr)
	t38 = *t37                                   func(interface{}, uintptr)
	t39 = t38 == nil:func(interface{}, uintptr)                        bool
	if t39 goto 13 else 11
13:                                                           cond.true P:1 S:2
	if read goto 11 else 10
14:                                                             if.then P:1 S:1
	t40 = goready(t10)                                                   ()
	jump 15
15:                                                             if.done P:2 S:2
	t41 = t25 != nil:*g                                                bool
	if t41 goto 16 else 17
16:                                                             if.then P:1 S:1
	t42 = goready(t25)                                                   ()
	jump 17
17:                                                             if.done P:2 S:0
	return

# Name: runtime.netpollDeadline
# Package: runtime
# Location: /usr/local/go/src/runtime/netpoll.go:422:6
func netpollDeadline(arg interface{}, seq uintptr):
0:                                                                entry P:0 S:0
	t0 = typeassert arg.(*pollDesc)                               *pollDesc
	t1 = netpolldeadlineimpl(t0, seq, true:bool, true:bool)              ()
	return

# Name: runtime.netpollReadDeadline
# Package: runtime
# Location: /usr/local/go/src/runtime/netpoll.go:426:6
func netpollReadDeadline(arg interface{}, seq uintptr):
0:                                                                entry P:0 S:0
	t0 = typeassert arg.(*pollDesc)                               *pollDesc
	t1 = netpolldeadlineimpl(t0, seq, true:bool, false:bool)             ()
	return

# Name: runtime.netpollWriteDeadline
# Package: runtime
# Location: /usr/local/go/src/runtime/netpoll.go:430:6
func netpollWriteDeadline(arg interface{}, seq uintptr):
0:                                                                entry P:0 S:0
	t0 = typeassert arg.(*pollDesc)                               *pollDesc
	t1 = netpolldeadlineimpl(t0, seq, false:bool, true:bool)             ()
	return

# Name: (*runtime.pollCache).alloc
# Package: runtime
# Location: /usr/local/go/src/runtime/netpoll.go:434:21
func (c *pollCache) alloc() *pollDesc:
0:                                                                entry P:0 S:2
	t0 = &c.lock [#0]                                                *mutex
	t1 = lock(t0)                                                        ()
	t2 = &c.first [#1]                                           **pollDesc
	t3 = *t2                                                      *pollDesc
	t4 = t3 == nil:*pollDesc                                           bool
	if t4 goto 1 else 2
1:                                                              if.then P:1 S:2
	t5 = 21:uintptr == 0:uintptr                                       bool
	if t5 goto 3 else 4
2:                                                              if.done P:2 S:0
	t6 = &c.first [#1]                                           **pollDesc
	t7 = *t6                                                      *pollDesc
	t8 = &c.first [#1]                                           **pollDesc
	t9 = &t7.link [#0]                                           **pollDesc
	t10 = *t9                                                     *pollDesc
	*t8 = t10
	t11 = &c.lock [#0]                                               *mutex
	t12 = unlock(t11)                                                    ()
	return t7
3:                                                              if.then P:1 S:1
	jump 4
4:                                                              if.done P:2 S:1
	t13 = phi [1: 21:uintptr, 3: 1:uintptr] #n                      uintptr
	t14 = t13 * 192:uintptr                                         uintptr
	t15 = &memstats.other_sys [#20]                                 *uint64
	t16 = persistentalloc(t14, 0:uintptr, t15)               unsafe.Pointer
	jump 6
5:                                                             for.body P:1 S:1
	t17 = t25 * 192:uintptr                                         uintptr
	t18 = add(t16, t17)                                      unsafe.Pointer
	t19 = convert *pollDesc <- unsafe.Pointer (t18)               *pollDesc
	t20 = &t19.link [#0]                                         **pollDesc
	t21 = &c.first [#1]                                          **pollDesc
	t22 = *t21                                                    *pollDesc
	*t20 = t22
	t23 = &c.first [#1]                                          **pollDesc
	*t23 = t19
	t24 = t25 + 1:uintptr                                           uintptr
	jump 6
6:                                                             for.loop P:2 S:2
	t25 = phi [4: 0:uintptr, 5: t24] #i                             uintptr
	t26 = t25 < t13                                                    bool
	if t26 goto 5 else 2

# Name: runtime.netpollinit
# Package: runtime
# Location: /usr/local/go/src/runtime/netpoll_kqueue.go:24:6
func netpollinit():
0:                                                                entry P:0 S:2
	t0 = kqueue()                                                     int32
	*kq = t0
	t1 = *kq                                                          int32
	t2 = t1 < 0:int32                                                  bool
	if t2 goto 1 else 2
1:                                                              if.then P:1 S:1
	t3 = *kq                                                          int32
	t4 = -t3                                                          int32
	t5 = println("netpollinit: kque...":string, t4)                      ()
	t6 = gothrow("netpollinit: kque...":string)                          ()
	jump 2
2:                                                              if.done P:2 S:0
	t7 = *kq                                                          int32
	t8 = closeonexec(t7)                                                 ()
	return

# Name: runtime.netpollopen
# Package: runtime
# Location: /usr/local/go/src/runtime/netpoll_kqueue.go:33:6
func netpollopen(fd uintptr, pd *pollDesc) int32:
0:                                                                entry P:0 S:2
	t0 = new [2]keventt (ev)                                    *[2]keventt
	t1 = &t0[0:int]                                                *keventt
	t2 = &t1.ident [#0]                                             *uint64
	t3 = convert unsafe.Pointer <- *uint64 (t2)              unsafe.Pointer
	t4 = convert *uintptr <- unsafe.Pointer (t3)                   *uintptr
	*t4 = fd
	t5 = &t0[0:int]                                                *keventt
	t6 = &t5.filter [#1]                                             *int16
	*t6 = -1:int16
	t7 = &t0[0:int]                                                *keventt
	t8 = &t7.flags [#2]                                             *uint16
	*t8 = 33:uint16
	t9 = &t0[0:int]                                                *keventt
	t10 = &t9.fflags [#3]                                           *uint32
	*t10 = 0:uint32
	t11 = &t0[0:int]                                               *keventt
	t12 = &t11.data [#4]                                             *int64
	*t12 = 0:int64
	t13 = &t0[0:int]                                               *keventt
	t14 = &t13.udata [#5]                                            **byte
	t15 = convert unsafe.Pointer <- *pollDesc (pd)           unsafe.Pointer
	t16 = convert *byte <- unsafe.Pointer (t15)                       *byte
	*t14 = t16
	t17 = &t0[1:int]                                               *keventt
	t18 = &t0[0:int]                                               *keventt
	t19 = *t18                                                      keventt
	*t17 = t19
	t20 = &t0[1:int]                                               *keventt
	t21 = &t20.filter [#1]                                           *int16
	*t21 = -2:int16
	t22 = *kq                                                         int32
	t23 = &t0[0:int]                                               *keventt
	t24 = kevent(t22, t23, 2:int32, nil:*keventt, 0:int32, nil:*timespec) int32
	t25 = t24 < 0:int32                                                bool
	if t25 goto 1 else 2
1:                                                              if.then P:1 S:0
	t26 = -t24                                                        int32
	return t26
2:                                                              if.done P:1 S:0
	return 0:int32

# Name: runtime.netpollclose
# Package: runtime
# Location: /usr/local/go/src/runtime/netpoll_kqueue.go:53:6
func netpollclose(fd uintptr) int32:
0:                                                                entry P:0 S:0
	return 0:int32

# Name: runtime.netpollarm
# Package: runtime
# Location: /usr/local/go/src/runtime/netpoll_kqueue.go:59:6
func netpollarm(pd *pollDesc, mode int):
0:                                                                entry P:0 S:0
	t0 = gothrow("unused":string)                                        ()
	return

# Name: runtime.netpoll
# Package: runtime
# Location: /usr/local/go/src/runtime/netpoll_kqueue.go:65:6
func netpoll(block bool) (gp *g):
0:                                                                entry P:0 S:2
	t0 = new *g (gp)                                                    **g
	t1 = *kq                                                          int32
	t2 = t1 == -1:int32                                                bool
	if t2 goto 1 else 2
1:                                                              if.then P:1 S:0
	t3 = *t0                                                             *g
	return t3
2:                                                              if.done P:1 S:2
	t4 = new timespec (ts)                                        *timespec
	if block goto 4 else 3
3:                                                              if.then P:1 S:1
	jump 4
4:                                                              if.done P:2 S:1
	t5 = phi [2: nil:*timespec, 3: t4] #tp                        *timespec
	t6 = new [64]keventt (events)                              *[64]keventt
	jump 5
5:                                                                retry P:5 S:2
	t7 = phi [4: nil:*keventt, 6: t7, 20: t24, 9: t7, 8: t7] #ev   *keventt
	t8 = phi [4: 0:int32, 6: t8, 20: t25, 9: t8, 8: t8] #mode         int32
	t9 = *kq                                                          int32
	t10 = &t6[0:int]                                               *keventt
	t11 = kevent(t9, nil:*keventt, 0:int32, t10, 64:int32, t5)        int32
	t12 = t11 < 0:int32                                                bool
	if t12 goto 6 else 7
6:                                                              if.then P:1 S:2
	t13 = t11 != -4:int32                                              bool
	if t13 goto 9 else 5
7:                                                              if.done P:1 S:1
	jump 12
8:                                                              if.then P:1 S:1
	*netpolllasterr = t11
	t14 = *kq                                                         int32
	t15 = -t11                                                        int32
	t16 = println("runtime: kevent o...":string, t14, "failed with":string, t15) ()
	jump 5
9:                                                            cond.true P:1 S:2
	t17 = *netpolllasterr                                             int32
	t18 = t11 != t17                                                   bool
	if t18 goto 8 else 5
10:                                                            for.body P:1 S:2
	t19 = &t6[t23]                                                 *keventt
	t20 = &t19.filter [#1]                                           *int16
	t21 = *t20                                                        int16
	t22 = t21 == -1:int16                                              bool
	if t22 goto 13 else 14
11:                                                            for.done P:1 S:2
	if block goto 20 else 19
12:                                                            for.loop P:2 S:2
	t23 = phi [7: 0:int, 18: t44] #i                                    int
	t24 = phi [7: t7, 18: t19] #ev                                 *keventt
	t25 = phi [7: t8, 18: t34] #mode                                  int32
	t26 = convert int <- int32 (t11)                                    int
	t27 = t23 < t26                                                    bool
	if t27 goto 10 else 11
13:                                                             if.then P:1 S:1
	t28 = 0:int32 + 114:int32                                         int32
	jump 14
14:                                                             if.done P:2 S:2
	t29 = phi [10: 0:int32, 13: t28] #mode                            int32
	t30 = &t19.filter [#1]                                           *int16
	t31 = *t30                                                        int16
	t32 = t31 == -2:int16                                              bool
	if t32 goto 15 else 16
15:                                                             if.then P:1 S:1
	t33 = t29 + 119:int32                                             int32
	jump 16
16:                                                             if.done P:2 S:2
	t34 = phi [14: t29, 15: t33] #mode                                int32
	t35 = t34 != 0:int32                                               bool
	if t35 goto 17 else 18
17:                                                             if.then P:1 S:1
	t36 = convert unsafe.Pointer <- **g (t0)                 unsafe.Pointer
	t37 = noescape(t36)                                      unsafe.Pointer
	t38 = convert **g <- unsafe.Pointer (t37)                           **g
	t39 = &t19.udata [#5]                                            **byte
	t40 = *t39                                                        *byte
	t41 = convert unsafe.Pointer <- *byte (t40)              unsafe.Pointer
	t42 = convert *pollDesc <- unsafe.Pointer (t41)               *pollDesc
	t43 = netpollready(t38, t42, t34)                                    ()
	jump 18
18:                                                             if.done P:2 S:1
	t44 = t23 + 1:int                                                   int
	jump 12
19:                                                             if.done P:2 S:0
	t45 = *t0                                                            *g
	*t0 = t45
	t46 = *t0                                                            *g
	return t46
20:                                                           cond.true P:1 S:2
	t47 = *t0                                                            *g
	t48 = t47 == nil:*g                                                bool
	if t48 goto 5 else 19

# Name: runtime.panicindex
# Package: runtime
# Location: /usr/local/go/src/runtime/panic.go:11:6
func panicindex():
0:                                                                entry P:0 S:0
	t0 = *indexError                                                  error
	t1 = change interface interface{} <- error (t0)             interface{}
	panic t1

# Name: runtime.panicslice
# Package: runtime
# Location: /usr/local/go/src/runtime/panic.go:17:6
func panicslice():
0:                                                                entry P:0 S:0
	t0 = *sliceError                                                  error
	t1 = change interface interface{} <- error (t0)             interface{}
	panic t1

# Name: runtime.panicdivide
# Package: runtime
# Location: /usr/local/go/src/runtime/panic.go:23:6
func panicdivide():
0:                                                                entry P:0 S:0
	t0 = *divideError                                                 error
	t1 = change interface interface{} <- error (t0)             interface{}
	panic t1

# Name: runtime.panicoverflow
# Package: runtime
# Location: /usr/local/go/src/runtime/panic.go:29:6
func panicoverflow():
0:                                                                entry P:0 S:0
	t0 = *overflowError                                               error
	t1 = change interface interface{} <- error (t0)             interface{}
	panic t1

# Name: runtime.panicfloat
# Package: runtime
# Location: /usr/local/go/src/runtime/panic.go:35:6
func panicfloat():
0:                                                                entry P:0 S:0
	t0 = *floatError                                                  error
	t1 = change interface interface{} <- error (t0)             interface{}
	panic t1

# Name: runtime.panicmem
# Package: runtime
# Location: /usr/local/go/src/runtime/panic.go:41:6
func panicmem():
0:                                                                entry P:0 S:0
	t0 = *memoryError                                                 error
	t1 = change interface interface{} <- error (t0)             interface{}
	panic t1

# Name: runtime.throwreturn
# Package: runtime
# Location: /usr/local/go/src/runtime/panic.go:45:6
func throwreturn():
0:                                                                entry P:0 S:0
	t0 = gothrow("no return at end ...":string)                          ()
	return

# Name: runtime.throwinit
# Package: runtime
# Location: /usr/local/go/src/runtime/panic.go:49:6
func throwinit():
0:                                                                entry P:0 S:0
	t0 = gothrow("recursive call du...":string)                          ()
	return

# Name: runtime.deferproc
# Package: runtime
# Location: /usr/local/go/src/runtime/panic.go:56:6
func deferproc(siz int32, fn *funcval):
0:                                                                entry P:0 S:2
	t0 = new int32 (siz)                                             *int32
	*t0 = siz
	t1 = new *funcval (fn)                                        **funcval
	*t1 = fn
	t2 = convert unsafe.Pointer <- **funcval (t1)            unsafe.Pointer
	t3 = convert uintptr <- unsafe.Pointer (t2)                     uintptr
	t4 = t3 + 8:uintptr                                             uintptr
	if false:untyped bool goto 1 else 2
1:                                                              if.then P:1 S:1
	t5 = t4 + 8:uintptr                                             uintptr
	jump 2
2:                                                              if.done P:2 S:2
	t6 = phi [0: t4, 1: t5] #argp                                   uintptr
	t7 = acquirem()                                                      *m
	t8 = &t7.scalararg [#45]                                    *[4]uintptr
	t9 = &t8[0:int]                                                *uintptr
	t10 = *t0                                                         int32
	t11 = convert uintptr <- int32 (t10)                            uintptr
	*t9 = t11
	t12 = &t7.ptrarg [#46]                               *[4]unsafe.Pointer
	t13 = &t12[0:int]                                       *unsafe.Pointer
	t14 = *t1                                                      *funcval
	t15 = convert unsafe.Pointer <- *funcval (t14)           unsafe.Pointer
	*t13 = t15
	t16 = &t7.scalararg [#45]                                   *[4]uintptr
	t17 = &t16[1:int]                                              *uintptr
	*t17 = t6
	t18 = &t7.scalararg [#45]                                   *[4]uintptr
	t19 = &t18[2:int]                                              *uintptr
	t20 = convert unsafe.Pointer <- *int32 (t0)              unsafe.Pointer
	t21 = getcallerpc(t20)                                          uintptr
	*t19 = t21
	t22 = &t7.curg [#6]                                                 **g
	t23 = *t22                                                           *g
	t24 = getg()                                                         *g
	t25 = t23 != t24                                                   bool
	if t25 goto 3 else 4
3:                                                              if.then P:1 S:1
	t26 = gothrow("defer on m":string)                                   ()
	jump 4
4:                                                              if.done P:2 S:0
	t27 = onM(deferproc_m)                                               ()
	t28 = releasem(t7)                                                   ()
	t29 = return0()                                                      ()
	return

# Name: runtime.deferclass
# Package: runtime
# Location: /usr/local/go/src/runtime/panic.go:105:6
func deferclass(siz uintptr) uintptr:
0:                                                                entry P:0 S:2
	t0 = siz <= 0:uintptr                                              bool
	if t0 goto 1 else 2
1:                                                              if.then P:1 S:0
	return 0:uintptr
2:                                                              if.done P:1 S:0
	t1 = siz - 0:uintptr                                            uintptr
	t2 = t1 + 15:uintptr                                            uintptr
	t3 = t2 / 16:uintptr                                            uintptr
	return t3

# Name: runtime.totaldefersize
# Package: runtime
# Location: /usr/local/go/src/runtime/panic.go:113:6
func totaldefersize(siz uintptr) uintptr:
0:                                                                entry P:0 S:2
	t0 = siz <= 0:uintptr                                              bool
	if t0 goto 1 else 2
1:                                                              if.then P:1 S:0
	return 48:uintptr
2:                                                              if.done P:1 S:0
	t1 = 48:uintptr + siz                                           uintptr
	return t1

# Name: runtime.testdefersizes
# Package: runtime
# Location: /usr/local/go/src/runtime/panic.go:122:6
# Locals:
#   0:	t0 [5]int32
func testdefersizes():
0:                                                                entry P:0 S:1
	t0 = local [5]int32 (m)                                       *[5]int32
	t1 = *t0                                                       [5]int32
	jump 1
1:                                                      rangeindex.loop P:2 S:2
	t2 = phi [0: -1:int, 2: t3]                                         int
	t3 = t2 + 1:int                                                     int
	t4 = t3 < 5:int                                                    bool
	if t4 goto 2 else 3
2:                                                      rangeindex.body P:1 S:1
	t5 = &t0[t3]                                                     *int32
	*t5 = -1:int32
	jump 1
3:                                                      rangeindex.done P:1 S:1
	jump 4
4:                                                             for.body P:2 S:2
	t6 = phi [3: 0:uintptr, 5: t9] #i                               uintptr
	t7 = deferclass(t6)                                             uintptr
	t8 = t7 >= 5:uintptr                                               bool
	if t8 goto 6 else 7
5:                                                             for.post P:3 S:1
	t9 = t6 + 1:uintptr                                             uintptr
	jump 4
6:                                                              if.then P:1 S:0
	return
7:                                                              if.done P:1 S:2
	t10 = totaldefersize(t6)                                        uintptr
	t11 = goroundupsize(t10)                                        uintptr
	t12 = convert int <- uintptr (t7)                                   int
	t13 = &t0[t12]                                                   *int32
	t14 = *t13                                                        int32
	t15 = t14 < 0:int32                                                bool
	if t15 goto 8 else 9
8:                                                              if.then P:1 S:1
	t16 = convert int <- uintptr (t7)                                   int
	t17 = &t0[t16]                                                   *int32
	t18 = convert int32 <- uintptr (t11)                              int32
	*t17 = t18
	jump 5
9:                                                              if.done P:1 S:2
	t19 = convert int <- uintptr (t7)                                   int
	t20 = &t0[t19]                                                   *int32
	t21 = *t20                                                        int32
	t22 = convert int32 <- uintptr (t11)                              int32
	t23 = t21 != t22                                                   bool
	if t23 goto 10 else 5
10:                                                             if.then P:1 S:1
	t24 = print("bad defer size cl...":string, t6, " siz=":string, t11, " defersc=":string, t7, "\n":string) ()
	t25 = gothrow("bad defer size class":string)                         ()
	jump 5

# Name: runtime.deferArgs
# Package: runtime
# Location: /usr/local/go/src/runtime/panic.go:148:6
func deferArgs(d *_defer) unsafe.Pointer:
0:                                                                entry P:0 S:0
	t0 = convert unsafe.Pointer <- *_defer (d)               unsafe.Pointer
	t1 = add(t0, 48:uintptr)                                 unsafe.Pointer
	return t1

# Name: runtime.init#3
# Package: runtime
# Location: /usr/local/go/src/runtime/panic.go:154:6
func init#3():
0:                                                                entry P:0 S:0
	t0 = new interface{} (x)                                   *interface{}
	t1 = make interface{} <- *_defer (nil:*_defer)              interface{}
	*t0 = t1
	t2 = convert unsafe.Pointer <- *interface{} (t0)         unsafe.Pointer
	t3 = convert **ptrtype <- unsafe.Pointer (t2)                 **ptrtype
	t4 = *t3                                                       *ptrtype
	t5 = &t4.elem [#1]                                              **_type
	t6 = *t5                                                         *_type
	*deferType = t6
	return

# Name: runtime.newdefer
# Package: runtime
# Location: /usr/local/go/src/runtime/panic.go:163:6
func newdefer(siz int32) *_defer:
0:                                                                entry P:0 S:2
	t0 = convert uintptr <- int32 (siz)                             uintptr
	t1 = deferclass(t0)                                             uintptr
	t2 = acquirem()                                                      *m
	t3 = t1 < 5:uintptr                                                bool
	if t3 goto 1 else 2
1:                                                              if.then P:1 S:2
	t4 = &t2.p [#8]                                                     **p
	t5 = *t4                                                             *p
	t6 = &t5.deferpool [#8]                                     *[5]*_defer
	t7 = convert int <- uintptr (t1)                                    int
	t8 = &t6[t7]                                                   **_defer
	t9 = *t8                                                        *_defer
	t10 = t9 != nil:*_defer                                            bool
	if t10 goto 3 else 2
2:                                                              if.done P:3 S:2
	t11 = phi [0: nil:*_defer, 1: t9, 3: t9] #d                     *_defer
	t12 = t11 == nil:*_defer                                           bool
	if t12 goto 4 else 5
3:                                                              if.then P:1 S:1
	t13 = &t5.deferpool [#8]                                    *[5]*_defer
	t14 = convert int <- uintptr (t1)                                   int
	t15 = &t13[t14]                                                **_defer
	t16 = &t9.link [#6]                                            **_defer
	t17 = *t16                                                      *_defer
	*t15 = t17
	jump 2
4:                                                              if.then P:1 S:1
	t18 = convert uintptr <- int32 (siz)                            uintptr
	t19 = totaldefersize(t18)                                       uintptr
	t20 = goroundupsize(t19)                                        uintptr
	t21 = *deferType                                                 *_type
	t22 = mallocgc(t20, t21, 0:uint32)                       unsafe.Pointer
	t23 = convert *_defer <- unsafe.Pointer (t22)                   *_defer
	jump 5
5:                                                              if.done P:2 S:0
	t24 = phi [2: t11, 4: t23] #d                                   *_defer
	t25 = &t24.siz [#0]                                              *int32
	*t25 = siz
	t26 = &t2.curg [#6]                                                 **g
	t27 = *t26                                                           *g
	t28 = &t24.link [#6]                                           **_defer
	t29 = &t27._defer [#4]                                         **_defer
	t30 = *t29                                                      *_defer
	*t28 = t30
	t31 = &t27._defer [#4]                                         **_defer
	*t31 = t24
	t32 = releasem(t2)                                                   ()
	return t24

# Name: runtime.freedefer
# Package: runtime
# Location: /usr/local/go/src/runtime/panic.go:190:6
# Locals:
#   0:	t16 _defer
func freedefer(d *_defer):
0:                                                                entry P:0 S:2
	t0 = &d._panic [#5]                                            **_panic
	t1 = *t0                                                        *_panic
	t2 = t1 != nil:*_panic                                             bool
	if t2 goto 1 else 2
1:                                                              if.then P:1 S:1
	t3 = freedeferpanic()                                                ()
	jump 2
2:                                                              if.done P:2 S:2
	t4 = &d.fn [#4]                                               **funcval
	t5 = *t4                                                       *funcval
	t6 = t5 != nil:*funcval                                            bool
	if t6 goto 3 else 4
3:                                                              if.then P:1 S:1
	t7 = freedeferfn()                                                   ()
	jump 4
4:                                                              if.done P:2 S:2
	t8 = &d.siz [#0]                                                 *int32
	t9 = *t8                                                          int32
	t10 = convert uintptr <- int32 (t9)                             uintptr
	t11 = deferclass(t10)                                           uintptr
	t12 = t11 < 5:uintptr                                              bool
	if t12 goto 5 else 6
5:                                                              if.then P:1 S:1
	t13 = acquirem()                                                     *m
	t14 = &t13.p [#8]                                                   **p
	t15 = *t14                                                           *p
	t16 = local _defer ()                                           *_defer
	t17 = *t16                                                       _defer
	*d = t17
	t18 = &d.link [#6]                                             **_defer
	t19 = &t15.deferpool [#8]                                   *[5]*_defer
	t20 = convert int <- uintptr (t11)                                  int
	t21 = &t19[t20]                                                **_defer
	t22 = *t21                                                      *_defer
	*t18 = t22
	t23 = &t15.deferpool [#8]                                   *[5]*_defer
	t24 = convert int <- uintptr (t11)                                  int
	t25 = &t23[t24]                                                **_defer
	*t25 = d
	t26 = releasem(t13)                                                  ()
	jump 6
6:                                                              if.done P:2 S:0
	return

# Name: runtime.freedeferpanic
# Package: runtime
# Location: /usr/local/go/src/runtime/panic.go:210:6
func freedeferpanic():
0:                                                                entry P:0 S:0
	t0 = gothrow("freedefer with d....":string)                          ()
	return

# Name: runtime.freedeferfn
# Package: runtime
# Location: /usr/local/go/src/runtime/panic.go:215:6
func freedeferfn():
0:                                                                entry P:0 S:0
	t0 = gothrow("freedefer with d....":string)                          ()
	return

# Name: runtime.deferreturn
# Package: runtime
# Location: /usr/local/go/src/runtime/panic.go:234:6
func deferreturn(arg0 uintptr):
0:                                                                entry P:0 S:2
	t0 = new uintptr (arg0)                                        *uintptr
	*t0 = arg0
	t1 = getg()                                                          *g
	t2 = &t1._defer [#4]                                           **_defer
	t3 = *t2                                                        *_defer
	t4 = t3 == nil:*_defer                                             bool
	if t4 goto 1 else 2
1:                                                              if.then P:1 S:0
	return
2:                                                              if.done P:1 S:2
	t5 = convert unsafe.Pointer <- *uintptr (t0)             unsafe.Pointer
	t6 = convert uintptr <- unsafe.Pointer (t5)                     uintptr
	t7 = &t3.argp [#2]                                             *uintptr
	t8 = *t7                                                        uintptr
	t9 = t8 != t6                                                      bool
	if t9 goto 3 else 4
3:                                                              if.then P:1 S:0
	return
4:                                                              if.done P:1 S:0
	t10 = acquirem()                                                     *m
	t11 = convert unsafe.Pointer <- uintptr (t6)             unsafe.Pointer
	t12 = deferArgs(t3)                                      unsafe.Pointer
	t13 = &t3.siz [#0]                                               *int32
	t14 = *t13                                                        int32
	t15 = convert uintptr <- int32 (t14)                            uintptr
	t16 = memmove(t11, t12, t15)                                         ()
	t17 = &t3.fn [#4]                                             **funcval
	t18 = *t17                                                     *funcval
	t19 = &t3.fn [#4]                                             **funcval
	*t19 = nil:*funcval
	t20 = &t1._defer [#4]                                          **_defer
	t21 = &t3.link [#6]                                            **_defer
	t22 = *t21                                                      *_defer
	*t20 = t22
	t23 = freedefer(t3)                                                  ()
	t24 = releasem(t10)                                                  ()
	t25 = jmpdefer(t18, t6)                                              ()
	return

# Name: runtime.Goexit
# Package: runtime
# Location: /usr/local/go/src/runtime/panic.go:267:6
func Goexit():
0:                                                                entry P:0 S:1
	t0 = getg()                                                          *g
	jump 1
1:                                                             for.body P:3 S:2
	t1 = &t0._defer [#4]                                           **_defer
	t2 = *t1                                                        *_defer
	t3 = t2 == nil:*_defer                                             bool
	if t3 goto 2 else 3
2:                                                              if.then P:1 S:0
	t4 = goexit()                                                        ()
	return
3:                                                              if.done P:1 S:2
	t5 = &t2.started [#1]                                             *bool
	t6 = *t5                                                           bool
	if t6 goto 4 else 5
4:                                                              if.then P:1 S:2
	t7 = &t2._panic [#5]                                           **_panic
	t8 = *t7                                                        *_panic
	t9 = t8 != nil:*_panic                                             bool
	if t9 goto 6 else 7
5:                                                              if.done P:1 S:2
	t10 = &t2.started [#1]                                            *bool
	*t10 = true:bool
	t11 = &t2.fn [#4]                                             **funcval
	t12 = *t11                                                     *funcval
	t13 = convert unsafe.Pointer <- *funcval (t12)           unsafe.Pointer
	t14 = deferArgs(t2)                                      unsafe.Pointer
	t15 = &t2.siz [#0]                                               *int32
	t16 = *t15                                                        int32
	t17 = convert uint32 <- int32 (t16)                              uint32
	t18 = &t2.siz [#0]                                               *int32
	t19 = *t18                                                        int32
	t20 = convert uint32 <- int32 (t19)                              uint32
	t21 = reflectcall(t13, t14, t17, t20)                                ()
	t22 = &t0._defer [#4]                                          **_defer
	t23 = *t22                                                      *_defer
	t24 = t23 != t2                                                    bool
	if t24 goto 8 else 9
6:                                                              if.then P:1 S:1
	t25 = &t2._panic [#5]                                          **_panic
	t26 = *t25                                                      *_panic
	t27 = &t26.aborted [#4]                                           *bool
	*t27 = true:bool
	t28 = &t2._panic [#5]                                          **_panic
	*t28 = nil:*_panic
	jump 7
7:                                                              if.done P:2 S:1
	t29 = &t2.fn [#4]                                             **funcval
	*t29 = nil:*funcval
	t30 = &t0._defer [#4]                                          **_defer
	t31 = &t2.link [#6]                                            **_defer
	t32 = *t31                                                      *_defer
	*t30 = t32
	t33 = freedefer(t2)                                                  ()
	jump 1
8:                                                              if.then P:1 S:1
	t34 = gothrow("bad defer entry i...":string)                         ()
	jump 9
9:                                                              if.done P:2 S:1
	t35 = &t2._panic [#5]                                          **_panic
	*t35 = nil:*_panic
	t36 = &t2.fn [#4]                                             **funcval
	*t36 = nil:*funcval
	t37 = &t0._defer [#4]                                          **_defer
	t38 = &t2.link [#6]                                            **_defer
	t39 = *t38                                                      *_defer
	*t37 = t39
	t40 = freedefer(t2)                                                  ()
	jump 1

# Name: runtime.printpanics
# Package: runtime
# Location: /usr/local/go/src/runtime/panic.go:304:6
func printpanics(p *_panic):
0:                                                                entry P:0 S:2
	t0 = &p.link [#2]                                              **_panic
	t1 = *t0                                                        *_panic
	t2 = t1 != nil:*_panic                                             bool
	if t2 goto 1 else 2
1:                                                              if.then P:1 S:1
	t3 = &p.link [#2]                                              **_panic
	t4 = *t3                                                        *_panic
	t5 = printpanics(t4)                                                 ()
	t6 = print("\t":string)                                              ()
	jump 2
2:                                                              if.done P:2 S:2
	t7 = print("panic: ":string)                                         ()
	t8 = &p.arg [#1]                                           *interface{}
	t9 = *t8                                                    interface{}
	t10 = printany(t9)                                                   ()
	t11 = &p.recovered [#3]                                           *bool
	t12 = *t11                                                         bool
	if t12 goto 3 else 4
3:                                                              if.then P:1 S:1
	t13 = print(" [recovered]":string)                                   ()
	jump 4
4:                                                              if.done P:2 S:0
	t14 = print("\n":string)                                             ()
	return

# Name: runtime.gopanic
# Package: runtime
# Location: /usr/local/go/src/runtime/panic.go:318:6
func gopanic(e interface{}):
0:                                                                entry P:0 S:2
	t0 = getg()                                                          *g
	t1 = &t0.m [#21]                                                    **m
	t2 = *t1                                                             *m
	t3 = &t2.curg [#6]                                                  **g
	t4 = *t3                                                             *g
	t5 = t4 != t0                                                      bool
	if t5 goto 1 else 2
1:                                                              if.then P:1 S:1
	t6 = gothrow("panic on m stack":string)                              ()
	jump 2
2:                                                              if.done P:2 S:2
	t7 = &t0.m [#21]                                                    **m
	t8 = *t7                                                             *m
	t9 = &t8.softfloat [#15]                                         *int32
	t10 = *t9                                                         int32
	t11 = t10 != 0:int32                                               bool
	if t11 goto 3 else 4
3:                                                              if.then P:1 S:1
	t12 = &t0.m [#21]                                                   **m
	t13 = *t12                                                           *m
	t14 = &t13.locks [#14]                                           *int32
	t15 = *t14                                                        int32
	t16 = t15 - 1:int32                                               int32
	*t14 = t16
	t17 = &t0.m [#21]                                                   **m
	t18 = *t17                                                           *m
	t19 = &t18.softfloat [#15]                                       *int32
	*t19 = 0:int32
	t20 = gothrow("panic during soft...":string)                         ()
	jump 4
4:                                                              if.done P:2 S:2
	t21 = &t0.m [#21]                                                   **m
	t22 = *t21                                                           *m
	t23 = &t22.mallocing [#11]                                       *int32
	t24 = *t23                                                        int32
	t25 = t24 != 0:int32                                               bool
	if t25 goto 5 else 6
5:                                                              if.then P:1 S:1
	t26 = print("panic: ":string)                                        ()
	t27 = printany(e)                                                    ()
	t28 = print("\n":string)                                             ()
	t29 = gothrow("panic during malloc":string)                          ()
	jump 6
6:                                                              if.done P:2 S:2
	t30 = &t0.m [#21]                                                   **m
	t31 = *t30                                                           *m
	t32 = &t31.gcing [#13]                                           *int32
	t33 = *t32                                                        int32
	t34 = t33 != 0:int32                                               bool
	if t34 goto 7 else 8
7:                                                              if.then P:1 S:1
	t35 = print("panic: ":string)                                        ()
	t36 = printany(e)                                                    ()
	t37 = print("\n":string)                                             ()
	t38 = gothrow("panic during gc":string)                              ()
	jump 8
8:                                                              if.done P:2 S:2
	t39 = &t0.m [#21]                                                   **m
	t40 = *t39                                                           *m
	t41 = &t40.locks [#14]                                           *int32
	t42 = *t41                                                        int32
	t43 = t42 != 0:int32                                               bool
	if t43 goto 9 else 10
9:                                                              if.then P:1 S:1
	t44 = print("panic: ":string)                                        ()
	t45 = printany(e)                                                    ()
	t46 = print("\n":string)                                             ()
	t47 = gothrow("panic holding locks":string)                          ()
	jump 10
10:                                                             if.done P:2 S:1
	t48 = new _panic (p)                                            *_panic
	t49 = &t48.arg [#1]                                        *interface{}
	*t49 = e
	t50 = &t48.link [#2]                                           **_panic
	t51 = &t0._panic [#3]                                          **_panic
	t52 = *t51                                                      *_panic
	*t50 = t52
	t53 = &t0._panic [#3]                                          **_panic
	t54 = convert unsafe.Pointer <- *_panic (t48)            unsafe.Pointer
	t55 = noescape(t54)                                      unsafe.Pointer
	t56 = convert *_panic <- unsafe.Pointer (t55)                   *_panic
	*t53 = t56
	jump 11
11:                                                            for.body P:4 S:2
	t57 = &t0._defer [#4]                                          **_defer
	t58 = *t57                                                      *_defer
	t59 = t58 == nil:*_defer                                           bool
	if t59 goto 12 else 13
12:                                                             if.then P:1 S:0
	t60 = startpanic()                                                   ()
	t61 = &t0._panic [#3]                                          **_panic
	t62 = *t61                                                      *_panic
	t63 = printpanics(t62)                                               ()
	t64 = dopanic(0:int)                                                 ()
	*nil:*int = 0:int
	return
13:                                                             if.done P:1 S:2
	t65 = &t58.started [#1]                                           *bool
	t66 = *t65                                                         bool
	if t66 goto 14 else 15
14:                                                             if.then P:1 S:2
	t67 = &t58._panic [#5]                                         **_panic
	t68 = *t67                                                      *_panic
	t69 = t68 != nil:*_panic                                           bool
	if t69 goto 16 else 17
15:                                                             if.done P:1 S:2
	t70 = &t58.started [#1]                                           *bool
	*t70 = true:bool
	t71 = &t58._panic [#5]                                         **_panic
	t72 = convert unsafe.Pointer <- *_panic (t48)            unsafe.Pointer
	t73 = noescape(t72)                                      unsafe.Pointer
	t74 = convert *_panic <- unsafe.Pointer (t73)                   *_panic
	*t71 = t74
	t75 = &t48.argp [#0]                                    *unsafe.Pointer
	t76 = getargp(0:int)                                            uintptr
	t77 = convert unsafe.Pointer <- uintptr (t76)            unsafe.Pointer
	*t75 = t77
	t78 = &t58.fn [#4]                                            **funcval
	t79 = *t78                                                     *funcval
	t80 = convert unsafe.Pointer <- *funcval (t79)           unsafe.Pointer
	t81 = deferArgs(t58)                                     unsafe.Pointer
	t82 = &t58.siz [#0]                                              *int32
	t83 = *t82                                                        int32
	t84 = convert uint32 <- int32 (t83)                              uint32
	t85 = &t58.siz [#0]                                              *int32
	t86 = *t85                                                        int32
	t87 = convert uint32 <- int32 (t86)                              uint32
	t88 = reflectcall(t80, t81, t84, t87)                                ()
	t89 = &t48.argp [#0]                                    *unsafe.Pointer
	*t89 = nil:unsafe.Pointer
	t90 = &t0._defer [#4]                                          **_defer
	t91 = *t90                                                      *_defer
	t92 = t91 != t58                                                   bool
	if t92 goto 18 else 19
16:                                                             if.then P:1 S:1
	t93 = &t58._panic [#5]                                         **_panic
	t94 = *t93                                                      *_panic
	t95 = &t94.aborted [#4]                                           *bool
	*t95 = true:bool
	jump 17
17:                                                             if.done P:2 S:1
	t96 = &t58._panic [#5]                                         **_panic
	*t96 = nil:*_panic
	t97 = &t58.fn [#4]                                            **funcval
	*t97 = nil:*funcval
	t98 = &t0._defer [#4]                                          **_defer
	t99 = &t58.link [#6]                                           **_defer
	t100 = *t99                                                     *_defer
	*t98 = t100
	t101 = freedefer(t58)                                                ()
	jump 11
18:                                                             if.then P:1 S:1
	t102 = gothrow("bad defer entry i...":string)                        ()
	jump 19
19:                                                             if.done P:2 S:2
	t103 = &t58._panic [#5]                                        **_panic
	*t103 = nil:*_panic
	t104 = &t58.fn [#4]                                           **funcval
	*t104 = nil:*funcval
	t105 = &t0._defer [#4]                                         **_defer
	t106 = &t58.link [#6]                                          **_defer
	t107 = *t106                                                    *_defer
	*t105 = t107
	t108 = &t58.pc [#3]                                            *uintptr
	t109 = *t108                                                    uintptr
	t110 = &t58.argp [#2]                                          *uintptr
	t111 = *t110                                                    uintptr
	t112 = convert unsafe.Pointer <- uintptr (t111)          unsafe.Pointer
	t113 = freedefer(t58)                                                ()
	t114 = &t48.recovered [#3]                                        *bool
	t115 = *t114                                                       bool
	if t115 goto 20 else 11
20:                                                             if.then P:1 S:1
	t116 = &t0._panic [#3]                                         **_panic
	t117 = &t48.link [#2]                                          **_panic
	t118 = *t117                                                    *_panic
	*t116 = t118
	jump 23
21:                                                            for.body P:1 S:1
	t119 = &t0._panic [#3]                                         **_panic
	t120 = &t0._panic [#3]                                         **_panic
	t121 = *t120                                                    *_panic
	t122 = &t121.link [#2]                                         **_panic
	t123 = *t122                                                    *_panic
	*t119 = t123
	jump 23
22:                                                            for.done P:2 S:2
	t124 = &t0._panic [#3]                                         **_panic
	t125 = *t124                                                    *_panic
	t126 = t125 == nil:*_panic                                         bool
	if t126 goto 25 else 26
23:                                                            for.loop P:2 S:2
	t127 = &t0._panic [#3]                                         **_panic
	t128 = *t127                                                    *_panic
	t129 = t128 != nil:*_panic                                         bool
	if t129 goto 24 else 22
24:                                                           cond.true P:1 S:2
	t130 = &t0._panic [#3]                                         **_panic
	t131 = *t130                                                    *_panic
	t132 = &t131.aborted [#4]                                         *bool
	t133 = *t132                                                       bool
	if t133 goto 21 else 22
25:                                                             if.then P:1 S:1
	t134 = &t0.sig [#23]                                             *int32
	*t134 = 0:int32
	jump 26
26:                                                             if.done P:2 S:1
	t135 = &t0.sigcode0 [#25]                                      *uintptr
	t136 = convert uintptr <- unsafe.Pointer (t112)                 uintptr
	*t135 = t136
	t137 = &t0.sigcode1 [#26]                                      *uintptr
	*t137 = t109
	t138 = mcall(recovery_m)                                             ()
	t139 = gothrow("recovery failed":string)                             ()
	jump 11

# Name: runtime.getargp
# Package: runtime
# Location: /usr/local/go/src/runtime/panic.go:432:6
func getargp(x int) uintptr:
0:                                                                entry P:0 S:2
	t0 = new int (x)                                                   *int
	*t0 = x
	t1 = *t0                                                            int
	t2 = t1 > 0:int                                                    bool
	if t2 goto 1 else 2
1:                                                              if.then P:1 S:0
	t3 = convert unsafe.Pointer <- *int (t0)                 unsafe.Pointer
	t4 = getcallersp(t3)                                            uintptr
	t5 = t4 * 0:uintptr                                             uintptr
	return t5
2:                                                              if.done P:1 S:0
	t6 = convert unsafe.Pointer <- *int (t0)                 unsafe.Pointer
	t7 = noescape(t6)                                        unsafe.Pointer
	t8 = convert uintptr <- unsafe.Pointer (t7)                     uintptr
	return t8

# Name: runtime.gorecover
# Package: runtime
# Location: /usr/local/go/src/runtime/panic.go:451:6
func gorecover(argp uintptr) interface{}:
0:                                                                entry P:0 S:2
	t0 = getg()                                                          *g
	t1 = &t0._panic [#3]                                           **_panic
	t2 = *t1                                                        *_panic
	t3 = t2 != nil:*_panic                                             bool
	if t3 goto 4 else 2
1:                                                              if.then P:1 S:0
	t4 = &t2.recovered [#3]                                           *bool
	*t4 = true:bool
	t5 = &t2.arg [#1]                                          *interface{}
	t6 = *t5                                                    interface{}
	return t6
2:                                                              if.done P:3 S:0
	return nil:interface{}
3:                                                            cond.true P:1 S:2
	t7 = &t2.argp [#0]                                      *unsafe.Pointer
	t8 = *t7                                                 unsafe.Pointer
	t9 = convert uintptr <- unsafe.Pointer (t8)                     uintptr
	t10 = argp == t9                                                   bool
	if t10 goto 1 else 2
4:                                                            cond.true P:1 S:2
	t11 = &t2.recovered [#3]                                          *bool
	t12 = *t11                                                         bool
	if t12 goto 2 else 3

# Name: runtime.startpanic
# Package: runtime
# Location: /usr/local/go/src/runtime/panic.go:468:6
func startpanic():
0:                                                                entry P:0 S:0
	t0 = onM_signalok(startpanic_m)                                      ()
	return

# Name: runtime.dopanic
# Package: runtime
# Location: /usr/local/go/src/runtime/panic.go:473:6
func dopanic(unused int):
0:                                                                entry P:0 S:0
	t0 = new int (unused)                                              *int
	*t0 = unused
	t1 = getg()                                                          *g
	t2 = acquirem()                                                      *m
	t3 = &t2.ptrarg [#46]                                *[4]unsafe.Pointer
	t4 = &t3[0:int]                                         *unsafe.Pointer
	t5 = convert unsafe.Pointer <- *g (t1)                   unsafe.Pointer
	*t4 = t5
	t6 = &t2.scalararg [#45]                                    *[4]uintptr
	t7 = &t6[0:int]                                                *uintptr
	t8 = convert unsafe.Pointer <- *int (t0)                 unsafe.Pointer
	t9 = getcallerpc(t8)                                            uintptr
	*t7 = t9
	t10 = &t2.scalararg [#45]                                   *[4]uintptr
	t11 = &t10[1:int]                                              *uintptr
	t12 = convert unsafe.Pointer <- *int (t0)                unsafe.Pointer
	t13 = getcallersp(t12)                                          uintptr
	*t11 = t13
	t14 = onM_signalok(dopanic_m)                                        ()
	*nil:*int = 0:int
	return

# Name: runtime.throw
# Package: runtime
# Location: /usr/local/go/src/runtime/panic.go:484:6
func throw(s *byte):
0:                                                                entry P:0 S:2
	t0 = getg()                                                          *g
	t1 = &t0.m [#21]                                                    **m
	t2 = *t1                                                             *m
	t3 = &t2.throwing [#12]                                          *int32
	t4 = *t3                                                          int32
	t5 = t4 == 0:int32                                                 bool
	if t5 goto 1 else 2
1:                                                              if.then P:1 S:1
	t6 = &t0.m [#21]                                                    **m
	t7 = *t6                                                             *m
	t8 = &t7.throwing [#12]                                          *int32
	*t8 = 1:int32
	jump 2
2:                                                              if.done P:2 S:0
	t9 = startpanic()                                                    ()
	t10 = gostringnocopy(s)                                          string
	t11 = print("fatal error: ":string, t10, "\n":string)                ()
	t12 = dopanic(0:int)                                                 ()
	*nil:*int = 0:int
	return

# Name: runtime.gothrow
# Package: runtime
# Location: /usr/local/go/src/runtime/panic.go:496:6
func gothrow(s string):
0:                                                                entry P:0 S:2
	t0 = getg()                                                          *g
	t1 = &t0.m [#21]                                                    **m
	t2 = *t1                                                             *m
	t3 = &t2.throwing [#12]                                          *int32
	t4 = *t3                                                          int32
	t5 = t4 == 0:int32                                                 bool
	if t5 goto 1 else 2
1:                                                              if.then P:1 S:1
	t6 = &t0.m [#21]                                                    **m
	t7 = *t6                                                             *m
	t8 = &t7.throwing [#12]                                          *int32
	*t8 = 1:int32
	jump 2
2:                                                              if.done P:2 S:0
	t9 = startpanic()                                                    ()
	t10 = print("fatal error: ":string, s, "\n":string)                  ()
	t11 = dopanic(0:int)                                                 ()
	*nil:*int = 0:int
	return

# Name: runtime.bytes
# Package: runtime
# Location: /usr/local/go/src/runtime/print1.go:13:6
func bytes(s string) (ret []byte):
0:                                                                entry P:0 S:0
	t0 = new string (s)                                             *string
	*t0 = s
	t1 = new []byte (ret)                                           *[]byte
	t2 = convert unsafe.Pointer <- *[]byte (t1)              unsafe.Pointer
	t3 = convert *slice <- unsafe.Pointer (t2)                       *slice
	t4 = convert unsafe.Pointer <- *string (t0)              unsafe.Pointer
	t5 = noescape(t4)                                        unsafe.Pointer
	t6 = convert *_string <- unsafe.Pointer (t5)                   *_string
	t7 = &t3.array [#0]                                              **byte
	t8 = &t6.str [#0]                                                **byte
	t9 = *t8                                                          *byte
	*t7 = t9
	t10 = &t3.len [#1]                                                *uint
	t11 = &t6.len [#1]                                                 *int
	t12 = *t11                                                          int
	t13 = convert uint <- int (t12)                                    uint
	*t10 = t13
	t14 = &t3.cap [#2]                                                *uint
	t15 = &t6.len [#1]                                                 *int
	t16 = *t15                                                          int
	t17 = convert uint <- int (t16)                                    uint
	*t14 = t17
	t18 = *t1                                                        []byte
	return t18

# Name: runtime.printf
# Package: runtime
# Location: /usr/local/go/src/runtime/print1.go:26:6
func printf(s *byte):
0:                                                                entry P:0 S:0
	t0 = new *byte (s)                                               **byte
	*t0 = s
	t1 = *t0                                                          *byte
	t2 = gostringnocopy(t1)                                          string
	t3 = convert unsafe.Pointer <- **byte (t0)               unsafe.Pointer
	t4 = add(t3, 8:uintptr)                                  unsafe.Pointer
	t5 = vprintf(t2, t4)                                                 ()
	return

# Name: runtime.snprintf
# Package: runtime
# Location: /usr/local/go/src/runtime/print1.go:34:6
func snprintf(dst *byte, n int32, s *byte):
0:                                                                entry P:0 S:0
	t0 = new *byte (s)                                               **byte
	*t0 = s
	t1 = convert unsafe.Pointer <- *byte (dst)               unsafe.Pointer
	t2 = convert *[1073741824]byte <- unsafe.Pointer (t1) *[1073741824]byte
	t3 = slice t2[0:int:n:n]                                         []byte
	t4 = getg()                                                          *g
	t5 = &t4.writebuf [#24]                                         *[]byte
	t6 = n - 1:int32                                                  int32
	t7 = slice t3[0:int:0:int:t6]                                    []byte
	*t5 = t7
	t8 = *t0                                                          *byte
	t9 = gostringnocopy(t8)                                          string
	t10 = convert unsafe.Pointer <- **byte (t0)              unsafe.Pointer
	t11 = add(t10, 8:uintptr)                                unsafe.Pointer
	t12 = vprintf(t9, t11)                                               ()
	t13 = &t4.writebuf [#24]                                        *[]byte
	t14 = *t13                                                       []byte
	t15 = len(t14)                                                      int
	t16 = &t3[t15]                                                    *byte
	*t16 = 0:byte
	t17 = &t4.writebuf [#24]                                        *[]byte
	*t17 = nil:[]byte
	return

# Name: runtime.gwrite
# Package: runtime
# Location: /usr/local/go/src/runtime/print1.go:48:6
func gwrite(b []byte):
0:                                                                entry P:0 S:2
	t0 = len(b)                                                         int
	t1 = t0 == 0:int                                                   bool
	if t1 goto 1 else 2
1:                                                              if.then P:1 S:0
	return
2:                                                              if.done P:1 S:2
	t2 = getg()                                                          *g
	t3 = t2 == nil:*g                                                  bool
	if t3 goto 3 else 5
3:                                                              if.then P:2 S:0
	t4 = &b[0:int]                                                    *byte
	t5 = convert unsafe.Pointer <- *byte (t4)                unsafe.Pointer
	t6 = len(b)                                                         int
	t7 = convert int32 <- int (t6)                                    int32
	t8 = write(2:uintptr, t5, t7)                                     int32
	return
4:                                                              if.done P:1 S:0
	t9 = &t2.writebuf [#24]                                         *[]byte
	t10 = *t9                                                        []byte
	t11 = &t2.writebuf [#24]                                        *[]byte
	t12 = *t11                                                       []byte
	t13 = cap(t12)                                                      int
	t14 = &t2.writebuf [#24]                                        *[]byte
	t15 = *t14                                                       []byte
	t16 = len(t15)                                                      int
	t17 = slice t10[t16:t13]                                         []byte
	t18 = copy(t17, b)                                                  int
	t19 = &t2.writebuf [#24]                                        *[]byte
	t20 = &t2.writebuf [#24]                                        *[]byte
	t21 = *t20                                                       []byte
	t22 = &t2.writebuf [#24]                                        *[]byte
	t23 = *t22                                                       []byte
	t24 = len(t23)                                                      int
	t25 = t24 + t18                                                     int
	t26 = slice t21[:t25]                                            []byte
	*t19 = t26
	return
5:                                                           cond.false P:1 S:2
	t27 = &t2.writebuf [#24]                                        *[]byte
	t28 = *t27                                                       []byte
	t29 = t28 == nil:[]byte                                            bool
	if t29 goto 3 else 4

# Name: runtime.prints
# Package: runtime
# Location: /usr/local/go/src/runtime/print1.go:62:6
func prints(s *byte):
0:                                                                entry P:0 S:1
	t0 = convert unsafe.Pointer <- *byte (s)                 unsafe.Pointer
	t1 = convert *[1073741824]byte <- unsafe.Pointer (t0) *[1073741824]byte
	jump 1
1:                                                             for.body P:2 S:2
	t2 = phi [0: 0:int, 3: t8] #i                                       int
	t3 = &t1[t2]                                                      *byte
	t4 = *t3                                                           byte
	t5 = t4 == 0:byte                                                  bool
	if t5 goto 2 else 3
2:                                                              if.then P:1 S:0
	t6 = slice t1[:t2]                                               []byte
	t7 = gwrite(t6)                                                      ()
	return
3:                                                              if.done P:1 S:1
	t8 = t2 + 1:int                                                     int
	jump 1

# Name: runtime.printsp
# Package: runtime
# Location: /usr/local/go/src/runtime/print1.go:72:6
func printsp():
0:                                                                entry P:0 S:0
	t0 = print(" ":string)                                               ()
	return

# Name: runtime.printnl
# Package: runtime
# Location: /usr/local/go/src/runtime/print1.go:76:6
func printnl():
0:                                                                entry P:0 S:0
	t0 = print("\n":string)                                              ()
	return

# Name: runtime.vprintf
# Package: runtime
# Location: /usr/local/go/src/runtime/print1.go:82:6
func vprintf(str string, arg unsafe.Pointer):
0:                                                                entry P:0 S:1
	t0 = bytes(str)                                                  []byte
	jump 3
1:                                                             for.body P:1 S:2
	t1 = &t0[t8]                                                      *byte
	t2 = *t1                                                           byte
	t3 = t2 != 37:byte                                                 bool
	if t3 goto 4 else 5
2:                                                             for.done P:2 S:2
	t4 = phi [3: t8, 7: t20] #i                                         int
	t5 = t7 < t4                                                       bool
	if t5 goto 62 else 63
3:                                                             for.loop P:2 S:2
	t6 = phi [0: arg, 4: t12] #arg                           unsafe.Pointer
	t7 = phi [0: 0:int, 4: t13] #start                                  int
	t8 = phi [0: 0:int, 4: t16] #i                                      int
	t9 = phi [0: 0:uintptr, 4: t15] #siz                            uintptr
	t10 = len(t0)                                                       int
	t11 = t8 < t10                                                     bool
	if t11 goto 1 else 2
4:                                                             for.post P:2 S:1
	t12 = phi [1: t6, 32: t52] #arg                          unsafe.Pointer
	t13 = phi [1: t7, 32: t53] #start                                   int
	t14 = phi [1: t8, 32: t20] #i                                       int
	t15 = phi [1: t9, 32: t27] #siz                                 uintptr
	t16 = t14 + 1:int                                                   int
	jump 3
5:                                                              if.done P:1 S:2
	t17 = t8 > t7                                                      bool
	if t17 goto 6 else 7
6:                                                              if.then P:1 S:1
	t18 = slice t0[t7:t8]                                            []byte
	t19 = gwrite(t18)                                                    ()
	jump 7
7:                                                              if.done P:2 S:2
	t20 = t8 + 1:int                                                    int
	t21 = len(t0)                                                       int
	t22 = t20 >= t21                                                   bool
	if t22 goto 2 else 8
8:                                                              if.done P:1 S:2
	t23 = &t0[t20]                                                    *byte
	t24 = *t23                                                         byte
	t25 = t24 == 116:byte                                              bool
	if t25 goto 10 else 12
9:                                                          switch.done P:9 S:2
	t26 = phi [10: t6, 11: t31, 14: t34, 17: t37, 22: t42, 24: t44, 27: t47, 29: t49, 31: t6] #arg unsafe.Pointer
	t27 = phi [10: 1:uintptr, 11: 4:uintptr, 14: 8:uintptr, 17: 16:uintptr, 22: 8:uintptr, 24: 16:uintptr, 27: 24:uintptr, 29: 16:uintptr, 31: 0:uintptr] #siz uintptr
	t28 = &t0[t20]                                                    *byte
	t29 = *t28                                                         byte
	t30 = t29 == 97:byte                                               bool
	if t30 goto 33 else 35
10:                                                         switch.body P:2 S:1
	jump 9
11:                                                         switch.body P:2 S:1
	t31 = roundup(t6, 4:uintptr)                             unsafe.Pointer
	jump 9
12:                                                         switch.next P:1 S:2
	t32 = t24 == 99:byte                                               bool
	if t32 goto 10 else 13
13:                                                         switch.next P:1 S:2
	t33 = t24 == 100:byte                                              bool
	if t33 goto 11 else 15
14:                                                         switch.body P:4 S:1
	t34 = roundup(t6, 8:uintptr)                             unsafe.Pointer
	jump 9
15:                                                         switch.next P:1 S:2
	t35 = t24 == 120:byte                                              bool
	if t35 goto 11 else 16
16:                                                         switch.next P:1 S:2
	t36 = t24 == 68:byte                                               bool
	if t36 goto 14 else 18
17:                                                         switch.body P:1 S:1
	t37 = roundup(t6, 8:uintptr)                             unsafe.Pointer
	jump 9
18:                                                         switch.next P:1 S:2
	t38 = t24 == 85:byte                                               bool
	if t38 goto 14 else 19
19:                                                         switch.next P:1 S:2
	t39 = t24 == 88:byte                                               bool
	if t39 goto 14 else 20
20:                                                         switch.next P:1 S:2
	t40 = t24 == 102:byte                                              bool
	if t40 goto 14 else 21
21:                                                         switch.next P:1 S:2
	t41 = t24 == 67:byte                                               bool
	if t41 goto 17 else 23
22:                                                         switch.body P:2 S:1
	t42 = roundup(t6, 8:uintptr)                             unsafe.Pointer
	jump 9
23:                                                         switch.next P:1 S:2
	t43 = t24 == 112:byte                                              bool
	if t43 goto 22 else 25
24:                                                         switch.body P:1 S:1
	t44 = roundup(t6, 8:uintptr)                             unsafe.Pointer
	jump 9
25:                                                         switch.next P:1 S:2
	t45 = t24 == 115:byte                                              bool
	if t45 goto 22 else 26
26:                                                         switch.next P:1 S:2
	t46 = t24 == 83:byte                                               bool
	if t46 goto 24 else 28
27:                                                         switch.body P:1 S:1
	t47 = roundup(t6, 8:uintptr)                             unsafe.Pointer
	jump 9
28:                                                         switch.next P:1 S:2
	t48 = t24 == 97:byte                                               bool
	if t48 goto 27 else 30
29:                                                         switch.body P:2 S:1
	t49 = roundup(t6, 8:uintptr)                             unsafe.Pointer
	jump 9
30:                                                         switch.next P:1 S:2
	t50 = t24 == 105:byte                                              bool
	if t50 goto 29 else 31
31:                                                         switch.next P:1 S:2
	t51 = t24 == 101:byte                                              bool
	if t51 goto 29 else 9
32:                                                        switch.done P:16 S:1
	t52 = add(t26, t27)                                      unsafe.Pointer
	t53 = t20 + 1:int                                                   int
	jump 4
33:                                                         switch.body P:1 S:1
	t54 = convert *[]byte <- unsafe.Pointer (t26)                   *[]byte
	t55 = *t54                                                       []byte
	t56 = printslice(t55)                                                ()
	jump 32
34:                                                         switch.body P:1 S:1
	t57 = convert *byte <- unsafe.Pointer (t26)                       *byte
	t58 = *t57                                                         byte
	t59 = printbyte(t58)                                                 ()
	jump 32
35:                                                         switch.next P:1 S:2
	t60 = t29 == 99:byte                                               bool
	if t60 goto 34 else 37
36:                                                         switch.body P:1 S:1
	t61 = convert *int32 <- unsafe.Pointer (t26)                     *int32
	t62 = *t61                                                        int32
	t63 = convert int64 <- int32 (t62)                                int64
	t64 = printint(t63)                                                  ()
	jump 32
37:                                                         switch.next P:1 S:2
	t65 = t29 == 100:byte                                              bool
	if t65 goto 36 else 39
38:                                                         switch.body P:1 S:1
	t66 = convert *int64 <- unsafe.Pointer (t26)                     *int64
	t67 = *t66                                                        int64
	t68 = printint(t67)                                                  ()
	jump 32
39:                                                         switch.next P:1 S:2
	t69 = t29 == 68:byte                                               bool
	if t69 goto 38 else 41
40:                                                         switch.body P:1 S:1
	t70 = convert *interface{} <- unsafe.Pointer (t26)         *interface{}
	t71 = *t70                                                  interface{}
	t72 = printeface(t71)                                                ()
	jump 32
41:                                                         switch.next P:1 S:2
	t73 = t29 == 101:byte                                              bool
	if t73 goto 40 else 43
42:                                                         switch.body P:1 S:1
	t74 = convert *float64 <- unsafe.Pointer (t26)                 *float64
	t75 = *t74                                                      float64
	t76 = printfloat(t75)                                                ()
	jump 32
43:                                                         switch.next P:1 S:2
	t77 = t29 == 102:byte                                              bool
	if t77 goto 42 else 45
44:                                                         switch.body P:1 S:1
	t78 = convert *complex128 <- unsafe.Pointer (t26)           *complex128
	t79 = *t78                                                   complex128
	t80 = printcomplex(t79)                                              ()
	jump 32
45:                                                         switch.next P:1 S:2
	t81 = t29 == 67:byte                                               bool
	if t81 goto 44 else 47
46:                                                         switch.body P:1 S:1
	t82 = convert *fInterface <- unsafe.Pointer (t26)           *fInterface
	t83 = *t82                                                   fInterface
	t84 = printiface(t83)                                                ()
	jump 32
47:                                                         switch.next P:1 S:2
	t85 = t29 == 105:byte                                              bool
	if t85 goto 46 else 49
48:                                                         switch.body P:1 S:1
	t86 = convert *unsafe.Pointer <- unsafe.Pointer (t26)   *unsafe.Pointer
	t87 = *t86                                               unsafe.Pointer
	t88 = printpointer(t87)                                              ()
	jump 32
49:                                                         switch.next P:1 S:2
	t89 = t29 == 112:byte                                              bool
	if t89 goto 48 else 51
50:                                                         switch.body P:1 S:1
	t90 = convert **byte <- unsafe.Pointer (t26)                     **byte
	t91 = *t90                                                        *byte
	t92 = prints(t91)                                                    ()
	jump 32
51:                                                         switch.next P:1 S:2
	t93 = t29 == 115:byte                                              bool
	if t93 goto 50 else 53
52:                                                         switch.body P:1 S:1
	t94 = convert *string <- unsafe.Pointer (t26)                   *string
	t95 = *t94                                                       string
	t96 = printstring(t95)                                               ()
	jump 32
53:                                                         switch.next P:1 S:2
	t97 = t29 == 83:byte                                               bool
	if t97 goto 52 else 55
54:                                                         switch.body P:1 S:1
	t98 = convert *bool <- unsafe.Pointer (t26)                       *bool
	t99 = *t98                                                         bool
	t100 = printbool(t99)                                                ()
	jump 32
55:                                                         switch.next P:1 S:2
	t101 = t29 == 116:byte                                             bool
	if t101 goto 54 else 57
56:                                                         switch.body P:1 S:1
	t102 = convert *uint64 <- unsafe.Pointer (t26)                  *uint64
	t103 = *t102                                                     uint64
	t104 = printuint(t103)                                               ()
	jump 32
57:                                                         switch.next P:1 S:2
	t105 = t29 == 85:byte                                              bool
	if t105 goto 56 else 59
58:                                                         switch.body P:1 S:1
	t106 = convert *uint32 <- unsafe.Pointer (t26)                  *uint32
	t107 = *t106                                                     uint32
	t108 = convert uint64 <- uint32 (t107)                           uint64
	t109 = printhex(t108)                                                ()
	jump 32
59:                                                         switch.next P:1 S:2
	t110 = t29 == 120:byte                                             bool
	if t110 goto 58 else 61
60:                                                         switch.body P:1 S:1
	t111 = convert *uint64 <- unsafe.Pointer (t26)                  *uint64
	t112 = *t111                                                     uint64
	t113 = printhex(t112)                                                ()
	jump 32
61:                                                         switch.next P:1 S:2
	t114 = t29 == 88:byte                                              bool
	if t114 goto 60 else 32
62:                                                             if.then P:1 S:1
	t115 = slice t0[t7:t4]                                           []byte
	t116 = gwrite(t115)                                                  ()
	jump 63
63:                                                             if.done P:2 S:0
	return

# Name: runtime.printpc
# Package: runtime
# Location: /usr/local/go/src/runtime/print1.go:166:6
func printpc(p unsafe.Pointer):
0:                                                                entry P:0 S:0
	t0 = convert uintptr <- unsafe.Pointer (p)                      uintptr
	t1 = convert hex <- uintptr (t0)                                    hex
	t2 = print("PC=":string, t1)                                         ()
	return

# Name: runtime.printbool
# Package: runtime
# Location: /usr/local/go/src/runtime/print1.go:170:6
func printbool(v bool):
0:                                                                entry P:0 S:2
	if v goto 1 else 3
1:                                                              if.then P:1 S:1
	t0 = print("true":string)                                            ()
	jump 2
2:                                                              if.done P:2 S:0
	return
3:                                                              if.else P:1 S:1
	t1 = print("false":string)                                           ()
	jump 2

# Name: runtime.printbyte
# Package: runtime
# Location: /usr/local/go/src/runtime/print1.go:178:6
func printbyte(c byte):
0:                                                                entry P:0 S:0
	t0 = new byte (c)                                                 *byte
	*t0 = c
	t1 = convert unsafe.Pointer <- *byte (t0)                unsafe.Pointer
	t2 = convert *[1]byte <- unsafe.Pointer (t1)                   *[1]byte
	t3 = slice t2[:]                                                 []byte
	t4 = gwrite(t3)                                                      ()
	return

# Name: runtime.printfloat
# Package: runtime
# Location: /usr/local/go/src/runtime/print1.go:182:6
func printfloat(v float64):
0:                                                                entry P:0 S:2
	t0 = v != v                                                        bool
	if t0 goto 1 else 3
1:                                                          switch.body P:1 S:0
	t1 = print("NaN":string)                                             ()
	return
2:                                                          switch.body P:1 S:0
	t2 = print("+Inf":string)                                            ()
	return
3:                                                          switch.next P:1 S:2
	t3 = v + v                                                      float64
	t4 = t3 == v                                                       bool
	if t4 goto 6 else 7
4:                                                          switch.body P:1 S:0
	t5 = print("-Inf":string)                                            ()
	return
5:                                                          switch.next P:1 S:2
	t6 = v + v                                                      float64
	t7 = t6 == v                                                       bool
	if t7 goto 9 else 10
6:                                                            binop.rhs P:1 S:1
	t8 = v > 0:float64                                                 bool
	jump 7
7:                                                           binop.done P:2 S:2
	t9 = phi [3: false:bool, 6: t8] #&&                                bool
	if t9 goto 2 else 5
8:                                                          switch.next P:1 S:2
	t10 = new [14]byte (buf)                                      *[14]byte
	t11 = &t10[0:int]                                                 *byte
	*t11 = 43:byte
	t12 = v == 0:float64                                               bool
	if t12 goto 11 else 13
9:                                                            binop.rhs P:1 S:1
	t13 = v < 0:float64                                                bool
	jump 10
10:                                                          binop.done P:2 S:2
	t14 = phi [5: false:bool, 9: t13] #&&                              bool
	if t14 goto 4 else 8
11:                                                             if.then P:1 S:2
	t15 = 1:float64 / v                                             float64
	t16 = t15 < 0:float64                                              bool
	if t16 goto 14 else 12
12:                                                             if.done P:4 S:1
	t17 = phi [11: v, 22: t35, 14: v, 24: t41] #v                   float64
	t18 = phi [11: 0:int, 22: t31, 14: 0:int, 24: t40] #e               int
	jump 27
13:                                                             if.else P:1 S:2
	t19 = v < 0:float64                                                bool
	if t19 goto 15 else 17
14:                                                             if.then P:1 S:1
	t20 = &t10[0:int]                                                 *byte
	*t20 = 45:byte
	jump 12
15:                                                             if.then P:1 S:1
	t21 = -v                                                        float64
	t22 = &t10[0:int]                                                 *byte
	*t22 = 45:byte
	jump 17
16:                                                            for.body P:1 S:1
	t23 = t26 + 1:int                                                   int
	t24 = t25 / 10:float64                                          float64
	jump 17
17:                                                            for.loop P:3 S:2
	t25 = phi [13: v, 16: t24, 15: t21] #v                          float64
	t26 = phi [13: 0:int, 16: t23, 15: 0:int] #e                        int
	t27 = t25 >= 10:float64                                            bool
	if t27 goto 16 else 20
18:                                                            for.body P:1 S:1
	t28 = t31 - 1:int                                                   int
	t29 = t30 * 10:float64                                          float64
	jump 20
19:                                                            for.done P:1 S:1
	jump 23
20:                                                            for.loop P:2 S:2
	t30 = phi [17: t25, 18: t29] #v                                 float64
	t31 = phi [17: t26, 18: t28] #e                                     int
	t32 = t30 < 1:float64                                              bool
	if t32 goto 18 else 19
21:                                                            for.body P:1 S:1
	t33 = t37 / 10:float64                                          float64
	t34 = t38 + 1:int                                                   int
	jump 23
22:                                                            for.done P:1 S:2
	t35 = t30 + t37                                                 float64
	t36 = t35 >= 10:float64                                            bool
	if t36 goto 24 else 12
23:                                                            for.loop P:2 S:2
	t37 = phi [19: 5:float64, 21: t33] #h                           float64
	t38 = phi [19: 0:int, 21: t34] #i                                   int
	t39 = t38 < 7:int                                                  bool
	if t39 goto 21 else 22
24:                                                             if.then P:1 S:1
	t40 = t31 + 1:int                                                   int
	t41 = t35 / 10:float64                                          float64
	jump 12
25:                                                            for.body P:1 S:1
	t42 = convert int <- float64 (t58)                                  int
	t43 = t59 + 2:int                                                   int
	t44 = &t10[t43]                                                   *byte
	t45 = t42 + 48:int                                                  int
	t46 = convert byte <- int (t45)                                    byte
	*t44 = t46
	t47 = convert float64 <- int (t42)                              float64
	t48 = t58 - t47                                                 float64
	t49 = t48 * 10:float64                                          float64
	t50 = t59 + 1:int                                                   int
	jump 27
26:                                                            for.done P:1 S:2
	t51 = &t10[1:int]                                                 *byte
	t52 = &t10[2:int]                                                 *byte
	t53 = *t52                                                         byte
	*t51 = t53
	t54 = &t10[2:int]                                                 *byte
	*t54 = 46:byte
	t55 = &t10[9:int]                                                 *byte
	*t55 = 101:byte
	t56 = &t10[10:int]                                                *byte
	*t56 = 43:byte
	t57 = t18 < 0:int                                                  bool
	if t57 goto 28 else 29
27:                                                            for.loop P:2 S:2
	t58 = phi [12: t17, 25: t49] #v                                 float64
	t59 = phi [12: 0:int, 25: t50] #i                                   int
	t60 = t59 < 7:int                                                  bool
	if t60 goto 25 else 26
28:                                                             if.then P:1 S:1
	t61 = -t18                                                          int
	t62 = &t10[10:int]                                                *byte
	*t62 = 45:byte
	jump 29
29:                                                             if.done P:2 S:0
	t63 = phi [26: t18, 28: t61] #e                                     int
	t64 = &t10[11:int]                                                *byte
	t65 = t63 / 100:int                                                 int
	t66 = convert byte <- int (t65)                                    byte
	t67 = t66 + 48:byte                                                byte
	*t64 = t67
	t68 = &t10[12:int]                                                *byte
	t69 = t63 / 10:int                                                  int
	t70 = convert byte <- int (t69)                                    byte
	t71 = t70 % 10:byte                                                byte
	t72 = t71 + 48:byte                                                byte
	*t68 = t72
	t73 = &t10[13:int]                                                *byte
	t74 = t63 % 10:int                                                  int
	t75 = convert byte <- int (t74)                                    byte
	t76 = t75 + 48:byte                                                byte
	*t73 = t76
	t77 = slice t10[:]                                               []byte
	t78 = gwrite(t77)                                                    ()
	return

# Name: runtime.printcomplex
# Package: runtime
# Location: /usr/local/go/src/runtime/print1.go:254:6
func printcomplex(c complex128):
0:                                                                entry P:0 S:0
	t0 = real(c)                                                    float64
	t1 = imag(c)                                                    float64
	t2 = print("(":string, t0, t1, "i)":string)                          ()
	return

# Name: runtime.printuint
# Package: runtime
# Location: /usr/local/go/src/runtime/print1.go:258:6
func printuint(v uint64):
0:                                                                entry P:0 S:1
	t0 = new [100]byte (buf)                                     *[100]byte
	t1 = 100:int - 1:int                                                int
	jump 3
1:                                                             for.body P:1 S:2
	t2 = &t0[t10]                                                     *byte
	t3 = t9 % 10:uint64                                              uint64
	t4 = t3 + 48:uint64                                              uint64
	t5 = convert byte <- uint64 (t4)                                   byte
	*t2 = t5
	t6 = t9 < 10:uint64                                                bool
	if t6 goto 2 else 4
2:                                                             for.done P:2 S:0
	t7 = slice t0[t10:]                                              []byte
	t8 = gwrite(t7)                                                      ()
	return
3:                                                             for.loop P:2 S:2
	t9 = phi [0: v, 4: t12] #v                                       uint64
	t10 = phi [0: t1, 4: t13] #i                                        int
	t11 = t10 > 0:int                                                  bool
	if t11 goto 1 else 2
4:                                                              if.done P:1 S:1
	t12 = t9 / 10:uint64                                             uint64
	t13 = t10 - 1:int                                                   int
	jump 3

# Name: runtime.printint
# Package: runtime
# Location: /usr/local/go/src/runtime/print1.go:271:6
func printint(v int64):
0:                                                                entry P:0 S:2
	t0 = v < 0:int64                                                   bool
	if t0 goto 1 else 2
1:                                                              if.then P:1 S:1
	t1 = print("-":string)                                               ()
	t2 = -v                                                           int64
	jump 2
2:                                                              if.done P:2 S:0
	t3 = phi [0: v, 1: t2] #v                                         int64
	t4 = convert uint64 <- int64 (t3)                                uint64
	t5 = printuint(t4)                                                   ()
	return

# Name: runtime.printhex
# Package: runtime
# Location: /usr/local/go/src/runtime/print1.go:279:6
func printhex(v uint64):
0:                                                                entry P:0 S:1
	t0 = new [100]byte (buf)                                     *[100]byte
	t1 = 100:int - 1:int                                                int
	jump 3
1:                                                             for.body P:1 S:2
	t2 = &t0[t13]                                                     *byte
	t3 = t12 % 16:uint64                                             uint64
	t4 = "0123456789abcdef":untyped string[t3]                        uint8
	*t2 = t4
	t5 = t12 < 16:uint64                                               bool
	if t5 goto 2 else 4
2:                                                             for.done P:2 S:0
	t6 = t13 - 1:int                                                    int
	t7 = &t0[t6]                                                      *byte
	*t7 = 120:byte
	t8 = t6 - 1:int                                                     int
	t9 = &t0[t8]                                                      *byte
	*t9 = 48:byte
	t10 = slice t0[t8:]                                              []byte
	t11 = gwrite(t10)                                                    ()
	return
3:                                                             for.loop P:2 S:2
	t12 = phi [0: v, 4: t15] #v                                      uint64
	t13 = phi [0: t1, 4: t16] #i                                        int
	t14 = t13 > 0:int                                                  bool
	if t14 goto 1 else 2
4:                                                              if.done P:1 S:1
	t15 = t12 / 16:uint64                                            uint64
	t16 = t13 - 1:int                                                   int
	jump 3

# Name: runtime.printpointer
# Package: runtime
# Location: /usr/local/go/src/runtime/print1.go:297:6
func printpointer(p unsafe.Pointer):
0:                                                                entry P:0 S:0
	t0 = convert uintptr <- unsafe.Pointer (p)                      uintptr
	t1 = convert uint64 <- uintptr (t0)                              uint64
	t2 = printhex(t1)                                                    ()
	return

# Name: runtime.printstring
# Package: runtime
# Location: /usr/local/go/src/runtime/print1.go:301:6
func printstring(s string):
0:                                                                entry P:0 S:2
	t0 = len(s)                                                         int
	t1 = convert uintptr <- int (t0)                                uintptr
	t2 = *maxstring                                                 uintptr
	t3 = t1 > t2                                                       bool
	if t3 goto 1 else 2
1:                                                              if.then P:1 S:0
	t4 = bytes("[string too long]":string)                           []byte
	t5 = gwrite(t4)                                                      ()
	return
2:                                                              if.done P:1 S:0
	t6 = bytes(s)                                                    []byte
	t7 = gwrite(t6)                                                      ()
	return

# Name: runtime.printslice
# Package: runtime
# Location: /usr/local/go/src/runtime/print1.go:309:6
func printslice(s []byte):
0:                                                                entry P:0 S:0
	t0 = new []byte (s)                                             *[]byte
	*t0 = s
	t1 = convert unsafe.Pointer <- *[]byte (t0)              unsafe.Pointer
	t2 = convert *slice <- unsafe.Pointer (t1)                       *slice
	t3 = *t0                                                         []byte
	t4 = len(t3)                                                        int
	t5 = *t0                                                         []byte
	t6 = cap(t5)                                                        int
	t7 = print("[":string, t4, "/":string, t6, "]":string)               ()
	t8 = &t2.array [#0]                                              **byte
	t9 = *t8                                                          *byte
	t10 = convert unsafe.Pointer <- *byte (t9)               unsafe.Pointer
	t11 = printpointer(t10)                                              ()
	return

# Name: runtime.printeface
# Package: runtime
# Location: /usr/local/go/src/runtime/print1.go:315:6
func printeface(e interface{}):
0:                                                                entry P:0 S:0
	t0 = new interface{} (e)                                   *interface{}
	*t0 = e
	t1 = convert unsafe.Pointer <- *interface{} (t0)         unsafe.Pointer
	t2 = convert *eface <- unsafe.Pointer (t1)                       *eface
	t3 = &t2._type [#0]                                             **_type
	t4 = *t3                                                         *_type
	t5 = &t2.data [#1]                                      *unsafe.Pointer
	t6 = *t5                                                 unsafe.Pointer
	t7 = print("(":string, t4, ",":string, t6, ")":string)               ()
	return

# Name: runtime.printiface
# Package: runtime
# Location: /usr/local/go/src/runtime/print1.go:320:6
func printiface(i fInterface):
0:                                                                entry P:0 S:0
	t0 = new fInterface (i)                                     *fInterface
	*t0 = i
	t1 = convert unsafe.Pointer <- *fInterface (t0)          unsafe.Pointer
	t2 = convert *iface <- unsafe.Pointer (t1)                       *iface
	t3 = &t2.tab [#0]                                                **itab
	t4 = *t3                                                          *itab
	t5 = &t2.data [#1]                                      *unsafe.Pointer
	t6 = *t5                                                 unsafe.Pointer
	t7 = print("(":string, t4, ",":string, t6, ")":string)               ()
	return

# Name: runtime.main$1
# Package: runtime
# Location: /usr/local/go/src/runtime/proc.go:50:8
# Parent: main
# Free variables:
#   0:	needUnlock *bool
func main$1():
0:                                                                entry P:0 S:2
	t0 = *needUnlock                                                   bool
	if t0 goto 1 else 2
1:                                                              if.then P:1 S:1
	t1 = unlockOSThread()                                                ()
	jump 2
2:                                                              if.done P:2 S:0
	return

# Name: runtime.main
# Package: runtime
# Location: /usr/local/go/src/runtime/proc.go:16:6
# Recover: 6
func main():
0:                                                                entry P:0 S:2
	t0 = getg()                                                          *g
	t1 = &t0.m [#21]                                                    **m
	t2 = *t1                                                             *m
	t3 = &t2.g0 [#0]                                                    **g
	t4 = *t3                                                             *g
	t5 = &t4.racectx [#29]                                         *uintptr
	*t5 = 0:uintptr
	if true:untyped bool goto 1 else 3
1:                                                              if.then P:1 S:1
	*maxstacksize = 1000000000:uintptr
	jump 2
2:                                                              if.done P:2 S:2
	t6 = onM(newsysmon)                                                  ()
	t7 = lockOSThread()                                                  ()
	t8 = &t0.m [#21]                                                    **m
	t9 = *t8                                                             *m
	t10 = t9 != m0                                                     bool
	if t10 goto 4 else 5
3:                                                              if.else P:1 S:1
	*maxstacksize = 250000000:uintptr
	jump 2
4:                                                              if.then P:1 S:1
	t11 = gothrow("runtime.main not ...":string)                         ()
	jump 5
5:                                                              if.done P:2 S:2
	t12 = runtime_init()                                                 ()
	t13 = new bool (needUnlock)                                       *bool
	*t13 = true:bool
	t14 = make closure main$1 [t13]                                  func()
	defer t14()
	t15 = &memstats.enablegc [#27]                                    *bool
	*t15 = true:bool
	t16 = main_init()                                                    ()
	*t13 = false:bool
	t17 = unlockOSThread()                                               ()
	t18 = main_main()                                                    ()
	if false:untyped bool goto 7 else 8
6:                                                              recover P:0 S:0
	return
7:                                                              if.then P:1 S:1
	t19 = racefini()                                                     ()
	jump 8
8:                                                              if.done P:2 S:2
	t20 = *panicking                                                 uint32
	t21 = t20 != 0:uint32                                              bool
	if t21 goto 9 else 10
9:                                                              if.then P:1 S:1
	t22 = gopark(nil:unsafe.Pointer, nil:unsafe.Pointer, "panicwait":string) ()
	jump 10
10:                                                             if.done P:2 S:1
	t23 = exit(0:int32)                                                  ()
	jump 11
11:                                                            for.body P:2 S:1
	*nil:*int32 = 0:int32
	jump 11

# Name: runtime.init#4
# Package: runtime
# Location: /usr/local/go/src/runtime/proc.go:86:6
func init#4():
0:                                                                entry P:0 S:0
	go forcegchelper()
	return

# Name: runtime.forcegchelper
# Package: runtime
# Location: /usr/local/go/src/runtime/proc.go:90:6
func forcegchelper():
0:                                                                entry P:0 S:1
	t0 = &forcegc.g [#1]                                                **g
	t1 = getg()                                                          *g
	*t0 = t1
	t2 = &forcegc.g [#1]                                                **g
	t3 = *t2                                                             *g
	t4 = &t3.issystem [#14]                                           *bool
	*t4 = true:bool
	jump 1
1:                                                             for.body P:2 S:2
	t5 = &forcegc.lock [#0]                                          *mutex
	t6 = lock(t5)                                                        ()
	t7 = &forcegc.idle [#2]                                         *uint32
	t8 = *t7                                                         uint32
	t9 = t8 != 0:uint32                                                bool
	if t9 goto 2 else 3
2:                                                              if.then P:1 S:1
	t10 = gothrow("forcegc: phase error":string)                         ()
	jump 3
3:                                                              if.done P:2 S:2
	t11 = &forcegc.idle [#2]                                        *uint32
	t12 = atomicstore(t11, 1:uint32)                                     ()
	t13 = &forcegc.lock [#0]                                         *mutex
	t14 = goparkunlock(t13, "force gc (idle)":string)                    ()
	t15 = &debug.gctrace [#2]                                        *int32
	t16 = *t15                                                        int32
	t17 = t16 > 0:int32                                                bool
	if t17 goto 4 else 5
4:                                                              if.then P:1 S:1
	t18 = println("GC forced":string)                                    ()
	jump 5
5:                                                              if.done P:2 S:1
	t19 = gogc(1:int32)                                                  ()
	jump 1

# Name: runtime.Gosched
# Package: runtime
# Location: /usr/local/go/src/runtime/proc.go:112:6
func Gosched():
0:                                                                entry P:0 S:0
	t0 = mcall(gosched_m)                                                ()
	return

# Name: runtime.gopark
# Package: runtime
# Location: /usr/local/go/src/runtime/proc.go:118:6
func gopark(unlockf unsafe.Pointer, lock unsafe.Pointer, reason string):
0:                                                                entry P:0 S:2
	t0 = acquirem()                                                      *m
	t1 = &t0.curg [#6]                                                  **g
	t2 = *t1                                                             *g
	t3 = readgstatus(t2)                                             uint32
	t4 = t3 != 2:uint32                                                bool
	if t4 goto 3 else 2
1:                                                              if.then P:1 S:1
	t5 = gothrow("gopark: bad g status":string)                          ()
	jump 2
2:                                                              if.done P:3 S:0
	t6 = &t0.waitlock [#44]                                 *unsafe.Pointer
	*t6 = lock
	t7 = &t0.waitunlockf [#43]                              *unsafe.Pointer
	*t7 = unlockf
	t8 = &t2.waitreason [#12]                                       *string
	*t8 = reason
	t9 = releasem(t0)                                                    ()
	t10 = mcall(park_m)                                                  ()
	return
3:                                                            cond.true P:1 S:2
	t11 = t3 != 4098:uint32                                            bool
	if t11 goto 1 else 2

# Name: runtime.goparkunlock
# Package: runtime
# Location: /usr/local/go/src/runtime/proc.go:135:6
func goparkunlock(lock *mutex, reason string):
0:                                                                entry P:0 S:0
	t0 = convert unsafe.Pointer <- *byte (parkunlock_c)      unsafe.Pointer
	t1 = convert unsafe.Pointer <- *mutex (lock)             unsafe.Pointer
	t2 = gopark(t0, t1, reason)                                          ()
	return

# Name: runtime.goready
# Package: runtime
# Location: /usr/local/go/src/runtime/proc.go:139:6
func goready(gp *g):
0:                                                                entry P:0 S:0
	t0 = acquirem()                                                      *m
	t1 = &t0.ptrarg [#46]                                *[4]unsafe.Pointer
	t2 = &t1[0:int]                                         *unsafe.Pointer
	t3 = convert unsafe.Pointer <- *g (gp)                   unsafe.Pointer
	*t2 = t3
	t4 = onM(ready_m)                                                    ()
	t5 = releasem(t0)                                                    ()
	return

# Name: runtime.acquireSudog
# Package: runtime
# Location: /usr/local/go/src/runtime/proc.go:147:6
func acquireSudog() *sudog:
0:                                                                entry P:0 S:2
	t0 = gomcache()                                                 *mcache
	t1 = &t0.sudogcache [#7]                                        **sudog
	t2 = *t1                                                         *sudog
	t3 = t2 != nil:*sudog                                              bool
	if t3 goto 1 else 2
1:                                                              if.then P:1 S:2
	t4 = &t2.elem [#4]                                      *unsafe.Pointer
	t5 = *t4                                                 unsafe.Pointer
	t6 = t5 != nil:unsafe.Pointer                                      bool
	if t6 goto 3 else 4
2:                                                              if.done P:1 S:0
	t7 = acquirem()                                                      *m
	t8 = new sudog (new)                                             *sudog
	t9 = releasem(t7)                                                    ()
	return t8
3:                                                              if.then P:1 S:1
	t10 = gothrow("acquireSudog: fou...":string)                         ()
	jump 4
4:                                                              if.done P:2 S:0
	t11 = &t0.sudogcache [#7]                                       **sudog
	t12 = &t2.next [#2]                                             **sudog
	t13 = *t12                                                       *sudog
	*t11 = t13
	t14 = &t2.next [#2]                                             **sudog
	*t14 = nil:*sudog
	return t2

# Name: runtime.releaseSudog
# Package: runtime
# Location: /usr/local/go/src/runtime/proc.go:174:6
func releaseSudog(s *sudog):
0:                                                                entry P:0 S:2
	t0 = &s.elem [#4]                                       *unsafe.Pointer
	t1 = *t0                                                 unsafe.Pointer
	t2 = t1 != nil:unsafe.Pointer                                      bool
	if t2 goto 1 else 2
1:                                                              if.then P:1 S:1
	t3 = gothrow("runtime: sudog wi...":string)                          ()
	jump 2
2:                                                              if.done P:2 S:2
	t4 = &s.selectdone [#1]                                        **uint32
	t5 = *t4                                                        *uint32
	t6 = t5 != nil:*uint32                                             bool
	if t6 goto 3 else 4
3:                                                              if.then P:1 S:1
	t7 = gothrow("runtime: sudog wi...":string)                          ()
	jump 4
4:                                                              if.done P:2 S:2
	t8 = &s.next [#2]                                               **sudog
	t9 = *t8                                                         *sudog
	t10 = t9 != nil:*sudog                                             bool
	if t10 goto 5 else 6
5:                                                              if.then P:1 S:1
	t11 = gothrow("runtime: sudog wi...":string)                         ()
	jump 6
6:                                                              if.done P:2 S:2
	t12 = &s.prev [#3]                                              **sudog
	t13 = *t12                                                       *sudog
	t14 = t13 != nil:*sudog                                            bool
	if t14 goto 7 else 8
7:                                                              if.then P:1 S:1
	t15 = gothrow("runtime: sudog wi...":string)                         ()
	jump 8
8:                                                              if.done P:2 S:2
	t16 = &s.waitlink [#7]                                          **sudog
	t17 = *t16                                                       *sudog
	t18 = t17 != nil:*sudog                                            bool
	if t18 goto 9 else 10
9:                                                              if.then P:1 S:1
	t19 = gothrow("runtime: sudog wi...":string)                         ()
	jump 10
10:                                                             if.done P:2 S:2
	t20 = getg()                                                         *g
	t21 = &t20.param [#8]                                   *unsafe.Pointer
	t22 = *t21                                               unsafe.Pointer
	t23 = t22 != nil:unsafe.Pointer                                    bool
	if t23 goto 11 else 12
11:                                                             if.then P:1 S:1
	t24 = gothrow("runtime: releaseS...":string)                         ()
	jump 12
12:                                                             if.done P:2 S:0
	t25 = gomcache()                                                *mcache
	t26 = &s.next [#2]                                              **sudog
	t27 = &t25.sudogcache [#7]                                      **sudog
	t28 = *t27                                                       *sudog
	*t26 = t28
	t29 = &t25.sudogcache [#7]                                      **sudog
	*t29 = s
	return

# Name: runtime.funcPC
# Package: runtime
# Location: /usr/local/go/src/runtime/proc.go:202:6
func funcPC(f interface{}) uintptr:
0:                                                                entry P:0 S:0
	t0 = new interface{} (f)                                   *interface{}
	*t0 = f
	t1 = convert unsafe.Pointer <- *interface{} (t0)         unsafe.Pointer
	t2 = add(t1, 8:uintptr)                                  unsafe.Pointer
	t3 = convert **uintptr <- unsafe.Pointer (t2)                 **uintptr
	t4 = *t3                                                       *uintptr
	t5 = *t4                                                        uintptr
	return t5

# Name: runtime.badmcall
# Package: runtime
# Location: /usr/local/go/src/runtime/proc.go:207:6
func badmcall(fn func(*g)):
0:                                                                entry P:0 S:0
	t0 = gothrow("runtime: mcall ca...":string)                          ()
	return

# Name: runtime.badmcall2
# Package: runtime
# Location: /usr/local/go/src/runtime/proc.go:211:6
func badmcall2(fn func(*g)):
0:                                                                entry P:0 S:0
	t0 = gothrow("runtime: mcall fu...":string)                          ()
	return

# Name: runtime.badreflectcall
# Package: runtime
# Location: /usr/local/go/src/runtime/proc.go:215:6
func badreflectcall():
0:                                                                entry P:0 S:0
	t0 = make interface{} <- string ("runtime: arg size...":string) interface{}
	panic t0

# Name: runtime.lockedOSThread
# Package: runtime
# Location: /usr/local/go/src/runtime/proc.go:219:6
func lockedOSThread() bool:
0:                                                                entry P:0 S:2
	t0 = getg()                                                          *g
	t1 = &t0.lockedm [#22]                                              **m
	t2 = *t1                                                             *m
	t3 = t2 != nil:*m                                                  bool
	if t3 goto 1 else 2
1:                                                            binop.rhs P:1 S:1
	t4 = &t0.m [#21]                                                    **m
	t5 = *t4                                                             *m
	t6 = &t5.lockedg [#30]                                              **g
	t7 = *t6                                                             *g
	t8 = t7 != nil:*g                                                  bool
	jump 2
2:                                                           binop.done P:2 S:0
	t9 = phi [0: false:bool, 1: t8] #&&                                bool
	return t9

# Name: runtime.newP
# Package: runtime
# Location: /usr/local/go/src/runtime/proc.go:224:6
func newP() *p:
0:                                                                entry P:0 S:0
	t0 = new p (new)                                                     *p
	return t0

# Name: runtime.newM
# Package: runtime
# Location: /usr/local/go/src/runtime/proc.go:228:6
func newM() *m:
0:                                                                entry P:0 S:0
	t0 = new m (new)                                                     *m
	return t0

# Name: runtime.newG
# Package: runtime
# Location: /usr/local/go/src/runtime/proc.go:232:6
func newG() *g:
0:                                                                entry P:0 S:0
	t0 = new g (new)                                                     *g
	return t0

# Name: runtime.allgadd
# Package: runtime
# Location: /usr/local/go/src/runtime/proc.go:236:6
func allgadd(gp *g):
0:                                                                entry P:0 S:2
	t0 = readgstatus(gp)                                             uint32
	t1 = t0 == 0:uint32                                                bool
	if t1 goto 1 else 2
1:                                                              if.then P:1 S:1
	t2 = gothrow("allgadd: bad stat...":string)                          ()
	jump 2
2:                                                              if.done P:2 S:0
	t3 = lock(allglock)                                                  ()
	t4 = *allgs                                                        []*g
	t5 = new [1]*g (varargs)                                         *[1]*g
	t6 = &t5[0:int]                                                     **g
	*t6 = gp
	t7 = slice t5[:]                                                   []*g
	t8 = append(t4, t7...)                                             []*g
	*allgs = t8
	t9 = *allgs                                                        []*g
	t10 = &t9[0:int]                                                    **g
	*allg = t10
	t11 = *allgs                                                       []*g
	t12 = len(t11)                                                      int
	t13 = convert uintptr <- int (t12)                              uintptr
	*allglen = t13
	t14 = unlock(allglock)                                               ()
	return

# Name: runtime.raceReadObjectPC
# Package: runtime
# Location: /usr/local/go/src/runtime/race0.go:19:6
func raceReadObjectPC(t *_type, addr unsafe.Pointer, callerpc uintptr, pc uintptr):
0:                                                                entry P:0 S:0
	t0 = gothrow("race":string)                                          ()
	return

# Name: runtime.raceWriteObjectPC
# Package: runtime
# Location: /usr/local/go/src/runtime/race0.go:20:6
func raceWriteObjectPC(t *_type, addr unsafe.Pointer, callerpc uintptr, pc uintptr):
0:                                                                entry P:0 S:0
	t0 = gothrow("race":string)                                          ()
	return

# Name: runtime.raceinit
# Package: runtime
# Location: /usr/local/go/src/runtime/race0.go:21:6
func raceinit():
0:                                                                entry P:0 S:0
	t0 = gothrow("race":string)                                          ()
	return

# Name: runtime.racefini
# Package: runtime
# Location: /usr/local/go/src/runtime/race0.go:22:6
func racefini():
0:                                                                entry P:0 S:0
	t0 = gothrow("race":string)                                          ()
	return

# Name: runtime.racemapshadow
# Package: runtime
# Location: /usr/local/go/src/runtime/race0.go:23:6
func racemapshadow(addr unsafe.Pointer, size uintptr):
0:                                                                entry P:0 S:0
	t0 = gothrow("race":string)                                          ()
	return

# Name: runtime.racewritepc
# Package: runtime
# Location: /usr/local/go/src/runtime/race0.go:24:6
func racewritepc(addr unsafe.Pointer, callerpc uintptr, pc uintptr):
0:                                                                entry P:0 S:0
	t0 = gothrow("race":string)                                          ()
	return

# Name: runtime.racereadpc
# Package: runtime
# Location: /usr/local/go/src/runtime/race0.go:25:6
func racereadpc(addr unsafe.Pointer, callerpc uintptr, pc uintptr):
0:                                                                entry P:0 S:0
	t0 = gothrow("race":string)                                          ()
	return

# Name: runtime.racereadrangepc
# Package: runtime
# Location: /usr/local/go/src/runtime/race0.go:26:6
func racereadrangepc(addr unsafe.Pointer, sz uintptr, callerpc uintptr, pc uintptr):
0:                                                                entry P:0 S:0
	t0 = gothrow("race":string)                                          ()
	return

# Name: runtime.racewriterangepc
# Package: runtime
# Location: /usr/local/go/src/runtime/race0.go:27:6
func racewriterangepc(addr unsafe.Pointer, sz uintptr, callerpc uintptr, pc uintptr):
0:                                                                entry P:0 S:0
	t0 = gothrow("race":string)                                          ()
	return

# Name: runtime.raceacquire
# Package: runtime
# Location: /usr/local/go/src/runtime/race0.go:28:6
func raceacquire(addr unsafe.Pointer):
0:                                                                entry P:0 S:0
	t0 = gothrow("race":string)                                          ()
	return

# Name: runtime.raceacquireg
# Package: runtime
# Location: /usr/local/go/src/runtime/race0.go:29:6
func raceacquireg(gp *g, addr unsafe.Pointer):
0:                                                                entry P:0 S:0
	t0 = gothrow("race":string)                                          ()
	return

# Name: runtime.racerelease
# Package: runtime
# Location: /usr/local/go/src/runtime/race0.go:30:6
func racerelease(addr unsafe.Pointer):
0:                                                                entry P:0 S:0
	t0 = gothrow("race":string)                                          ()
	return

# Name: runtime.racereleaseg
# Package: runtime
# Location: /usr/local/go/src/runtime/race0.go:31:6
func racereleaseg(gp *g, addr unsafe.Pointer):
0:                                                                entry P:0 S:0
	t0 = gothrow("race":string)                                          ()
	return

# Name: runtime.racereleasemerge
# Package: runtime
# Location: /usr/local/go/src/runtime/race0.go:32:6
func racereleasemerge(addr unsafe.Pointer):
0:                                                                entry P:0 S:0
	t0 = gothrow("race":string)                                          ()
	return

# Name: runtime.racereleasemergeg
# Package: runtime
# Location: /usr/local/go/src/runtime/race0.go:33:6
func racereleasemergeg(gp *g, addr unsafe.Pointer):
0:                                                                entry P:0 S:0
	t0 = gothrow("race":string)                                          ()
	return

# Name: runtime.racefingo
# Package: runtime
# Location: /usr/local/go/src/runtime/race0.go:34:6
func racefingo():
0:                                                                entry P:0 S:0
	t0 = gothrow("race":string)                                          ()
	return

# Name: runtime.racemalloc
# Package: runtime
# Location: /usr/local/go/src/runtime/race0.go:35:6
func racemalloc(p unsafe.Pointer, sz uintptr):
0:                                                                entry P:0 S:0
	t0 = gothrow("race":string)                                          ()
	return

# Name: runtime.racegostart
# Package: runtime
# Location: /usr/local/go/src/runtime/race0.go:36:6
func racegostart(pc uintptr) uintptr:
0:                                                                entry P:0 S:0
	t0 = gothrow("race":string)                                          ()
	return 0:uintptr

# Name: runtime.racegoend
# Package: runtime
# Location: /usr/local/go/src/runtime/race0.go:37:6
func racegoend():
0:                                                                entry P:0 S:0
	t0 = gothrow("race":string)                                          ()
	return

# Name: runtime.setMaxStack
# Package: runtime
# Location: /usr/local/go/src/runtime/rdebug.go:7:6
func setMaxStack(in int) (out int):
0:                                                                entry P:0 S:0
	t0 = *maxstacksize                                              uintptr
	t1 = convert int <- uintptr (t0)                                    int
	t2 = convert uintptr <- int (in)                                uintptr
	*maxstacksize = t2
	return t1

# Name: runtime.setGCPercent
# Package: runtime
# Location: /usr/local/go/src/runtime/rdebug.go:13:6
func setGCPercent(in int32) (out int32):
0:                                                                entry P:0 S:0
	t0 = acquirem()                                                      *m
	t1 = &t0.scalararg [#45]                                    *[4]uintptr
	t2 = &t1[0:int]                                                *uintptr
	t3 = convert int <- int32 (in)                                      int
	t4 = convert uintptr <- int (t3)                                uintptr
	*t2 = t4
	t5 = onM(setgcpercent_m)                                             ()
	t6 = &t0.scalararg [#45]                                    *[4]uintptr
	t7 = &t6[0:int]                                                *uintptr
	t8 = *t7                                                        uintptr
	t9 = convert int <- uintptr (t8)                                    int
	t10 = convert int32 <- int (t9)                                   int32
	t11 = releasem(t0)                                                   ()
	return t10

# Name: runtime.setPanicOnFault
# Package: runtime
# Location: /usr/local/go/src/runtime/rdebug.go:22:6
func setPanicOnFault(new bool) (old bool):
0:                                                                entry P:0 S:0
	t0 = acquirem()                                                      *m
	t1 = &t0.curg [#6]                                                  **g
	t2 = *t1                                                             *g
	t3 = &t2.paniconfault [#16]                                       *bool
	t4 = *t3                                                           bool
	t5 = &t0.curg [#6]                                                  **g
	t6 = *t5                                                             *g
	t7 = &t6.paniconfault [#16]                                       *bool
	*t7 = new
	t8 = releasem(t0)                                                    ()
	return t4

# Name: runtime.setMaxThreads
# Package: runtime
# Location: /usr/local/go/src/runtime/rdebug.go:30:6
func setMaxThreads(in int) (out int):
0:                                                                entry P:0 S:0
	t0 = acquirem()                                                      *m
	t1 = &t0.scalararg [#45]                                    *[4]uintptr
	t2 = &t1[0:int]                                                *uintptr
	t3 = convert uintptr <- int (in)                                uintptr
	*t2 = t3
	t4 = onM(setmaxthreads_m)                                            ()
	t5 = &t0.scalararg [#45]                                    *[4]uintptr
	t6 = &t5[0:int]                                                *uintptr
	t7 = *t6                                                        uintptr
	t8 = convert int <- uintptr (t7)                                    int
	t9 = releasem(t0)                                                    ()
	return t8

# Name: runtime.charntorune
# Package: runtime
# Location: /usr/local/go/src/runtime/rune.go:75:6
func charntorune(s string) (rune, int):
0:                                                                entry P:0 S:2
	t0 = len(s)                                                         int
	t1 = t0 <= 0:int                                                   bool
	if t1 goto 1 else 2
1:                                                              if.then P:1 S:0
	return 65533:rune, 1:int
2:                                                              if.done P:1 S:2
	t2 = s[0:int]                                                     uint8
	t3 = t2 < 128:byte                                                 bool
	if t3 goto 3 else 4
3:                                                              if.then P:1 S:0
	t4 = convert rune <- uint8 (t2)                                    rune
	return t4, 1:int
4:                                                              if.done P:1 S:2
	t5 = len(s)                                                         int
	t6 = t5 <= 1:int                                                   bool
	if t6 goto 5 else 6
5:                                                              if.then P:1 S:0
	return 65533:rune, 1:int
6:                                                              if.done P:1 S:2
	t7 = s[1:int]                                                     uint8
	t8 = t7 ^ 128:byte                                                 byte
	t9 = t8 & 192:byte                                                 byte
	t10 = t9 != 0:byte                                                 bool
	if t10 goto 7 else 8
7:                                                              if.then P:1 S:0
	return 65533:rune, 1:int
8:                                                              if.done P:1 S:2
	t11 = t2 < 224:byte                                                bool
	if t11 goto 9 else 10
9:                                                              if.then P:1 S:2
	t12 = t2 < 192:byte                                                bool
	if t12 goto 11 else 12
10:                                                             if.done P:1 S:2
	t13 = len(s)                                                        int
	t14 = t13 <= 2:int                                                 bool
	if t14 goto 15 else 16
11:                                                             if.then P:1 S:0
	return 65533:rune, 1:int
12:                                                             if.done P:1 S:2
	t15 = convert rune <- uint8 (t2)                                   rune
	t16 = t15 << 6:uint64                                              rune
	t17 = convert rune <- byte (t8)                                    rune
	t18 = t16 | t17                                                    rune
	t19 = t18 & 2047:rune                                              rune
	t20 = t19 <= 127:rune                                              bool
	if t20 goto 13 else 14
13:                                                             if.then P:1 S:0
	return 65533:rune, 1:int
14:                                                             if.done P:1 S:0
	return t19, 2:int
15:                                                             if.then P:1 S:0
	return 65533:rune, 1:int
16:                                                             if.done P:1 S:2
	t21 = s[2:int]                                                    uint8
	t22 = t21 ^ 128:byte                                               byte
	t23 = t22 & 192:byte                                               byte
	t24 = t23 != 0:byte                                                bool
	if t24 goto 17 else 18
17:                                                             if.then P:1 S:0
	return 65533:rune, 1:int
18:                                                             if.done P:1 S:2
	t25 = t2 < 240:byte                                                bool
	if t25 goto 19 else 20
19:                                                             if.then P:1 S:2
	t26 = convert rune <- uint8 (t2)                                   rune
	t27 = t26 << 6:uint64                                              rune
	t28 = convert rune <- byte (t8)                                    rune
	t29 = t27 | t28                                                    rune
	t30 = t29 << 6:uint64                                              rune
	t31 = convert rune <- byte (t22)                                   rune
	t32 = t30 | t31                                                    rune
	t33 = t32 & 65535:rune                                             rune
	t34 = t33 <= 2047:rune                                             bool
	if t34 goto 21 else 22
20:                                                             if.done P:1 S:2
	t35 = len(s)                                                        int
	t36 = t35 <= 3:int                                                 bool
	if t36 goto 26 else 27
21:                                                             if.then P:1 S:0
	return 65533:rune, 1:int
22:                                                             if.done P:1 S:2
	t37 = 55296:rune <= t33                                            bool
	if t37 goto 25 else 24
23:                                                             if.then P:1 S:0
	return 65533:rune, 1:int
24:                                                             if.done P:2 S:0
	return t33, 3:int
25:                                                           cond.true P:1 S:2
	t38 = t33 <= 57343:rune                                            bool
	if t38 goto 23 else 24
26:                                                             if.then P:1 S:0
	return 65533:rune, 1:int
27:                                                             if.done P:1 S:2
	t39 = s[3:int]                                                    uint8
	t40 = t39 ^ 128:byte                                               byte
	t41 = t40 & 192:byte                                               byte
	t42 = t41 != 0:byte                                                bool
	if t42 goto 28 else 29
28:                                                             if.then P:1 S:0
	return 65533:rune, 1:int
29:                                                             if.done P:1 S:2
	t43 = t2 < 248:byte                                                bool
	if t43 goto 30 else 31
30:                                                             if.then P:1 S:2
	t44 = convert rune <- uint8 (t2)                                   rune
	t45 = t44 << 6:uint64                                              rune
	t46 = convert rune <- byte (t8)                                    rune
	t47 = t45 | t46                                                    rune
	t48 = t47 << 6:uint64                                              rune
	t49 = convert rune <- byte (t22)                                   rune
	t50 = t48 | t49                                                    rune
	t51 = t50 << 6:uint64                                              rune
	t52 = convert rune <- byte (t40)                                   rune
	t53 = t51 | t52                                                    rune
	t54 = t53 & 2097151:rune                                           rune
	t55 = t54 <= 65535:rune                                            bool
	if t55 goto 32 else 34
31:                                                             if.done P:1 S:0
	return 65533:rune, 1:int
32:                                                             if.then P:2 S:0
	return 65533:rune, 1:int
33:                                                             if.done P:1 S:0
	return t54, 4:int
34:                                                          cond.false P:1 S:2
	t56 = t54 > 1114111:rune                                           bool
	if t56 goto 32 else 33

# Name: runtime.runetochar
# Package: runtime
# Location: /usr/local/go/src/runtime/rune.go:165:6
func runetochar(str []byte, r rune) int:
0:                                                                entry P:0 S:2
	t0 = convert uint32 <- rune (r)                                  uint32
	t1 = t0 <= 127:uint32                                              bool
	if t1 goto 1 else 2
1:                                                              if.then P:1 S:0
	t2 = &str[0:int]                                                  *byte
	t3 = convert byte <- uint32 (t0)                                   byte
	*t2 = t3
	return 1:int
2:                                                              if.done P:1 S:2
	t4 = t0 <= 2047:uint32                                             bool
	if t4 goto 3 else 4
3:                                                              if.then P:1 S:0
	t5 = &str[0:int]                                                  *byte
	t6 = t0 >> 6:uint64                                              uint32
	t7 = 192:uint32 | t6                                             uint32
	t8 = convert byte <- uint32 (t7)                                   byte
	*t5 = t8
	t9 = &str[1:int]                                                  *byte
	t10 = t0 & 63:uint32                                             uint32
	t11 = 128:uint32 | t10                                           uint32
	t12 = convert byte <- uint32 (t11)                                 byte
	*t9 = t12
	return 2:int
4:                                                              if.done P:1 S:2
	t13 = t0 > 1114111:uint32                                          bool
	if t13 goto 5 else 6
5:                                                              if.then P:1 S:1
	jump 6
6:                                                              if.done P:2 S:2
	t14 = phi [4: t0, 5: 65533:uint32] #c                            uint32
	t15 = 55296:uint32 <= t14                                          bool
	if t15 goto 9 else 8
7:                                                              if.then P:1 S:1
	jump 8
8:                                                              if.done P:3 S:2
	t16 = phi [6: t14, 9: t14, 7: 65533:uint32] #c                   uint32
	t17 = t16 <= 65535:uint32                                          bool
	if t17 goto 10 else 11
9:                                                            cond.true P:1 S:2
	t18 = t14 <= 57343:uint32                                          bool
	if t18 goto 7 else 8
10:                                                             if.then P:1 S:0
	t19 = &str[0:int]                                                 *byte
	t20 = t16 >> 12:uint64                                           uint32
	t21 = 224:uint32 | t20                                           uint32
	t22 = convert byte <- uint32 (t21)                                 byte
	*t19 = t22
	t23 = &str[1:int]                                                 *byte
	t24 = t16 >> 6:uint64                                            uint32
	t25 = t24 & 63:uint32                                            uint32
	t26 = 128:uint32 | t25                                           uint32
	t27 = convert byte <- uint32 (t26)                                 byte
	*t23 = t27
	t28 = &str[2:int]                                                 *byte
	t29 = t16 & 63:uint32                                            uint32
	t30 = 128:uint32 | t29                                           uint32
	t31 = convert byte <- uint32 (t30)                                 byte
	*t28 = t31
	return 3:int
11:                                                             if.done P:1 S:0
	t32 = &str[0:int]                                                 *byte
	t33 = t16 >> 18:uint64                                           uint32
	t34 = 240:uint32 | t33                                           uint32
	t35 = convert byte <- uint32 (t34)                                 byte
	*t32 = t35
	t36 = &str[1:int]                                                 *byte
	t37 = t16 >> 12:uint64                                           uint32
	t38 = t37 & 63:uint32                                            uint32
	t39 = 128:uint32 | t38                                           uint32
	t40 = convert byte <- uint32 (t39)                                 byte
	*t36 = t40
	t41 = &str[2:int]                                                 *byte
	t42 = t16 >> 6:uint64                                            uint32
	t43 = t42 & 63:uint32                                            uint32
	t44 = 128:uint32 | t43                                           uint32
	t45 = convert byte <- uint32 (t44)                                 byte
	*t41 = t45
	t46 = &str[3:int]                                                 *byte
	t47 = t16 & 63:uint32                                            uint32
	t48 = 128:uint32 | t47                                           uint32
	t49 = convert byte <- uint32 (t48)                                 byte
	*t46 = t49
	return 4:int

# Name: runtime.tickspersecond
# Package: runtime
# Location: /usr/local/go/src/runtime/runtime.go:15:6
func tickspersecond() int64:
0:                                                                entry P:0 S:2
	t0 = &ticks.val [#1]                                            *uint64
	t1 = atomicload64(t0)                                            uint64
	t2 = convert int64 <- uint64 (t1)                                 int64
	t3 = t2 != 0:int64                                                 bool
	if t3 goto 1 else 2
1:                                                              if.then P:1 S:0
	return t2
2:                                                              if.done P:1 S:2
	t4 = &ticks.lock [#0]                                            *mutex
	t5 = lock(t4)                                                        ()
	t6 = &ticks.val [#1]                                            *uint64
	t7 = *t6                                                         uint64
	t8 = convert int64 <- uint64 (t7)                                 int64
	t9 = t8 == 0:int64                                                 bool
	if t9 goto 3 else 4
3:                                                              if.then P:1 S:2
	t10 = nanotime()                                                  int64
	t11 = cputicks()                                                  int64
	t12 = usleep(100000:uint32)                                          ()
	t13 = nanotime()                                                  int64
	t14 = cputicks()                                                  int64
	t15 = t13 == t10                                                   bool
	if t15 goto 5 else 6
4:                                                              if.done P:2 S:0
	t16 = phi [2: t8, 8: t29] #r                                      int64
	t17 = &ticks.lock [#0]                                           *mutex
	t18 = unlock(t17)                                                    ()
	return t16
5:                                                              if.then P:1 S:1
	t19 = t13 + 1:int64                                               int64
	jump 6
6:                                                              if.done P:2 S:2
	t20 = phi [3: t13, 5: t19] #t1                                    int64
	t21 = t14 - t11                                                   int64
	t22 = t21 * 1000:int64                                            int64
	t23 = t22 * 1000:int64                                            int64
	t24 = t23 * 1000:int64                                            int64
	t25 = t20 - t10                                                   int64
	t26 = t24 / t25                                                   int64
	t27 = t26 == 0:int64                                               bool
	if t27 goto 7 else 8
7:                                                              if.then P:1 S:1
	t28 = t26 + 1:int64                                               int64
	jump 8
8:                                                              if.done P:2 S:1
	t29 = phi [6: t26, 7: t28] #r                                     int64
	t30 = &ticks.val [#1]                                           *uint64
	t31 = convert uint64 <- int64 (t29)                              uint64
	t32 = atomicstore64(t30, t31)                                        ()
	jump 4

# Name: runtime.makeStringSlice
# Package: runtime
# Location: /usr/local/go/src/runtime/runtime.go:41:6
func makeStringSlice(n int) []string:
0:                                                                entry P:0 S:0
	t0 = make []string n n                                         []string
	return t0

# Name: runtime.parforalloc
# Package: runtime
# Location: /usr/local/go/src/runtime/runtime.go:46:6
func parforalloc(nthrmax uint32) *parfor:
0:                                                                entry P:0 S:0
	t0 = new parfor (complit)                                       *parfor
	t1 = &t0.thr [#8]                                        **parforthread
	t2 = make []parforthread nthrmax nthrmax                 []parforthread
	t3 = &t2[0:int]                                           *parforthread
	t4 = &t0.nthrmax [#3]                                           *uint32
	*t1 = t3
	*t4 = nthrmax
	return t0

# Name: runtime.runtime_envs
# Package: runtime
# Location: /usr/local/go/src/runtime/runtime.go:57:6
func runtime_envs() []string:
0:                                                                entry P:0 S:0
	t0 = *envs                                                     []string
	return t0

# Name: runtime.runtime_args
# Package: runtime
# Location: /usr/local/go/src/runtime/runtime.go:60:6
func runtime_args() []string:
0:                                                                entry P:0 S:0
	t0 = *argslice                                                 []string
	return t0

# Name: runtime.selectsize
# Package: runtime
# Location: /usr/local/go/src/runtime/select.go:20:6
func selectsize(size uintptr) uintptr:
0:                                                                entry P:0 S:0
	t0 = size - 1:uintptr                                           uintptr
	t1 = t0 * 48:uintptr                                            uintptr
	t2 = 72:uintptr + t1                                            uintptr
	t3 = size * 8:uintptr                                           uintptr
	t4 = t2 + t3                                                    uintptr
	t5 = size * 2:uintptr                                           uintptr
	t6 = t4 + t5                                                    uintptr
	t7 = round(t6, 8:uintptr)                                       uintptr
	return t7

# Name: runtime.newselect
# Package: runtime
# Location: /usr/local/go/src/runtime/select.go:28:6
func newselect(sel *_select, selsize int64, size int32):
0:                                                                entry P:0 S:2
	t0 = convert uintptr <- int32 (size)                            uintptr
	t1 = selectsize(t0)                                             uintptr
	t2 = convert int64 <- uintptr (t1)                                int64
	t3 = selsize != t2                                                 bool
	if t3 goto 1 else 2
1:                                                              if.then P:1 S:1
	t4 = convert uintptr <- int32 (size)                            uintptr
	t5 = selectsize(t4)                                             uintptr
	t6 = print("runtime: bad sele...":string, selsize, ", want ":string, t5, "\n":string) ()
	t7 = gothrow("bad select size":string)                               ()
	jump 2
2:                                                              if.done P:2 S:2
	t8 = &sel.tcase [#0]                                            *uint16
	t9 = convert uint16 <- int32 (size)                              uint16
	*t8 = t9
	t10 = &sel.ncase [#1]                                           *uint16
	*t10 = 0:uint16
	t11 = &sel.lockorder [#3]                                      ***hchan
	t12 = &sel.scase [#4]                                         *[1]scase
	t13 = convert unsafe.Pointer <- *[1]scase (t12)          unsafe.Pointer
	t14 = convert uintptr <- int32 (size)                           uintptr
	t15 = t14 * 48:uintptr                                          uintptr
	t16 = add(t13, t15)                                      unsafe.Pointer
	t17 = convert **hchan <- unsafe.Pointer (t16)                   **hchan
	*t11 = t17
	t18 = &sel.pollorder [#2]                                      **uint16
	t19 = &sel.lockorder [#3]                                      ***hchan
	t20 = *t19                                                      **hchan
	t21 = convert unsafe.Pointer <- **hchan (t20)            unsafe.Pointer
	t22 = convert uintptr <- int32 (size)                           uintptr
	t23 = t22 * 8:uintptr                                           uintptr
	t24 = add(t21, t23)                                      unsafe.Pointer
	t25 = convert *uint16 <- unsafe.Pointer (t24)                   *uint16
	*t18 = t25
	if false:untyped bool goto 3 else 4
3:                                                              if.then P:1 S:1
	t26 = print("newselect s=":string, sel, " size=":string, size, "\n":string) ()
	jump 4
4:                                                              if.done P:2 S:0
	return

# Name: runtime.selectsend
# Package: runtime
# Location: /usr/local/go/src/runtime/select.go:44:6
func selectsend(sel *_select, c *hchan, elem unsafe.Pointer) (selected bool):
0:                                                                entry P:0 S:2
	t0 = new *_select (sel)                                       **_select
	*t0 = sel
	t1 = new bool (selected)                                          *bool
	t2 = c != nil:*hchan                                               bool
	if t2 goto 1 else 2
1:                                                              if.then P:1 S:1
	t3 = *t0                                                       *_select
	t4 = convert unsafe.Pointer <- **_select (t0)            unsafe.Pointer
	t5 = getcallerpc(t4)                                            uintptr
	t6 = convert unsafe.Pointer <- *bool (t1)                unsafe.Pointer
	t7 = convert uintptr <- unsafe.Pointer (t6)                     uintptr
	t8 = convert unsafe.Pointer <- **_select (t0)            unsafe.Pointer
	t9 = convert uintptr <- unsafe.Pointer (t8)                     uintptr
	t10 = t7 - t9                                                   uintptr
	t11 = selectsendImpl(t3, c, t5, elem, t10)                           ()
	jump 2
2:                                                              if.done P:2 S:0
	t12 = *t1                                                          bool
	return t12

# Name: runtime.selectsendImpl
# Package: runtime
# Location: /usr/local/go/src/runtime/select.go:53:6
func selectsendImpl(sel *_select, c *hchan, pc uintptr, elem unsafe.Pointer, so uintptr):
0:                                                                entry P:0 S:2
	t0 = &sel.ncase [#1]                                            *uint16
	t1 = *t0                                                         uint16
	t2 = &sel.tcase [#0]                                            *uint16
	t3 = *t2                                                         uint16
	t4 = t1 >= t3                                                      bool
	if t4 goto 1 else 2
1:                                                              if.then P:1 S:1
	t5 = gothrow("selectsend: too m...":string)                          ()
	jump 2
2:                                                              if.done P:2 S:2
	t6 = &sel.ncase [#1]                                            *uint16
	t7 = t1 + 1:uint16                                               uint16
	*t6 = t7
	t8 = &sel.scase [#4]                                          *[1]scase
	t9 = convert unsafe.Pointer <- *[1]scase (t8)            unsafe.Pointer
	t10 = convert uintptr <- uint16 (t1)                            uintptr
	t11 = t10 * 48:uintptr                                          uintptr
	t12 = add(t9, t11)                                       unsafe.Pointer
	t13 = convert *scase <- unsafe.Pointer (t12)                     *scase
	t14 = &t13.pc [#2]                                             *uintptr
	*t14 = pc
	t15 = &t13._chan [#1]                                           **hchan
	*t15 = c
	t16 = &t13.so [#4]                                              *uint16
	t17 = convert uint16 <- uintptr (so)                             uint16
	*t16 = t17
	t18 = &t13.kind [#3]                                            *uint16
	*t18 = 2:uint16
	t19 = &t13.elem [#0]                                    *unsafe.Pointer
	*t19 = elem
	if false:untyped bool goto 3 else 4
3:                                                              if.then P:1 S:1
	t20 = &t13.pc [#2]                                             *uintptr
	t21 = *t20                                                      uintptr
	t22 = convert hex <- uintptr (t21)                                  hex
	t23 = &t13._chan [#1]                                           **hchan
	t24 = *t23                                                       *hchan
	t25 = &t13.so [#4]                                              *uint16
	t26 = *t25                                                       uint16
	t27 = print("selectsend s=":string, sel, " pc=":string, t22, " chan=":string, t24, " so=":string, t26, "\n":string) ()
	jump 4
4:                                                              if.done P:2 S:0
	return

# Name: runtime.selectrecv
# Package: runtime
# Location: /usr/local/go/src/runtime/select.go:73:6
func selectrecv(sel *_select, c *hchan, elem unsafe.Pointer) (selected bool):
0:                                                                entry P:0 S:2
	t0 = new *_select (sel)                                       **_select
	*t0 = sel
	t1 = new bool (selected)                                          *bool
	t2 = c != nil:*hchan                                               bool
	if t2 goto 1 else 2
1:                                                              if.then P:1 S:1
	t3 = *t0                                                       *_select
	t4 = convert unsafe.Pointer <- **_select (t0)            unsafe.Pointer
	t5 = getcallerpc(t4)                                            uintptr
	t6 = convert unsafe.Pointer <- *bool (t1)                unsafe.Pointer
	t7 = convert uintptr <- unsafe.Pointer (t6)                     uintptr
	t8 = convert unsafe.Pointer <- **_select (t0)            unsafe.Pointer
	t9 = convert uintptr <- unsafe.Pointer (t8)                     uintptr
	t10 = t7 - t9                                                   uintptr
	t11 = selectrecvImpl(t3, c, t5, elem, nil:*bool, t10)                ()
	jump 2
2:                                                              if.done P:2 S:0
	t12 = *t1                                                          bool
	return t12

# Name: runtime.selectrecv2
# Package: runtime
# Location: /usr/local/go/src/runtime/select.go:82:6
func selectrecv2(sel *_select, c *hchan, elem unsafe.Pointer, received *bool) (selected bool):
0:                                                                entry P:0 S:2
	t0 = new *_select (sel)                                       **_select
	*t0 = sel
	t1 = new bool (selected)                                          *bool
	t2 = c != nil:*hchan                                               bool
	if t2 goto 1 else 2
1:                                                              if.then P:1 S:1
	t3 = *t0                                                       *_select
	t4 = convert unsafe.Pointer <- **_select (t0)            unsafe.Pointer
	t5 = getcallerpc(t4)                                            uintptr
	t6 = convert unsafe.Pointer <- *bool (t1)                unsafe.Pointer
	t7 = convert uintptr <- unsafe.Pointer (t6)                     uintptr
	t8 = convert unsafe.Pointer <- **_select (t0)            unsafe.Pointer
	t9 = convert uintptr <- unsafe.Pointer (t8)                     uintptr
	t10 = t7 - t9                                                   uintptr
	t11 = selectrecvImpl(t3, c, t5, elem, received, t10)                 ()
	jump 2
2:                                                              if.done P:2 S:0
	t12 = *t1                                                          bool
	return t12

# Name: runtime.selectrecvImpl
# Package: runtime
# Location: /usr/local/go/src/runtime/select.go:90:6
func selectrecvImpl(sel *_select, c *hchan, pc uintptr, elem unsafe.Pointer, received *bool, so uintptr):
0:                                                                entry P:0 S:2
	t0 = &sel.ncase [#1]                                            *uint16
	t1 = *t0                                                         uint16
	t2 = &sel.tcase [#0]                                            *uint16
	t3 = *t2                                                         uint16
	t4 = t1 >= t3                                                      bool
	if t4 goto 1 else 2
1:                                                              if.then P:1 S:1
	t5 = gothrow("selectrecv: too m...":string)                          ()
	jump 2
2:                                                              if.done P:2 S:2
	t6 = &sel.ncase [#1]                                            *uint16
	t7 = t1 + 1:uint16                                               uint16
	*t6 = t7
	t8 = &sel.scase [#4]                                          *[1]scase
	t9 = convert unsafe.Pointer <- *[1]scase (t8)            unsafe.Pointer
	t10 = convert uintptr <- uint16 (t1)                            uintptr
	t11 = t10 * 48:uintptr                                          uintptr
	t12 = add(t9, t11)                                       unsafe.Pointer
	t13 = convert *scase <- unsafe.Pointer (t12)                     *scase
	t14 = &t13.pc [#2]                                             *uintptr
	*t14 = pc
	t15 = &t13._chan [#1]                                           **hchan
	*t15 = c
	t16 = &t13.so [#4]                                              *uint16
	t17 = convert uint16 <- uintptr (so)                             uint16
	*t16 = t17
	t18 = &t13.kind [#3]                                            *uint16
	*t18 = 1:uint16
	t19 = &t13.elem [#0]                                    *unsafe.Pointer
	*t19 = elem
	t20 = &t13.receivedp [#5]                                        **bool
	*t20 = received
	if false:untyped bool goto 3 else 4
3:                                                              if.then P:1 S:1
	t21 = &t13.pc [#2]                                             *uintptr
	t22 = *t21                                                      uintptr
	t23 = convert hex <- uintptr (t22)                                  hex
	t24 = &t13._chan [#1]                                           **hchan
	t25 = *t24                                                       *hchan
	t26 = &t13.so [#4]                                              *uint16
	t27 = *t26                                                       uint16
	t28 = print("selectrecv s=":string, sel, " pc=":string, t23, " chan=":string, t25, " so=":string, t27, "\n":string) ()
	jump 4
4:                                                              if.done P:2 S:0
	return

# Name: runtime.selectdefault
# Package: runtime
# Location: /usr/local/go/src/runtime/select.go:110:6
func selectdefault(sel *_select) (selected bool):
0:                                                                entry P:0 S:0
	t0 = new *_select (sel)                                       **_select
	*t0 = sel
	t1 = new bool (selected)                                          *bool
	t2 = *t0                                                       *_select
	t3 = convert unsafe.Pointer <- **_select (t0)            unsafe.Pointer
	t4 = getcallerpc(t3)                                            uintptr
	t5 = convert unsafe.Pointer <- *bool (t1)                unsafe.Pointer
	t6 = convert uintptr <- unsafe.Pointer (t5)                     uintptr
	t7 = convert unsafe.Pointer <- **_select (t0)            unsafe.Pointer
	t8 = convert uintptr <- unsafe.Pointer (t7)                     uintptr
	t9 = t6 - t8                                                    uintptr
	t10 = selectdefaultImpl(t2, t4, t9)                                  ()
	t11 = *t1                                                          bool
	return t11

# Name: runtime.selectdefaultImpl
# Package: runtime
# Location: /usr/local/go/src/runtime/select.go:115:6
func selectdefaultImpl(sel *_select, callerpc uintptr, so uintptr):
0:                                                                entry P:0 S:2
	t0 = &sel.ncase [#1]                                            *uint16
	t1 = *t0                                                         uint16
	t2 = &sel.tcase [#0]                                            *uint16
	t3 = *t2                                                         uint16
	t4 = t1 >= t3                                                      bool
	if t4 goto 1 else 2
1:                                                              if.then P:1 S:1
	t5 = gothrow("selectdefault: to...":string)                          ()
	jump 2
2:                                                              if.done P:2 S:2
	t6 = &sel.ncase [#1]                                            *uint16
	t7 = t1 + 1:uint16                                               uint16
	*t6 = t7
	t8 = &sel.scase [#4]                                          *[1]scase
	t9 = convert unsafe.Pointer <- *[1]scase (t8)            unsafe.Pointer
	t10 = convert uintptr <- uint16 (t1)                            uintptr
	t11 = t10 * 48:uintptr                                          uintptr
	t12 = add(t9, t11)                                       unsafe.Pointer
	t13 = convert *scase <- unsafe.Pointer (t12)                     *scase
	t14 = &t13.pc [#2]                                             *uintptr
	*t14 = callerpc
	t15 = &t13._chan [#1]                                           **hchan
	*t15 = nil:*hchan
	t16 = &t13.so [#4]                                              *uint16
	t17 = convert uint16 <- uintptr (so)                             uint16
	*t16 = t17
	t18 = &t13.kind [#3]                                            *uint16
	*t18 = 3:uint16
	if false:untyped bool goto 3 else 4
3:                                                              if.then P:1 S:1
	t19 = &t13.pc [#2]                                             *uintptr
	t20 = *t19                                                      uintptr
	t21 = convert hex <- uintptr (t20)                                  hex
	t22 = &t13.so [#4]                                              *uint16
	t23 = *t22                                                       uint16
	t24 = print("selectdefault s=":string, sel, " pc=":string, t21, " so=":string, t23, "\n":string) ()
	jump 4
4:                                                              if.done P:2 S:0
	return

# Name: runtime.sellock
# Package: runtime
# Location: /usr/local/go/src/runtime/select.go:132:6
func sellock(sel *_select):
0:                                                                entry P:0 S:1
	t0 = new sliceStruct (lockslice)                           *sliceStruct
	t1 = &t0.array [#0]                                     *unsafe.Pointer
	t2 = &sel.lockorder [#3]                                       ***hchan
	t3 = *t2                                                        **hchan
	t4 = convert unsafe.Pointer <- **hchan (t3)              unsafe.Pointer
	t5 = &t0.len [#1]                                                  *int
	t6 = &sel.ncase [#1]                                            *uint16
	t7 = *t6                                                         uint16
	t8 = convert int <- uint16 (t7)                                     int
	t9 = &t0.cap [#2]                                                  *int
	t10 = &sel.ncase [#1]                                           *uint16
	t11 = *t10                                                       uint16
	t12 = convert int <- uint16 (t11)                                   int
	*t1 = t4
	*t5 = t8
	*t9 = t12
	t13 = convert unsafe.Pointer <- *sliceStruct (t0)        unsafe.Pointer
	t14 = convert *[]*hchan <- unsafe.Pointer (t13)               *[]*hchan
	t15 = *t14                                                     []*hchan
	t16 = len(t15)                                                      int
	jump 1
1:                                                      rangeindex.loop P:4 S:2
	t17 = phi [0: nil:*hchan, 2: t17, 5: t17, 4: t22] #c             *hchan
	t18 = phi [0: -1:int, 2: t19, 5: t19, 4: t19]                       int
	t19 = t18 + 1:int                                                   int
	t20 = t19 < t16                                                    bool
	if t20 goto 2 else 3
2:                                                      rangeindex.body P:1 S:2
	t21 = &t15[t19]                                                 **hchan
	t22 = *t21                                                       *hchan
	t23 = t22 != nil:*hchan                                            bool
	if t23 goto 5 else 1
3:                                                      rangeindex.done P:1 S:0
	return
4:                                                              if.then P:1 S:1
	t24 = &t22.lock [#10]                                            *mutex
	t25 = lock(t24)                                                      ()
	jump 1
5:                                                            cond.true P:1 S:2
	t26 = t22 != t17                                                   bool
	if t26 goto 4 else 1

# Name: runtime.selunlock
# Package: runtime
# Location: /usr/local/go/src/runtime/select.go:144:6
func selunlock(sel *_select):
0:                                                                entry P:0 S:2
	t0 = &sel.ncase [#1]                                            *uint16
	t1 = *t0                                                         uint16
	t2 = convert int <- uint16 (t1)                                     int
	t3 = new sliceStruct (lockslice)                           *sliceStruct
	t4 = &t3.array [#0]                                     *unsafe.Pointer
	t5 = &sel.lockorder [#3]                                       ***hchan
	t6 = *t5                                                        **hchan
	t7 = convert unsafe.Pointer <- **hchan (t6)              unsafe.Pointer
	t8 = &t3.len [#1]                                                  *int
	t9 = &t3.cap [#2]                                                  *int
	*t4 = t7
	*t8 = t2
	*t9 = t2
	t10 = convert unsafe.Pointer <- *sliceStruct (t3)        unsafe.Pointer
	t11 = convert *[]*hchan <- unsafe.Pointer (t10)               *[]*hchan
	t12 = *t11                                                     []*hchan
	t13 = t2 > 0:int                                                   bool
	if t13 goto 3 else 2
1:                                                              if.then P:1 S:1
	jump 2
2:                                                              if.done P:3 S:1
	t14 = phi [0: 0:int, 3: 0:int, 1: 1:int] #r                         int
	t15 = t2 - 1:int                                                    int
	jump 6
3:                                                            cond.true P:1 S:2
	t16 = &t12[0:int]                                               **hchan
	t17 = *t16                                                       *hchan
	t18 = t17 == nil:*hchan                                            bool
	if t18 goto 1 else 2
4:                                                             for.body P:1 S:2
	t19 = &t12[t22]                                                 **hchan
	t20 = *t19                                                       *hchan
	t21 = t22 > 0:int                                                  bool
	if t21 goto 9 else 8
5:                                                             for.done P:1 S:0
	return
6:                                                             for.loop P:2 S:2
	t22 = phi [2: t15, 7: t24] #i                                       int
	t23 = t22 >= t14                                                   bool
	if t23 goto 4 else 5
7:                                                             for.post P:2 S:1
	t24 = t22 - 1:int                                                   int
	jump 6
8:                                                              if.done P:2 S:1
	t25 = &t20.lock [#10]                                            *mutex
	t26 = unlock(t25)                                                    ()
	jump 7
9:                                                            cond.true P:1 S:2
	t27 = t22 - 1:int                                                   int
	t28 = &t12[t27]                                                 **hchan
	t29 = *t28                                                       *hchan
	t30 = t20 == t29                                                   bool
	if t30 goto 7 else 8

# Name: runtime.selparkcommit
# Package: runtime
# Location: /usr/local/go/src/runtime/select.go:170:6
func selparkcommit(gp *g, sel *_select) bool:
0:                                                                entry P:0 S:0
	t0 = selunlock(sel)                                                  ()
	return true:bool

# Name: runtime.block
# Package: runtime
# Location: /usr/local/go/src/runtime/select.go:175:6
func block():
0:                                                                entry P:0 S:0
	t0 = gopark(nil:unsafe.Pointer, nil:unsafe.Pointer, "select (no cases)":string) ()
	return

# Name: runtime.selectgo
# Package: runtime
# Location: /usr/local/go/src/runtime/select.go:182:6
func selectgo(sel *_select):
0:                                                                entry P:0 S:0
	t0 = new *_select (sel)                                       **_select
	*t0 = sel
	t1 = *t0                                                       *_select
	t2 = selectgoImpl(t1)                                 (uintptr, uint16)
	t3 = extract t2 #0                                              uintptr
	t4 = extract t2 #1                                               uint16
	t5 = convert unsafe.Pointer <- **_select (t0)            unsafe.Pointer
	t6 = convert uintptr <- uint16 (t4)                             uintptr
	t7 = add(t5, t6)                                         unsafe.Pointer
	t8 = convert *bool <- unsafe.Pointer (t7)                         *bool
	*t8 = true:bool
	t9 = convert unsafe.Pointer <- **_select (t0)            unsafe.Pointer
	t10 = setcallerpc(t9, t3)                                            ()
	return

# Name: runtime.selectgoImpl
# Package: runtime
# Location: /usr/local/go/src/runtime/select.go:190:6
func selectgoImpl(sel *_select) (uintptr, uint16):
0:                                                                entry P:0 S:2
	if false:untyped bool goto 1 else 2
1:                                                              if.then P:1 S:1
	t0 = print("select: sel=":string, sel, "\n":string)                  ()
	jump 2
2:                                                              if.done P:2 S:2
	t1 = new sliceStruct (scaseslice)                          *sliceStruct
	t2 = &t1.array [#0]                                     *unsafe.Pointer
	t3 = &sel.scase [#4]                                          *[1]scase
	t4 = convert unsafe.Pointer <- *[1]scase (t3)            unsafe.Pointer
	t5 = &t1.len [#1]                                                  *int
	t6 = &sel.ncase [#1]                                            *uint16
	t7 = *t6                                                         uint16
	t8 = convert int <- uint16 (t7)                                     int
	t9 = &t1.cap [#2]                                                  *int
	t10 = &sel.ncase [#1]                                           *uint16
	t11 = *t10                                                       uint16
	t12 = convert int <- uint16 (t11)                                   int
	*t2 = t4
	*t5 = t8
	*t9 = t12
	t13 = convert unsafe.Pointer <- *sliceStruct (t1)        unsafe.Pointer
	t14 = convert *[]scase <- unsafe.Pointer (t13)                 *[]scase
	t15 = *t14                                                      []scase
	t16 = *blockprofilerate                                          uint64
	t17 = t16 > 0:uint64                                               bool
	if t17 goto 3 else 4
3:                                                              if.then P:1 S:1
	t18 = cputicks()                                                  int64
	jump 6
4:                                                              if.done P:2 S:1
	t19 = phi [2: 0:int64, 6: t18] #t0                                int64
	t20 = new sliceStruct (pollslice)                          *sliceStruct
	t21 = &t20.array [#0]                                   *unsafe.Pointer
	t22 = &sel.pollorder [#2]                                      **uint16
	t23 = *t22                                                      *uint16
	t24 = convert unsafe.Pointer <- *uint16 (t23)            unsafe.Pointer
	t25 = &t20.len [#1]                                                *int
	t26 = &sel.ncase [#1]                                           *uint16
	t27 = *t26                                                       uint16
	t28 = convert int <- uint16 (t27)                                   int
	t29 = &t20.cap [#2]                                                *int
	t30 = &sel.ncase [#1]                                           *uint16
	t31 = *t30                                                       uint16
	t32 = convert int <- uint16 (t31)                                   int
	*t21 = t24
	*t25 = t28
	*t29 = t32
	t33 = convert unsafe.Pointer <- *sliceStruct (t20)       unsafe.Pointer
	t34 = convert *[]uint16 <- unsafe.Pointer (t33)               *[]uint16
	t35 = *t34                                                     []uint16
	jump 9
5:                                                             for.body P:1 S:1
	t36 = &t15[t39]                                                  *scase
	t37 = &t36.releasetime [#6]                                      *int64
	*t37 = -1:int64
	t38 = t39 + 1:int                                                   int
	jump 6
6:                                                             for.loop P:2 S:2
	t39 = phi [3: 0:int, 5: t38] #i                                     int
	t40 = &sel.ncase [#1]                                           *uint16
	t41 = *t40                                                       uint16
	t42 = convert int <- uint16 (t41)                                   int
	t43 = t39 < t42                                                    bool
	if t43 goto 5 else 4
7:                                                             for.body P:1 S:1
	t44 = &t35[t47]                                                 *uint16
	t45 = convert uint16 <- int (t47)                                uint16
	*t44 = t45
	t46 = t47 + 1:int                                                   int
	jump 9
8:                                                             for.done P:1 S:1
	jump 12
9:                                                             for.loop P:2 S:2
	t47 = phi [4: 0:int, 7: t46] #i                                     int
	t48 = &sel.ncase [#1]                                           *uint16
	t49 = *t48                                                       uint16
	t50 = convert int <- uint16 (t49)                                   int
	t51 = t47 < t50                                                    bool
	if t51 goto 7 else 8
10:                                                            for.body P:1 S:1
	t52 = &t35[t79]                                                 *uint16
	t53 = *t52                                                       uint16
	t54 = fastrand1()                                                uint32
	t55 = convert int <- uint32 (t54)                                   int
	t56 = t79 + 1:int                                                   int
	t57 = t55 % t56                                                     int
	t58 = &t35[t79]                                                 *uint16
	t59 = &t35[t57]                                                 *uint16
	t60 = *t59                                                       uint16
	*t58 = t60
	t61 = &t35[t57]                                                 *uint16
	*t61 = t53
	t62 = t79 + 1:int                                                   int
	jump 12
11:                                                            for.done P:1 S:1
	t63 = new sliceStruct (lockslice)                          *sliceStruct
	t64 = &t63.array [#0]                                   *unsafe.Pointer
	t65 = &sel.lockorder [#3]                                      ***hchan
	t66 = *t65                                                      **hchan
	t67 = convert unsafe.Pointer <- **hchan (t66)            unsafe.Pointer
	t68 = &t63.len [#1]                                                *int
	t69 = &sel.ncase [#1]                                           *uint16
	t70 = *t69                                                       uint16
	t71 = convert int <- uint16 (t70)                                   int
	t72 = &t63.cap [#2]                                                *int
	t73 = &sel.ncase [#1]                                           *uint16
	t74 = *t73                                                       uint16
	t75 = convert int <- uint16 (t74)                                   int
	*t64 = t67
	*t68 = t71
	*t72 = t75
	t76 = convert unsafe.Pointer <- *sliceStruct (t63)       unsafe.Pointer
	t77 = convert *[]*hchan <- unsafe.Pointer (t76)               *[]*hchan
	t78 = *t77                                                     []*hchan
	jump 15
12:                                                            for.loop P:2 S:2
	t79 = phi [8: 1:int, 10: t62] #i                                    int
	t80 = &sel.ncase [#1]                                           *uint16
	t81 = *t80                                                       uint16
	t82 = convert int <- uint16 (t81)                                   int
	t83 = t79 < t82                                                    bool
	if t83 goto 10 else 11
13:                                                            for.body P:1 S:1
	t84 = &t15[t91]                                                  *scase
	t85 = &t84._chan [#1]                                           **hchan
	t86 = *t85                                                       *hchan
	jump 18
14:                                                            for.done P:1 S:1
	t87 = &sel.ncase [#1]                                           *uint16
	t88 = *t87                                                       uint16
	t89 = convert int <- uint16 (t88)                                   int
	t90 = t89 - 1:int                                                   int
	jump 22
15:                                                            for.loop P:2 S:2
	t91 = phi [11: 0:int, 17: t103] #i                                  int
	t92 = phi [11: 0:int, 17: t105] #k                                  int
	t93 = &sel.ncase [#1]                                           *uint16
	t94 = *t93                                                       uint16
	t95 = convert int <- uint16 (t94)                                   int
	t96 = t91 < t95                                                    bool
	if t96 goto 13 else 14
16:                                                            for.body P:1 S:1
	t97 = t104 - 1:int                                                  int
	t98 = t97 / 2:int                                                   int
	t99 = &t78[t104]                                                **hchan
	t100 = &t78[t98]                                                **hchan
	t101 = *t100                                                     *hchan
	*t99 = t101
	jump 18
17:                                                            for.done P:2 S:1
	t102 = &t78[t104]                                               **hchan
	*t102 = t86
	t103 = t91 + 1:int                                                  int
	jump 15
18:                                                            for.loop P:2 S:2
	t104 = phi [13: t91, 16: t98] #j                                    int
	t105 = phi [13: t92, 16: t98] #k                                    int
	t106 = t104 > 0:int                                                bool
	if t106 goto 19 else 17
19:                                                           cond.true P:1 S:2
	t107 = t104 - 1:int                                                 int
	t108 = t107 / 2:int                                                 int
	t109 = &t78[t108]                                               **hchan
	t110 = *t109                                                     *hchan
	t111 = (*hchan).sortkey(t110)                                   uintptr
	t112 = (*hchan).sortkey(t86)                                    uintptr
	t113 = t111 < t112                                                 bool
	if t113 goto 16 else 17
20:                                                            for.body P:1 S:1
	t114 = &t78[t121]                                               **hchan
	t115 = *t114                                                     *hchan
	t116 = &t78[t121]                                               **hchan
	t117 = &t78[0:int]                                              **hchan
	t118 = *t117                                                     *hchan
	*t116 = t118
	jump 23
21:                                                            for.done P:1 S:1
	t119 = sellock(sel)                                                  ()
	t120 = new uint32 (done)                                        *uint32
	jump 30
22:                                                            for.loop P:2 S:2
	t121 = phi [14: t90, 24: t130] #i                                   int
	t122 = phi [14: 0:int, 24: t128] #k                                 int
	t123 = t121 >= 0:int                                               bool
	if t123 goto 20 else 21
23:                                                            for.body P:2 S:2
	t124 = phi [20: 0:int, 29: t134] #j                                 int
	t125 = t124 * 2:int                                                 int
	t126 = t125 + 1:int                                                 int
	t127 = t126 >= t121                                                bool
	if t127 goto 24 else 25
24:                                                            for.done P:2 S:1
	t128 = phi [23: t126, 27: t134] #k                                  int
	t129 = &t78[t124]                                               **hchan
	*t129 = t115
	t130 = t121 - 1:int                                                 int
	jump 22
25:                                                             if.done P:1 S:2
	t131 = t126 + 1:int                                                 int
	t132 = t131 < t121                                                 bool
	if t132 goto 28 else 27
26:                                                             if.then P:1 S:1
	t133 = t126 + 1:int                                                 int
	jump 27
27:                                                             if.done P:3 S:2
	t134 = phi [25: t126, 28: t126, 26: t133] #k                        int
	t135 = (*hchan).sortkey(t115)                                   uintptr
	t136 = &t78[t134]                                               **hchan
	t137 = *t136                                                     *hchan
	t138 = (*hchan).sortkey(t137)                                   uintptr
	t139 = t135 < t138                                                 bool
	if t139 goto 29 else 24
28:                                                           cond.true P:1 S:2
	t140 = &t78[t126]                                               **hchan
	t141 = *t140                                                     *hchan
	t142 = (*hchan).sortkey(t141)                                   uintptr
	t143 = t126 + 1:int                                                 int
	t144 = &t78[t143]                                               **hchan
	t145 = *t144                                                     *hchan
	t146 = (*hchan).sortkey(t145)                                   uintptr
	t147 = t142 < t146                                                 bool
	if t147 goto 26 else 27
29:                                                             if.then P:1 S:1
	t148 = &t78[t124]                                               **hchan
	t149 = &t78[t134]                                               **hchan
	t150 = *t149                                                     *hchan
	*t148 = t150
	jump 23
30:                                                                loop P:2 S:1
	t151 = phi [21: nil:*g, 70: t224] #gp                                *g
	t152 = phi [21: nil:*sudog, 70: t255] #sg                        *sudog
	t153 = phi [21: nil:*hchan, 70: t301] #c                         *hchan
	t154 = phi [21: nil:*scase, 70: t302] #k                         *scase
	t155 = phi [21: nil:*sudog, 70: t303] #sglist                    *sudog
	t156 = phi [21: nil:*sudog, 70: t304] #sgnext                    *sudog
	t157 = phi [21: 0:int, 70: t262] #i                                 int
	t158 = phi [21: nil:*sudog, 70: t263] #sg                        *sudog
	t159 = phi [21: nil:*sudog, 70: t291] #sg1                       *sudog
	t160 = phi [21: 0:int, 70: t306] #i                                 int
	jump 33
31:                                                            for.body P:1 S:2
	t161 = &t35[t175]                                               *uint16
	t162 = *t161                                                     uint16
	t163 = convert int <- uint16 (t162)                                 int
	t164 = &t15[t163]                                                *scase
	t165 = &t164._chan [#1]                                         **hchan
	t166 = *t165                                                     *hchan
	t167 = &t164.kind [#3]                                          *uint16
	t168 = *t167                                                     uint16
	t169 = t168 == 1:uint16                                            bool
	if t169 goto 35 else 37
32:                                                            for.done P:1 S:2
	t170 = t173 != nil:*scase                                          bool
	if t170 goto 54 else 55
33:                                                            for.loop P:2 S:2
	t171 = phi [30: t152, 34: t180] #sg                              *sudog
	t172 = phi [30: t153, 34: t166] #c                               *hchan
	t173 = phi [30: nil:*scase, 34: t181] #dfl                       *scase
	t174 = phi [30: nil:*scase, 34: t164] #cas                       *scase
	t175 = phi [30: 0:int, 34: t182] #i                                 int
	t176 = &sel.ncase [#1]                                          *uint16
	t177 = *t176                                                     uint16
	t178 = convert int <- uint16 (t177)                                 int
	t179 = t175 < t178                                                 bool
	if t179 goto 31 else 32
34:                                                         switch.done P:5 S:1
	t180 = phi [39: t190, 50: t171, 44: t171, 45: t171, 51: t221] #sg *sudog
	t181 = phi [39: t173, 50: t173, 44: t164, 45: t173, 51: t173] #dfl *scase
	t182 = t175 + 1:int                                                 int
	jump 33
35:                                                         switch.body P:1 S:2
	t183 = &t166.dataqsiz [#1]                                        *uint
	t184 = *t183                                                       uint
	t185 = t184 > 0:uint                                               bool
	if t185 goto 38 else 40
36:                                                         switch.body P:1 S:2
	if false:untyped bool goto 46 else 47
37:                                                         switch.next P:1 S:2
	t186 = t168 == 2:uint16                                            bool
	if t186 goto 36 else 45
38:                                                             if.then P:1 S:2
	t187 = &t166.qcount [#0]                                          *uint
	t188 = *t187                                                       uint
	t189 = t188 > 0:uint                                               bool
	if t189 goto 41 else 39
39:                                                             if.done P:2 S:2
	t190 = phi [38: t171, 40: t195] #sg                              *sudog
	t191 = &t166.closed [#4]                                        *uint32
	t192 = *t191                                                     uint32
	t193 = t192 != 0:uint32                                            bool
	if t193 goto 43 else 34
40:                                                             if.else P:1 S:2
	t194 = &t166.sendq [#9]                                          *waitq
	t195 = (*waitq).dequeue(t194)                                    *sudog
	t196 = t195 != nil:*sudog                                          bool
	if t196 goto 42 else 39
41:                                                             if.then P:1 S:2
	if false:untyped bool goto 93 else 94
42:                                                             if.then P:1 S:2
	if false:untyped bool goto 115 else 116
43:                                                             if.then P:1 S:2
	t197 = selunlock(sel)                                                ()
	t198 = &t164.receivedp [#5]                                      **bool
	t199 = *t198                                                      *bool
	t200 = t199 != nil:*bool                                           bool
	if t200 goto 127 else 128
44:                                                         switch.body P:1 S:1
	jump 34
45:                                                         switch.next P:1 S:2
	t201 = t168 == 3:uint16                                            bool
	if t201 goto 44 else 34
46:                                                             if.then P:1 S:1
	t202 = convert unsafe.Pointer <- *hchan (t166)           unsafe.Pointer
	t203 = &t164.pc [#2]                                           *uintptr
	t204 = *t203                                                    uintptr
	t205 = *chansendpc                                              uintptr
	t206 = racereadpc(t202, t204, t205)                                  ()
	jump 47
47:                                                             if.done P:2 S:2
	t207 = &t166.closed [#4]                                        *uint32
	t208 = *t207                                                     uint32
	t209 = t208 != 0:uint32                                            bool
	if t209 goto 48 else 49
48:                                                             if.then P:1 S:0
	t210 = selunlock(sel)                                                ()
	t211 = make interface{} <- string ("send on closed ch...":string) interface{}
	panic t211
49:                                                             if.done P:1 S:2
	t212 = &t166.dataqsiz [#1]                                        *uint
	t213 = *t212                                                       uint
	t214 = t213 > 0:uint                                               bool
	if t214 goto 50 else 51
50:                                                             if.then P:1 S:2
	t215 = &t166.qcount [#0]                                          *uint
	t216 = *t215                                                       uint
	t217 = &t166.dataqsiz [#1]                                        *uint
	t218 = *t217                                                       uint
	t219 = t216 < t218                                                 bool
	if t219 goto 52 else 34
51:                                                             if.else P:1 S:2
	t220 = &t166.recvq [#8]                                          *waitq
	t221 = (*waitq).dequeue(t220)                                    *sudog
	t222 = t221 != nil:*sudog                                          bool
	if t222 goto 53 else 34
52:                                                             if.then P:1 S:2
	if false:untyped bool goto 107 else 108
53:                                                             if.then P:1 S:2
	if false:untyped bool goto 132 else 133
54:                                                             if.then P:1 S:1
	t223 = selunlock(sel)                                                ()
	jump 56
55:                                                             if.done P:1 S:1
	t224 = getg()                                                        *g
	*t120 = 0:uint32
	jump 59
56:                                                               retc P:10 S:2
	t225 = phi [54: t173, 88: t305, 106: t164, 114: t164, 126: t164, 130: t164, 139: t164, 104: t164, 112: t164, 131: t164] #cas *scase
	t226 = &t225.releasetime [#6]                                    *int64
	t227 = *t226                                                      int64
	t228 = t227 > 0:int64                                              bool
	if t228 goto 140 else 141
57:                                                            for.body P:1 S:2
	t229 = &t35[t262]                                               *uint16
	t230 = *t229                                                     uint16
	t231 = convert int <- uint16 (t230)                                 int
	t232 = &t15[t231]                                                *scase
	t233 = &t232._chan [#1]                                         **hchan
	t234 = *t233                                                     *hchan
	t235 = acquireSudog()                                            *sudog
	t236 = &t235.g [#0]                                                 **g
	*t236 = t224
	t237 = &t235.selectdone [#1]                                   **uint32
	t238 = convert unsafe.Pointer <- *uint32 (t120)          unsafe.Pointer
	t239 = noescape(t238)                                    unsafe.Pointer
	t240 = convert *uint32 <- unsafe.Pointer (t239)                 *uint32
	*t237 = t240
	t241 = &t235.elem [#4]                                  *unsafe.Pointer
	t242 = &t232.elem [#0]                                  *unsafe.Pointer
	t243 = *t242                                             unsafe.Pointer
	*t241 = t243
	t244 = &t235.releasetime [#5]                                    *int64
	*t244 = 0:int64
	t245 = t19 != 0:int64                                              bool
	if t245 goto 60 else 61
58:                                                            for.done P:1 S:1
	t246 = &t224.param [#8]                                 *unsafe.Pointer
	*t246 = nil:unsafe.Pointer
	t247 = make interface{} <- func(gp *g, sel *_select) bool (selparkcommit) interface{}
	t248 = funcPC(t247)                                             uintptr
	t249 = convert unsafe.Pointer <- uintptr (t248)          unsafe.Pointer
	t250 = convert unsafe.Pointer <- *_select (sel)          unsafe.Pointer
	t251 = gopark(t249, t250, "select":string)                           ()
	t252 = sellock(sel)                                                  ()
	t253 = &t224.param [#8]                                 *unsafe.Pointer
	t254 = *t253                                             unsafe.Pointer
	t255 = convert *sudog <- unsafe.Pointer (t254)                   *sudog
	t256 = &t224.param [#8]                                 *unsafe.Pointer
	*t256 = nil:unsafe.Pointer
	t257 = &t224.waiting [#30]                                      **sudog
	t258 = *t257                                                     *sudog
	t259 = &t224.waiting [#30]                                      **sudog
	t260 = *t259                                                     *sudog
	jump 68
59:                                                            for.loop P:2 S:2
	t261 = phi [55: t172, 62: t234] #c                               *hchan
	t262 = phi [55: 0:int, 62: t276] #i                                 int
	t263 = phi [55: t158, 62: t235] #sg                              *sudog
	t264 = &sel.ncase [#1]                                          *uint16
	t265 = *t264                                                     uint16
	t266 = convert int <- uint16 (t265)                                 int
	t267 = t262 < t266                                                 bool
	if t267 goto 57 else 58
60:                                                             if.then P:1 S:1
	t268 = &t235.releasetime [#5]                                    *int64
	*t268 = -1:int64
	jump 61
61:                                                             if.done P:2 S:2
	t269 = &t235.waitlink [#7]                                      **sudog
	t270 = &t224.waiting [#30]                                      **sudog
	t271 = *t270                                                     *sudog
	*t269 = t271
	t272 = &t224.waiting [#30]                                      **sudog
	*t272 = t235
	t273 = &t232.kind [#3]                                          *uint16
	t274 = *t273                                                     uint16
	t275 = t274 == 1:uint16                                            bool
	if t275 goto 63 else 65
62:                                                         switch.done P:3 S:1
	t276 = t262 + 1:int                                                 int
	jump 59
63:                                                         switch.body P:1 S:1
	t277 = &t234.recvq [#8]                                          *waitq
	t278 = (*waitq).enqueue(t277, t235)                                  ()
	jump 62
64:                                                         switch.body P:1 S:1
	t279 = &t234.sendq [#9]                                          *waitq
	t280 = (*waitq).enqueue(t279, t235)                                  ()
	jump 62
65:                                                         switch.next P:1 S:2
	t281 = t274 == 2:uint16                                            bool
	if t281 goto 64 else 62
66:                                                            for.body P:1 S:1
	t282 = &t291.selectdone [#1]                                   **uint32
	*t282 = nil:*uint32
	t283 = &t291.elem [#4]                                  *unsafe.Pointer
	*t283 = nil:unsafe.Pointer
	t284 = &t291.waitlink [#7]                                      **sudog
	t285 = *t284                                                     *sudog
	jump 68
67:                                                            for.done P:1 S:1
	t286 = &t224.waiting [#30]                                      **sudog
	*t286 = nil:*sudog
	t287 = &sel.ncase [#1]                                          *uint16
	t288 = *t287                                                     uint16
	t289 = convert int <- uint16 (t288)                                 int
	t290 = t289 - 1:int                                                 int
	jump 71
68:                                                            for.loop P:2 S:2
	t291 = phi [58: t260, 66: t285] #sg1                             *sudog
	t292 = t291 != nil:*sudog                                          bool
	if t292 goto 66 else 67
69:                                                            for.body P:1 S:2
	t293 = &t35[t306]                                               *uint16
	t294 = *t293                                                     uint16
	t295 = convert int <- uint16 (t294)                                 int
	t296 = &t15[t295]                                                *scase
	t297 = &t303.releasetime [#5]                                    *int64
	t298 = *t297                                                      int64
	t299 = t298 > 0:int64                                              bool
	if t299 goto 72 else 73
70:                                                            for.done P:1 S:2
	t300 = t305 == nil:*scase                                          bool
	if t300 goto 30 else 79
71:                                                            for.loop P:2 S:2
	t301 = phi [67: t261, 75: t312] #c                               *hchan
	t302 = phi [67: t154, 75: t296] #k                               *scase
	t303 = phi [67: t258, 75: t315] #sglist                          *sudog
	t304 = phi [67: t156, 75: t315] #sgnext                          *sudog
	t305 = phi [67: nil:*scase, 75: t313] #cas                       *scase
	t306 = phi [67: t290, 75: t318] #i                                  int
	t307 = t306 >= 0:int                                               bool
	if t307 goto 69 else 70
72:                                                             if.then P:1 S:1
	t308 = &t296.releasetime [#6]                                    *int64
	t309 = &t303.releasetime [#5]                                    *int64
	t310 = *t309                                                      int64
	*t308 = t310
	jump 73
73:                                                             if.done P:2 S:2
	t311 = t255 == t303                                                bool
	if t311 goto 74 else 76
74:                                                             if.then P:1 S:1
	jump 75
75:                                                             if.done P:3 S:1
	t312 = phi [74: t301, 77: t320, 78: t320] #c                     *hchan
	t313 = phi [74: t296, 77: t305, 78: t305] #cas                   *scase
	t314 = &t303.waitlink [#7]                                      **sudog
	t315 = *t314                                                     *sudog
	t316 = &t303.waitlink [#7]                                      **sudog
	*t316 = nil:*sudog
	t317 = releaseSudog(t303)                                            ()
	t318 = t306 - 1:int                                                 int
	jump 71
76:                                                             if.else P:1 S:2
	t319 = &t296._chan [#1]                                         **hchan
	t320 = *t319                                                     *hchan
	t321 = &t296.kind [#3]                                          *uint16
	t322 = *t321                                                     uint16
	t323 = t322 == 2:uint16                                            bool
	if t323 goto 77 else 78
77:                                                             if.then P:1 S:1
	t324 = &t320.sendq [#9]                                          *waitq
	t325 = (*waitq).dequeueSudoG(t324, t303)                             ()
	jump 75
78:                                                             if.else P:1 S:1
	t326 = &t320.recvq [#8]                                          *waitq
	t327 = (*waitq).dequeueSudoG(t326, t303)                             ()
	jump 75
79:                                                             if.done P:1 S:2
	t328 = &t305._chan [#1]                                         **hchan
	t329 = *t328                                                     *hchan
	t330 = &t329.dataqsiz [#1]                                        *uint
	t331 = *t330                                                       uint
	t332 = t331 > 0:uint                                               bool
	if t332 goto 80 else 81
80:                                                             if.then P:1 S:1
	t333 = gothrow("selectgo: shouldn...":string)                        ()
	jump 81
81:                                                             if.done P:2 S:2
	if false:untyped bool goto 82 else 83
82:                                                             if.then P:1 S:1
	t334 = &t305.kind [#3]                                          *uint16
	t335 = *t334                                                     uint16
	t336 = print("wait-return: sel=":string, sel, " c=":string, t329, " cas=":string, t305, " kind=":string, t335, "\n":string) ()
	jump 83
83:                                                             if.done P:2 S:2
	t337 = &t305.kind [#3]                                          *uint16
	t338 = *t337                                                     uint16
	t339 = t338 == 1:uint16                                            bool
	if t339 goto 84 else 85
84:                                                             if.then P:1 S:2
	t340 = &t305.receivedp [#5]                                      **bool
	t341 = *t340                                                      *bool
	t342 = t341 != nil:*bool                                           bool
	if t342 goto 86 else 85
85:                                                             if.done P:3 S:2
	if false:untyped bool goto 87 else 88
86:                                                             if.then P:1 S:1
	t343 = &t305.receivedp [#5]                                      **bool
	t344 = *t343                                                      *bool
	*t344 = true:bool
	jump 85
87:                                                             if.then P:1 S:2
	t345 = &t305.kind [#3]                                          *uint16
	t346 = *t345                                                     uint16
	t347 = t346 == 1:uint16                                            bool
	if t347 goto 91 else 90
88:                                                             if.done P:4 S:1
	t348 = selunlock(sel)                                                ()
	jump 56
89:                                                             if.then P:1 S:1
	t349 = &t329.elemtype [#5]                                      **_type
	t350 = *t349                                                     *_type
	t351 = &t305.elem [#0]                                  *unsafe.Pointer
	t352 = *t351                                             unsafe.Pointer
	t353 = &t305.pc [#2]                                           *uintptr
	t354 = *t353                                                    uintptr
	t355 = *chanrecvpc                                              uintptr
	t356 = raceWriteObjectPC(t350, t352, t354, t355)                     ()
	jump 88
90:                                                             if.else P:2 S:2
	t357 = &t305.kind [#3]                                          *uint16
	t358 = *t357                                                     uint16
	t359 = t358 == 2:uint16                                            bool
	if t359 goto 92 else 88
91:                                                           cond.true P:1 S:2
	t360 = &t305.elem [#0]                                  *unsafe.Pointer
	t361 = *t360                                             unsafe.Pointer
	t362 = t361 != nil:unsafe.Pointer                                  bool
	if t362 goto 89 else 90
92:                                                             if.then P:1 S:1
	t363 = &t329.elemtype [#5]                                      **_type
	t364 = *t363                                                     *_type
	t365 = &t305.elem [#0]                                  *unsafe.Pointer
	t366 = *t365                                             unsafe.Pointer
	t367 = &t305.pc [#2]                                           *uintptr
	t368 = *t367                                                    uintptr
	t369 = *chansendpc                                              uintptr
	t370 = raceReadObjectPC(t364, t366, t368, t369)                      ()
	jump 88
93:                                                             if.then P:1 S:2
	t371 = &t164.elem [#0]                                  *unsafe.Pointer
	t372 = *t371                                             unsafe.Pointer
	t373 = t372 != nil:unsafe.Pointer                                  bool
	if t373 goto 95 else 96
94:                                                             if.done P:2 S:2
	t374 = &t164.receivedp [#5]                                      **bool
	t375 = *t374                                                      *bool
	t376 = t375 != nil:*bool                                           bool
	if t376 goto 97 else 98
95:                                                             if.then P:1 S:1
	t377 = &t166.elemtype [#5]                                      **_type
	t378 = *t377                                                     *_type
	t379 = &t164.elem [#0]                                  *unsafe.Pointer
	t380 = *t379                                             unsafe.Pointer
	t381 = &t164.pc [#2]                                           *uintptr
	t382 = *t381                                                    uintptr
	t383 = *chanrecvpc                                              uintptr
	t384 = raceWriteObjectPC(t378, t380, t382, t383)                     ()
	jump 96
96:                                                             if.done P:2 S:1
	t385 = &t166.recvx [#7]                                           *uint
	t386 = *t385                                                       uint
	t387 = chanbuf(t166, t386)                               unsafe.Pointer
	t388 = raceacquire(t387)                                             ()
	t389 = &t166.recvx [#7]                                           *uint
	t390 = *t389                                                       uint
	t391 = chanbuf(t166, t390)                               unsafe.Pointer
	t392 = racerelease(t391)                                             ()
	jump 94
97:                                                             if.then P:1 S:1
	t393 = &t164.receivedp [#5]                                      **bool
	t394 = *t393                                                      *bool
	*t394 = true:bool
	jump 98
98:                                                             if.done P:2 S:2
	t395 = &t164.elem [#0]                                  *unsafe.Pointer
	t396 = *t395                                             unsafe.Pointer
	t397 = t396 != nil:unsafe.Pointer                                  bool
	if t397 goto 99 else 100
99:                                                             if.then P:1 S:1
	t398 = &t164.elem [#0]                                  *unsafe.Pointer
	t399 = *t398                                             unsafe.Pointer
	t400 = &t166.recvx [#7]                                           *uint
	t401 = *t400                                                       uint
	t402 = chanbuf(t166, t401)                               unsafe.Pointer
	t403 = &t166.elemsize [#3]                                      *uint16
	t404 = *t403                                                     uint16
	t405 = convert uintptr <- uint16 (t404)                         uintptr
	t406 = memmove(t399, t402, t405)                                     ()
	jump 100
100:                                                            if.done P:2 S:2
	t407 = &t166.recvx [#7]                                           *uint
	t408 = *t407                                                       uint
	t409 = chanbuf(t166, t408)                               unsafe.Pointer
	t410 = &t166.elemsize [#3]                                      *uint16
	t411 = *t410                                                     uint16
	t412 = convert uintptr <- uint16 (t411)                         uintptr
	t413 = memclr(t409, t412)                                            ()
	t414 = &t166.recvx [#7]                                           *uint
	t415 = *t414                                                       uint
	t416 = t415 + 1:uint                                               uint
	*t414 = t416
	t417 = &t166.recvx [#7]                                           *uint
	t418 = *t417                                                       uint
	t419 = &t166.dataqsiz [#1]                                        *uint
	t420 = *t419                                                       uint
	t421 = t418 == t420                                                bool
	if t421 goto 101 else 102
101:                                                            if.then P:1 S:1
	t422 = &t166.recvx [#7]                                           *uint
	*t422 = 0:uint
	jump 102
102:                                                            if.done P:2 S:2
	t423 = &t166.qcount [#0]                                          *uint
	t424 = *t423                                                       uint
	t425 = t424 - 1:uint                                               uint
	*t423 = t425
	t426 = &t166.sendq [#9]                                          *waitq
	t427 = (*waitq).dequeue(t426)                                    *sudog
	t428 = t427 != nil:*sudog                                          bool
	if t428 goto 103 else 104
103:                                                            if.then P:1 S:2
	t429 = &t427.g [#0]                                                 **g
	t430 = *t429                                                         *g
	t431 = selunlock(sel)                                                ()
	t432 = &t427.releasetime [#5]                                    *int64
	t433 = *t432                                                      int64
	t434 = t433 != 0:int64                                             bool
	if t434 goto 105 else 106
104:                                                            if.else P:1 S:1
	t435 = selunlock(sel)                                                ()
	jump 56
105:                                                            if.then P:1 S:1
	t436 = &t427.releasetime [#5]                                    *int64
	t437 = cputicks()                                                 int64
	*t436 = t437
	jump 106
106:                                                            if.done P:2 S:1
	t438 = goready(t430)                                                 ()
	jump 56
107:                                                            if.then P:1 S:1
	t439 = &t166.sendx [#6]                                           *uint
	t440 = *t439                                                       uint
	t441 = chanbuf(t166, t440)                               unsafe.Pointer
	t442 = raceacquire(t441)                                             ()
	t443 = &t166.sendx [#6]                                           *uint
	t444 = *t443                                                       uint
	t445 = chanbuf(t166, t444)                               unsafe.Pointer
	t446 = racerelease(t445)                                             ()
	t447 = &t166.elemtype [#5]                                      **_type
	t448 = *t447                                                     *_type
	t449 = &t164.elem [#0]                                  *unsafe.Pointer
	t450 = *t449                                             unsafe.Pointer
	t451 = &t164.pc [#2]                                           *uintptr
	t452 = *t451                                                    uintptr
	t453 = *chansendpc                                              uintptr
	t454 = raceReadObjectPC(t448, t450, t452, t453)                      ()
	jump 108
108:                                                            if.done P:2 S:2
	t455 = &t166.sendx [#6]                                           *uint
	t456 = *t455                                                       uint
	t457 = chanbuf(t166, t456)                               unsafe.Pointer
	t458 = &t164.elem [#0]                                  *unsafe.Pointer
	t459 = *t458                                             unsafe.Pointer
	t460 = &t166.elemsize [#3]                                      *uint16
	t461 = *t460                                                     uint16
	t462 = convert uintptr <- uint16 (t461)                         uintptr
	t463 = memmove(t457, t459, t462)                                     ()
	t464 = &t166.sendx [#6]                                           *uint
	t465 = *t464                                                       uint
	t466 = t465 + 1:uint                                               uint
	*t464 = t466
	t467 = &t166.sendx [#6]                                           *uint
	t468 = *t467                                                       uint
	t469 = &t166.dataqsiz [#1]                                        *uint
	t470 = *t469                                                       uint
	t471 = t468 == t470                                                bool
	if t471 goto 109 else 110
109:                                                            if.then P:1 S:1
	t472 = &t166.sendx [#6]                                           *uint
	*t472 = 0:uint
	jump 110
110:                                                            if.done P:2 S:2
	t473 = &t166.qcount [#0]                                          *uint
	t474 = *t473                                                       uint
	t475 = t474 + 1:uint                                               uint
	*t473 = t475
	t476 = &t166.recvq [#8]                                          *waitq
	t477 = (*waitq).dequeue(t476)                                    *sudog
	t478 = t477 != nil:*sudog                                          bool
	if t478 goto 111 else 112
111:                                                            if.then P:1 S:2
	t479 = &t477.g [#0]                                                 **g
	t480 = *t479                                                         *g
	t481 = selunlock(sel)                                                ()
	t482 = &t477.releasetime [#5]                                    *int64
	t483 = *t482                                                      int64
	t484 = t483 != 0:int64                                             bool
	if t484 goto 113 else 114
112:                                                            if.else P:1 S:1
	t485 = selunlock(sel)                                                ()
	jump 56
113:                                                            if.then P:1 S:1
	t486 = &t477.releasetime [#5]                                    *int64
	t487 = cputicks()                                                 int64
	*t486 = t487
	jump 114
114:                                                            if.done P:2 S:1
	t488 = goready(t480)                                                 ()
	jump 56
115:                                                            if.then P:1 S:2
	t489 = &t164.elem [#0]                                  *unsafe.Pointer
	t490 = *t489                                             unsafe.Pointer
	t491 = t490 != nil:unsafe.Pointer                                  bool
	if t491 goto 117 else 118
116:                                                            if.done P:2 S:2
	t492 = selunlock(sel)                                                ()
	if false:untyped bool goto 119 else 120
117:                                                            if.then P:1 S:1
	t493 = &t166.elemtype [#5]                                      **_type
	t494 = *t493                                                     *_type
	t495 = &t164.elem [#0]                                  *unsafe.Pointer
	t496 = *t495                                             unsafe.Pointer
	t497 = &t164.pc [#2]                                           *uintptr
	t498 = *t497                                                    uintptr
	t499 = *chanrecvpc                                              uintptr
	t500 = raceWriteObjectPC(t494, t496, t498, t499)                     ()
	jump 118
118:                                                            if.done P:2 S:1
	t501 = racesync(t166, t195)                                          ()
	jump 116
119:                                                            if.then P:1 S:1
	t502 = print("syncrecv: sel=":string, sel, " c=":string, t166, "\n":string) ()
	jump 120
120:                                                            if.done P:2 S:2
	t503 = &t164.receivedp [#5]                                      **bool
	t504 = *t503                                                      *bool
	t505 = t504 != nil:*bool                                           bool
	if t505 goto 121 else 122
121:                                                            if.then P:1 S:1
	t506 = &t164.receivedp [#5]                                      **bool
	t507 = *t506                                                      *bool
	*t507 = true:bool
	jump 122
122:                                                            if.done P:2 S:2
	t508 = &t164.elem [#0]                                  *unsafe.Pointer
	t509 = *t508                                             unsafe.Pointer
	t510 = t509 != nil:unsafe.Pointer                                  bool
	if t510 goto 123 else 124
123:                                                            if.then P:1 S:1
	t511 = &t164.elem [#0]                                  *unsafe.Pointer
	t512 = *t511                                             unsafe.Pointer
	t513 = &t195.elem [#4]                                  *unsafe.Pointer
	t514 = *t513                                             unsafe.Pointer
	t515 = &t166.elemsize [#3]                                      *uint16
	t516 = *t515                                                     uint16
	t517 = convert uintptr <- uint16 (t516)                         uintptr
	t518 = memmove(t512, t514, t517)                                     ()
	jump 124
124:                                                            if.done P:2 S:2
	t519 = &t195.elem [#4]                                  *unsafe.Pointer
	*t519 = nil:unsafe.Pointer
	t520 = &t195.g [#0]                                                 **g
	t521 = *t520                                                         *g
	t522 = &t521.param [#8]                                 *unsafe.Pointer
	t523 = convert unsafe.Pointer <- *sudog (t195)           unsafe.Pointer
	*t522 = t523
	t524 = &t195.releasetime [#5]                                    *int64
	t525 = *t524                                                      int64
	t526 = t525 != 0:int64                                             bool
	if t526 goto 125 else 126
125:                                                            if.then P:1 S:1
	t527 = &t195.releasetime [#5]                                    *int64
	t528 = cputicks()                                                 int64
	*t527 = t528
	jump 126
126:                                                            if.done P:2 S:1
	t529 = goready(t521)                                                 ()
	jump 56
127:                                                            if.then P:1 S:1
	t530 = &t164.receivedp [#5]                                      **bool
	t531 = *t530                                                      *bool
	*t531 = false:bool
	jump 128
128:                                                            if.done P:2 S:2
	t532 = &t164.elem [#0]                                  *unsafe.Pointer
	t533 = *t532                                             unsafe.Pointer
	t534 = t533 != nil:unsafe.Pointer                                  bool
	if t534 goto 129 else 130
129:                                                            if.then P:1 S:1
	t535 = &t164.elem [#0]                                  *unsafe.Pointer
	t536 = *t535                                             unsafe.Pointer
	t537 = &t166.elemsize [#3]                                      *uint16
	t538 = *t537                                                     uint16
	t539 = convert uintptr <- uint16 (t538)                         uintptr
	t540 = memclr(t536, t539)                                            ()
	jump 130
130:                                                            if.done P:2 S:2
	if false:untyped bool goto 131 else 56
131:                                                            if.then P:1 S:1
	t541 = convert unsafe.Pointer <- *hchan (t166)           unsafe.Pointer
	t542 = raceacquire(t541)                                             ()
	jump 56
132:                                                            if.then P:1 S:1
	t543 = &t166.elemtype [#5]                                      **_type
	t544 = *t543                                                     *_type
	t545 = &t164.elem [#0]                                  *unsafe.Pointer
	t546 = *t545                                             unsafe.Pointer
	t547 = &t164.pc [#2]                                           *uintptr
	t548 = *t547                                                    uintptr
	t549 = *chansendpc                                              uintptr
	t550 = raceReadObjectPC(t544, t546, t548, t549)                      ()
	t551 = racesync(t166, t221)                                          ()
	jump 133
133:                                                            if.done P:2 S:2
	t552 = selunlock(sel)                                                ()
	if false:untyped bool goto 134 else 135
134:                                                            if.then P:1 S:1
	t553 = print("syncsend: sel=":string, sel, " c=":string, t166, "\n":string) ()
	jump 135
135:                                                            if.done P:2 S:2
	t554 = &t221.elem [#4]                                  *unsafe.Pointer
	t555 = *t554                                             unsafe.Pointer
	t556 = t555 != nil:unsafe.Pointer                                  bool
	if t556 goto 136 else 137
136:                                                            if.then P:1 S:1
	t557 = &t221.elem [#4]                                  *unsafe.Pointer
	t558 = *t557                                             unsafe.Pointer
	t559 = &t164.elem [#0]                                  *unsafe.Pointer
	t560 = *t559                                             unsafe.Pointer
	t561 = &t166.elemsize [#3]                                      *uint16
	t562 = *t561                                                     uint16
	t563 = convert uintptr <- uint16 (t562)                         uintptr
	t564 = memmove(t558, t560, t563)                                     ()
	jump 137
137:                                                            if.done P:2 S:2
	t565 = &t221.elem [#4]                                  *unsafe.Pointer
	*t565 = nil:unsafe.Pointer
	t566 = &t221.g [#0]                                                 **g
	t567 = *t566                                                         *g
	t568 = &t567.param [#8]                                 *unsafe.Pointer
	t569 = convert unsafe.Pointer <- *sudog (t221)           unsafe.Pointer
	*t568 = t569
	t570 = &t221.releasetime [#5]                                    *int64
	t571 = *t570                                                      int64
	t572 = t571 != 0:int64                                             bool
	if t572 goto 138 else 139
138:                                                            if.then P:1 S:1
	t573 = &t221.releasetime [#5]                                    *int64
	t574 = cputicks()                                                 int64
	*t573 = t574
	jump 139
139:                                                            if.done P:2 S:1
	t575 = goready(t567)                                                 ()
	jump 56
140:                                                            if.then P:1 S:1
	t576 = &t225.releasetime [#6]                                    *int64
	t577 = *t576                                                      int64
	t578 = t577 - t19                                                 int64
	t579 = blockevent(t578, 2:int)                                       ()
	jump 141
141:                                                            if.done P:2 S:0
	t580 = &t225.pc [#2]                                           *uintptr
	t581 = *t580                                                    uintptr
	t582 = &t225.so [#4]                                            *uint16
	t583 = *t582                                                     uint16
	return t581, t583

# Name: (*runtime.hchan).sortkey
# Package: runtime
# Location: /usr/local/go/src/runtime/select.go:577:17
func (c *hchan) sortkey() uintptr:
0:                                                                entry P:0 S:0
	t0 = convert unsafe.Pointer <- *hchan (c)                unsafe.Pointer
	t1 = convert uintptr <- unsafe.Pointer (t0)                     uintptr
	return t1

# Name: runtime.reflect_rselect
# Package: runtime
# Location: /usr/local/go/src/runtime/select.go:602:6
func reflect_rselect(cases []runtimeSelect) (chosen int, recvOK bool):
0:                                                                entry P:0 S:1
	t0 = len(cases)                                                     int
	t1 = convert uintptr <- int (t0)                                uintptr
	t2 = selectsize(t1)                                             uintptr
	t3 = mallocgc(t2, nil:*_type, 1:uint32)                  unsafe.Pointer
	t4 = convert *_select <- unsafe.Pointer (t3)                   *_select
	t5 = convert int64 <- uintptr (t2)                                int64
	t6 = len(cases)                                                     int
	t7 = convert int32 <- int (t6)                                    int32
	t8 = newselect(t4, t5, t7)                                           ()
	t9 = new bool (new)                                               *bool
	t10 = len(cases)                                                    int
	jump 1
1:                                                      rangeindex.loop P:7 S:2
	t11 = phi [0: -1:int, 4: t12, 5: t12, 9: t12, 7: t12, 10: t12, 8: t12] int
	t12 = t11 + 1:int                                                   int
	t13 = t12 < t10                                                    bool
	if t13 goto 2 else 3
2:                                                      rangeindex.body P:1 S:2
	t14 = &cases[t12]                                        *runtimeSelect
	t15 = &t14.dir [#0]                                          *selectDir
	t16 = *t15                                                    selectDir
	t17 = t16 == 3:selectDir                                           bool
	if t17 goto 4 else 6
3:                                                      rangeindex.done P:1 S:0
	t18 = selectgoImpl(t4)                                (uintptr, uint16)
	t19 = extract t18 #0                                            uintptr
	t20 = extract t18 #1                                             uint16
	t21 = convert int <- uintptr (t19)                                  int
	t22 = *t9                                                          bool
	return t21, t22
4:                                                          switch.body P:1 S:1
	t23 = convert uintptr <- int (t12)                              uintptr
	t24 = selectdefaultImpl(t4, t23, 0:uintptr)                          ()
	jump 1
5:                                                          switch.body P:1 S:2
	t25 = &t14.ch [#2]                                              **hchan
	t26 = *t25                                                       *hchan
	t27 = t26 == nil:*hchan                                            bool
	if t27 goto 1 else 9
6:                                                          switch.next P:1 S:2
	t28 = t16 == 1:selectDir                                           bool
	if t28 goto 5 else 8
7:                                                          switch.body P:1 S:2
	t29 = &t14.ch [#2]                                              **hchan
	t30 = *t29                                                       *hchan
	t31 = t30 == nil:*hchan                                            bool
	if t31 goto 1 else 10
8:                                                          switch.next P:1 S:2
	t32 = t16 == 2:selectDir                                           bool
	if t32 goto 7 else 1
9:                                                              if.done P:1 S:1
	t33 = &t14.ch [#2]                                              **hchan
	t34 = *t33                                                       *hchan
	t35 = convert uintptr <- int (t12)                              uintptr
	t36 = &t14.val [#3]                                     *unsafe.Pointer
	t37 = *t36                                               unsafe.Pointer
	t38 = selectsendImpl(t4, t34, t35, t37, 0:uintptr)                   ()
	jump 1
10:                                                             if.done P:1 S:1
	t39 = &t14.ch [#2]                                              **hchan
	t40 = *t39                                                       *hchan
	t41 = convert uintptr <- int (t12)                              uintptr
	t42 = &t14.val [#3]                                     *unsafe.Pointer
	t43 = *t42                                               unsafe.Pointer
	t44 = selectrecvImpl(t4, t40, t41, t43, t9, 0:uintptr)               ()
	jump 1

# Name: (*runtime.waitq).dequeueSudoG
# Package: runtime
# Location: /usr/local/go/src/runtime/select.go:632:17
func (q *waitq) dequeueSudoG(s *sudog):
0:                                                                entry P:0 S:1
	t0 = &q.first [#0]                                              **sudog
	jump 1
1:                                                             for.body P:2 S:2
	t1 = phi [0: nil:*sudog, 5: t3] #prevsgp                         *sudog
	t2 = phi [0: t0, 5: t11] #l                                     **sudog
	t3 = *t2                                                         *sudog
	t4 = t3 == nil:*sudog                                              bool
	if t4 goto 2 else 3
2:                                                              if.then P:1 S:0
	return
3:                                                              if.done P:1 S:2
	t5 = t3 == s                                                       bool
	if t5 goto 4 else 5
4:                                                              if.then P:1 S:2
	t6 = &t3.next [#2]                                              **sudog
	t7 = *t6                                                         *sudog
	*t2 = t7
	t8 = &q.last [#1]                                               **sudog
	t9 = *t8                                                         *sudog
	t10 = t9 == t3                                                     bool
	if t10 goto 6 else 7
5:                                                              if.done P:1 S:1
	t11 = &t3.next [#2]                                             **sudog
	jump 1
6:                                                              if.then P:1 S:1
	t12 = &q.last [#1]                                              **sudog
	*t12 = t1
	jump 7
7:                                                              if.done P:2 S:0
	t13 = &s.next [#2]                                              **sudog
	*t13 = nil:*sudog
	return

# Name: runtime.asyncsemacquire
# Package: runtime
# Location: /usr/local/go/src/runtime/sema.go:42:6
func asyncsemacquire(addr *uint32):
0:                                                                entry P:0 S:0
	t0 = semacquire(addr, true:bool)                                     ()
	return

# Name: runtime.asyncsemrelease
# Package: runtime
# Location: /usr/local/go/src/runtime/sema.go:46:6
func asyncsemrelease(addr *uint32):
0:                                                                entry P:0 S:0
	t0 = semrelease(addr)                                                ()
	return

# Name: runtime.semacquire
# Package: runtime
# Location: /usr/local/go/src/runtime/sema.go:51:6
func semacquire(addr *uint32, profile bool):
0:                                                                entry P:0 S:2
	t0 = getg()                                                          *g
	t1 = &t0.m [#21]                                                    **m
	t2 = *t1                                                             *m
	t3 = &t2.curg [#6]                                                  **g
	t4 = *t3                                                             *g
	t5 = t0 != t4                                                      bool
	if t5 goto 1 else 2
1:                                                              if.then P:1 S:1
	t6 = gothrow("semacquire not on...":string)                          ()
	jump 2
2:                                                              if.done P:2 S:2
	t7 = cansemacquire(addr)                                           bool
	if t7 goto 3 else 4
3:                                                              if.then P:1 S:0
	return
4:                                                              if.done P:1 S:2
	t8 = acquireSudog()                                              *sudog
	t9 = semroot(addr)                                            *semaRoot
	t10 = &t8.releasetime [#5]                                       *int64
	*t10 = 0:int64
	if profile goto 6 else 7
5:                                                              if.then P:1 S:1
	t11 = cputicks()                                                  int64
	t12 = &t8.releasetime [#5]                                       *int64
	*t12 = -1:int64
	jump 7
6:                                                            cond.true P:1 S:2
	t13 = *blockprofilerate                                          uint64
	t14 = t13 > 0:uint64                                               bool
	if t14 goto 5 else 7
7:                                                             for.body P:4 S:2
	t15 = phi [4: 0:int64, 10: t15, 6: 0:int64, 5: t11] #t0           int64
	t16 = &t9.lock [#0]                                              *mutex
	t17 = lock(t16)                                                      ()
	t18 = &t9.nwait [#3]                                            *uint32
	t19 = xadd(t18, 1:int32)                                         uint32
	t20 = cansemacquire(addr)                                          bool
	if t20 goto 9 else 10
8:                                                             for.done P:2 S:2
	t21 = &t8.releasetime [#5]                                       *int64
	t22 = *t21                                                        int64
	t23 = t22 > 0:int64                                                bool
	if t23 goto 11 else 12
9:                                                              if.then P:1 S:1
	t24 = &t9.nwait [#3]                                            *uint32
	t25 = xadd(t24, -1:int32)                                        uint32
	t26 = &t9.lock [#0]                                              *mutex
	t27 = unlock(t26)                                                    ()
	jump 8
10:                                                             if.done P:1 S:2
	t28 = (*semaRoot).queue(t9, addr, t8)                                ()
	t29 = &t9.lock [#0]                                              *mutex
	t30 = goparkunlock(t29, "semacquire":string)                         ()
	t31 = cansemacquire(addr)                                          bool
	if t31 goto 8 else 7
11:                                                             if.then P:1 S:1
	t32 = &t8.releasetime [#5]                                       *int64
	t33 = *t32                                                        int64
	t34 = t33 - t15                                                   int64
	t35 = blockevent(t34, 3:int)                                         ()
	jump 12
12:                                                             if.done P:2 S:0
	t36 = releaseSudog(t8)                                               ()
	return

# Name: runtime.semrelease
# Package: runtime
# Location: /usr/local/go/src/runtime/sema.go:100:6
func semrelease(addr *uint32):
0:                                                                entry P:0 S:2
	t0 = semroot(addr)                                            *semaRoot
	t1 = xadd(addr, 1:int32)                                         uint32
	t2 = &t0.nwait [#3]                                             *uint32
	t3 = atomicload(t2)                                              uint32
	t4 = t3 == 0:uint32                                                bool
	if t4 goto 1 else 2
1:                                                              if.then P:1 S:0
	return
2:                                                              if.done P:1 S:2
	t5 = &t0.lock [#0]                                               *mutex
	t6 = lock(t5)                                                        ()
	t7 = &t0.nwait [#3]                                             *uint32
	t8 = atomicload(t7)                                              uint32
	t9 = t8 == 0:uint32                                                bool
	if t9 goto 3 else 4
3:                                                              if.then P:1 S:0
	t10 = &t0.lock [#0]                                              *mutex
	t11 = unlock(t10)                                                    ()
	return
4:                                                              if.done P:1 S:1
	t12 = &t0.head [#1]                                             **sudog
	t13 = *t12                                                       *sudog
	jump 7
5:                                                             for.body P:1 S:2
	t14 = &t21.elem [#4]                                    *unsafe.Pointer
	t15 = *t14                                               unsafe.Pointer
	t16 = convert unsafe.Pointer <- *uint32 (addr)           unsafe.Pointer
	t17 = t15 == t16                                                   bool
	if t17 goto 8 else 9
6:                                                             for.done P:2 S:2
	t18 = &t0.lock [#0]                                              *mutex
	t19 = unlock(t18)                                                    ()
	t20 = t21 != nil:*sudog                                            bool
	if t20 goto 10 else 11
7:                                                             for.loop P:2 S:2
	t21 = phi [4: t13, 9: t27] #s                                    *sudog
	t22 = t21 != nil:*sudog                                            bool
	if t22 goto 5 else 6
8:                                                              if.then P:1 S:1
	t23 = &t0.nwait [#3]                                            *uint32
	t24 = xadd(t23, -1:int32)                                        uint32
	t25 = (*semaRoot).dequeue(t0, t21)                                   ()
	jump 6
9:                                                              if.done P:1 S:1
	t26 = &t21.next [#2]                                            **sudog
	t27 = *t26                                                       *sudog
	jump 7
10:                                                             if.then P:1 S:2
	t28 = &t21.releasetime [#5]                                      *int64
	t29 = *t28                                                        int64
	t30 = t29 != 0:int64                                               bool
	if t30 goto 12 else 13
11:                                                             if.done P:2 S:0
	return
12:                                                             if.then P:1 S:1
	t31 = &t21.releasetime [#5]                                      *int64
	t32 = cputicks()                                                  int64
	*t31 = t32
	jump 13
13:                                                             if.done P:2 S:1
	t33 = &t21.g [#0]                                                   **g
	t34 = *t33                                                           *g
	t35 = goready(t34)                                                   ()
	jump 11

# Name: runtime.semroot
# Package: runtime
# Location: /usr/local/go/src/runtime/sema.go:136:6
func semroot(addr *uint32) *semaRoot:
0:                                                                entry P:0 S:0
	t0 = convert unsafe.Pointer <- *uint32 (addr)            unsafe.Pointer
	t1 = convert uintptr <- unsafe.Pointer (t0)                     uintptr
	t2 = t1 >> 3:uint64                                             uintptr
	t3 = t2 % 251:uintptr                                           uintptr
	t4 = convert int <- uintptr (t3)                                    int
	t5 = &semtable[t4]                 *struct{root semaRoot; pad [36]byte}
	t6 = &t5.root [#0]                                            *semaRoot
	return t6

# Name: runtime.cansemacquire
# Package: runtime
# Location: /usr/local/go/src/runtime/sema.go:140:6
func cansemacquire(addr *uint32) bool:
0:                                                                entry P:0 S:1
	jump 1
1:                                                             for.body P:2 S:2
	t0 = atomicload(addr)                                            uint32
	t1 = t0 == 0:uint32                                                bool
	if t1 goto 2 else 3
2:                                                              if.then P:1 S:0
	return false:bool
3:                                                              if.done P:1 S:2
	t2 = t0 - 1:uint32                                               uint32
	t3 = cas(addr, t0, t2)                                             bool
	if t3 goto 4 else 1
4:                                                              if.then P:1 S:0
	return true:bool

# Name: (*runtime.semaRoot).queue
# Package: runtime
# Location: /usr/local/go/src/runtime/sema.go:152:23
func (root *semaRoot) queue(addr *uint32, s *sudog):
0:                                                                entry P:0 S:2
	t0 = &s.g [#0]                                                      **g
	t1 = getg()                                                          *g
	*t0 = t1
	t2 = &s.elem [#4]                                       *unsafe.Pointer
	t3 = convert unsafe.Pointer <- *uint32 (addr)            unsafe.Pointer
	*t2 = t3
	t4 = &s.next [#2]                                               **sudog
	*t4 = nil:*sudog
	t5 = &s.prev [#3]                                               **sudog
	t6 = &root.tail [#2]                                            **sudog
	t7 = *t6                                                         *sudog
	*t5 = t7
	t8 = &root.tail [#2]                                            **sudog
	t9 = *t8                                                         *sudog
	t10 = t9 != nil:*sudog                                             bool
	if t10 goto 1 else 3
1:                                                              if.then P:1 S:1
	t11 = &root.tail [#2]                                           **sudog
	t12 = *t11                                                       *sudog
	t13 = &t12.next [#2]                                            **sudog
	*t13 = s
	jump 2
2:                                                              if.done P:2 S:0
	t14 = &root.tail [#2]                                           **sudog
	*t14 = s
	return
3:                                                              if.else P:1 S:1
	t15 = &root.head [#1]                                           **sudog
	*t15 = s
	jump 2

# Name: (*runtime.semaRoot).dequeue
# Package: runtime
# Location: /usr/local/go/src/runtime/sema.go:165:23
func (root *semaRoot) dequeue(s *sudog):
0:                                                                entry P:0 S:2
	t0 = &s.next [#2]                                               **sudog
	t1 = *t0                                                         *sudog
	t2 = t1 != nil:*sudog                                              bool
	if t2 goto 1 else 3
1:                                                              if.then P:1 S:1
	t3 = &s.next [#2]                                               **sudog
	t4 = *t3                                                         *sudog
	t5 = &t4.prev [#3]                                              **sudog
	t6 = &s.prev [#3]                                               **sudog
	t7 = *t6                                                         *sudog
	*t5 = t7
	jump 2
2:                                                              if.done P:2 S:2
	t8 = &s.prev [#3]                                               **sudog
	t9 = *t8                                                         *sudog
	t10 = t9 != nil:*sudog                                             bool
	if t10 goto 4 else 6
3:                                                              if.else P:1 S:1
	t11 = &root.tail [#2]                                           **sudog
	t12 = &s.prev [#3]                                              **sudog
	t13 = *t12                                                       *sudog
	*t11 = t13
	jump 2
4:                                                              if.then P:1 S:1
	t14 = &s.prev [#3]                                              **sudog
	t15 = *t14                                                       *sudog
	t16 = &t15.next [#2]                                            **sudog
	t17 = &s.next [#2]                                              **sudog
	t18 = *t17                                                       *sudog
	*t16 = t18
	jump 5
5:                                                              if.done P:2 S:0
	t19 = &s.elem [#4]                                      *unsafe.Pointer
	*t19 = nil:unsafe.Pointer
	t20 = &s.next [#2]                                              **sudog
	*t20 = nil:*sudog
	t21 = &s.prev [#3]                                              **sudog
	*t21 = nil:*sudog
	return
6:                                                              if.else P:1 S:1
	t22 = &root.head [#1]                                           **sudog
	t23 = &s.next [#2]                                              **sudog
	t24 = *t23                                                       *sudog
	*t22 = t24
	jump 5

# Name: runtime.syncsemacquire
# Package: runtime
# Location: /usr/local/go/src/runtime/sema.go:189:6
func syncsemacquire(s *syncSema):
0:                                                                entry P:0 S:2
	t0 = &s.lock [#0]                                                *mutex
	t1 = lock(t0)                                                        ()
	t2 = &s.head [#1]                                               **sudog
	t3 = *t2                                                         *sudog
	t4 = t3 != nil:*sudog                                              bool
	if t4 goto 4 else 3
1:                                                              if.then P:1 S:2
	t5 = &s.head [#1]                                               **sudog
	t6 = *t5                                                         *sudog
	t7 = &t6.nrelease [#6]                                           *int32
	t8 = *t7                                                          int32
	t9 = t8 - 1:int32                                                 int32
	*t7 = t9
	t10 = &s.head [#1]                                              **sudog
	t11 = *t10                                                       *sudog
	t12 = &t11.nrelease [#6]                                         *int32
	t13 = *t12                                                        int32
	t14 = t13 == 0:int32                                               bool
	if t14 goto 5 else 6
2:                                                              if.done P:3 S:0
	return
3:                                                              if.else P:2 S:2
	t15 = acquireSudog()                                             *sudog
	t16 = &t15.g [#0]                                                   **g
	t17 = getg()                                                         *g
	*t16 = t17
	t18 = &t15.nrelease [#6]                                         *int32
	*t18 = -1:int32
	t19 = &t15.next [#2]                                            **sudog
	*t19 = nil:*sudog
	t20 = &t15.releasetime [#5]                                      *int64
	*t20 = 0:int64
	t21 = *blockprofilerate                                          uint64
	t22 = t21 > 0:uint64                                               bool
	if t22 goto 9 else 10
4:                                                            cond.true P:1 S:2
	t23 = &s.head [#1]                                              **sudog
	t24 = *t23                                                       *sudog
	t25 = &t24.nrelease [#6]                                         *int32
	t26 = *t25                                                        int32
	t27 = t26 > 0:int32                                                bool
	if t27 goto 1 else 3
5:                                                              if.then P:1 S:2
	t28 = &s.head [#1]                                              **sudog
	t29 = *t28                                                       *sudog
	t30 = &s.head [#1]                                              **sudog
	t31 = &t29.next [#2]                                            **sudog
	t32 = *t31                                                       *sudog
	*t30 = t32
	t33 = &s.head [#1]                                              **sudog
	t34 = *t33                                                       *sudog
	t35 = t34 == nil:*sudog                                            bool
	if t35 goto 7 else 6
6:                                                              if.done P:3 S:2
	t36 = phi [1: nil:*sudog, 5: t29, 7: t29] #wake                  *sudog
	t37 = &s.lock [#0]                                               *mutex
	t38 = unlock(t37)                                                    ()
	t39 = t36 != nil:*sudog                                            bool
	if t39 goto 8 else 2
7:                                                              if.then P:1 S:1
	t40 = &s.tail [#2]                                              **sudog
	*t40 = nil:*sudog
	jump 6
8:                                                              if.then P:1 S:1
	t41 = &t36.next [#2]                                            **sudog
	*t41 = nil:*sudog
	t42 = &t36.g [#0]                                                   **g
	t43 = *t42                                                           *g
	t44 = goready(t43)                                                   ()
	jump 2
9:                                                              if.then P:1 S:1
	t45 = cputicks()                                                  int64
	t46 = &t15.releasetime [#5]                                      *int64
	*t46 = -1:int64
	jump 10
10:                                                             if.done P:2 S:2
	t47 = phi [3: 0:int64, 9: t45] #t0                                int64
	t48 = &s.tail [#2]                                              **sudog
	t49 = *t48                                                       *sudog
	t50 = t49 == nil:*sudog                                            bool
	if t50 goto 11 else 13
11:                                                             if.then P:1 S:1
	t51 = &s.head [#1]                                              **sudog
	*t51 = t15
	jump 12
12:                                                             if.done P:2 S:2
	t52 = &s.tail [#2]                                              **sudog
	*t52 = t15
	t53 = &s.lock [#0]                                               *mutex
	t54 = goparkunlock(t53, "semacquire":string)                         ()
	t55 = t47 != 0:int64                                               bool
	if t55 goto 14 else 15
13:                                                             if.else P:1 S:1
	t56 = &s.tail [#2]                                              **sudog
	t57 = *t56                                                       *sudog
	t58 = &t57.next [#2]                                            **sudog
	*t58 = t15
	jump 12
14:                                                             if.then P:1 S:1
	t59 = &t15.releasetime [#5]                                      *int64
	t60 = *t59                                                        int64
	t61 = t60 - t47                                                   int64
	t62 = blockevent(t61, 2:int)                                         ()
	jump 15
15:                                                             if.done P:2 S:1
	t63 = releaseSudog(t15)                                              ()
	jump 2

# Name: runtime.syncsemrelease
# Package: runtime
# Location: /usr/local/go/src/runtime/sema.go:234:6
func syncsemrelease(s *syncSema, n uint32):
0:                                                                entry P:0 S:1
	t0 = &s.lock [#0]                                                *mutex
	t1 = lock(t0)                                                        ()
	jump 3
1:                                                             for.body P:1 S:2
	t2 = &s.head [#1]                                               **sudog
	t3 = *t2                                                         *sudog
	t4 = &s.head [#1]                                               **sudog
	t5 = &t3.next [#2]                                              **sudog
	t6 = *t5                                                         *sudog
	*t4 = t6
	t7 = &s.head [#1]                                               **sudog
	t8 = *t7                                                         *sudog
	t9 = t8 == nil:*sudog                                              bool
	if t9 goto 6 else 7
2:                                                             for.done P:3 S:2
	t10 = t11 > 0:uint32                                               bool
	if t10 goto 10 else 12
3:                                                             for.loop P:2 S:2
	t11 = phi [0: n, 9: t31] #n                                      uint32
	t12 = t11 > 0:uint32                                               bool
	if t12 goto 5 else 2
4:                                                            cond.true P:1 S:2
	t13 = &s.head [#1]                                              **sudog
	t14 = *t13                                                       *sudog
	t15 = &t14.nrelease [#6]                                         *int32
	t16 = *t15                                                        int32
	t17 = t16 < 0:int32                                                bool
	if t17 goto 1 else 2
5:                                                            cond.true P:1 S:2
	t18 = &s.head [#1]                                              **sudog
	t19 = *t18                                                       *sudog
	t20 = t19 != nil:*sudog                                            bool
	if t20 goto 4 else 2
6:                                                              if.then P:1 S:1
	t21 = &s.tail [#2]                                              **sudog
	*t21 = nil:*sudog
	jump 7
7:                                                              if.done P:2 S:2
	t22 = &t3.releasetime [#5]                                       *int64
	t23 = *t22                                                        int64
	t24 = t23 != 0:int64                                               bool
	if t24 goto 8 else 9
8:                                                              if.then P:1 S:1
	t25 = &t3.releasetime [#5]                                       *int64
	t26 = cputicks()                                                  int64
	*t25 = t26
	jump 9
9:                                                              if.done P:2 S:1
	t27 = &t3.next [#2]                                             **sudog
	*t27 = nil:*sudog
	t28 = &t3.g [#0]                                                    **g
	t29 = *t28                                                           *g
	t30 = goready(t29)                                                   ()
	t31 = t11 - 1:uint32                                             uint32
	jump 3
10:                                                             if.then P:1 S:2
	t32 = acquireSudog()                                             *sudog
	t33 = &t32.g [#0]                                                   **g
	t34 = getg()                                                         *g
	*t33 = t34
	t35 = &t32.nrelease [#6]                                         *int32
	t36 = convert int32 <- uint32 (t11)                               int32
	*t35 = t36
	t37 = &t32.next [#2]                                            **sudog
	*t37 = nil:*sudog
	t38 = &t32.releasetime [#5]                                      *int64
	*t38 = 0:int64
	t39 = &s.tail [#2]                                              **sudog
	t40 = *t39                                                       *sudog
	t41 = t40 == nil:*sudog                                            bool
	if t41 goto 13 else 15
11:                                                             if.done P:2 S:0
	return
12:                                                             if.else P:1 S:1
	t42 = &s.lock [#0]                                               *mutex
	t43 = unlock(t42)                                                    ()
	jump 11
13:                                                             if.then P:1 S:1
	t44 = &s.head [#1]                                              **sudog
	*t44 = t32
	jump 14
14:                                                             if.done P:2 S:1
	t45 = &s.tail [#2]                                              **sudog
	*t45 = t32
	t46 = &s.lock [#0]                                               *mutex
	t47 = goparkunlock(t46, "semarelease":string)                        ()
	t48 = releaseSudog(t32)                                              ()
	jump 11
15:                                                             if.else P:1 S:1
	t49 = &s.tail [#2]                                              **sudog
	t50 = *t49                                                       *sudog
	t51 = &t50.next [#2]                                            **sudog
	*t51 = t32
	jump 14

# Name: runtime.syncsemcheck
# Package: runtime
# Location: /usr/local/go/src/runtime/sema.go:270:6
func syncsemcheck(sz uintptr):
0:                                                                entry P:0 S:2
	t0 = sz != 24:uintptr                                              bool
	if t0 goto 1 else 2
1:                                                              if.then P:1 S:1
	t1 = print("runtime: bad sync...":string, sz, " runtime=":string, 24:uintptr, "\n":string) ()
	t2 = gothrow("bad syncSema size":string)                             ()
	jump 2
2:                                                              if.done P:2 S:0
	return

# Name: runtime.os_sigpipe
# Package: runtime
# Location: /usr/local/go/src/runtime/signal_unix.go:11:6
func os_sigpipe():
0:                                                                entry P:0 S:0
	t0 = onM(sigpipe)                                                    ()
	return

# Name: runtime.sigpanic
# Package: runtime
# Location: /usr/local/go/src/runtime/sigpanic_unix.go:11:6
func sigpanic():
0:                                                                entry P:0 S:2
	t0 = getg()                                                          *g
	t1 = canpanic(t0)                                                  bool
	if t1 goto 2 else 1
1:                                                              if.then P:1 S:1
	t2 = gothrow("unexpected signal...":string)                          ()
	jump 2
2:                                                              if.done P:2 S:2
	t3 = &t0.sig [#23]                                               *int32
	t4 = *t3                                                          int32
	t5 = t4 == 10:int32                                                bool
	if t5 goto 4 else 6
3:                                                          switch.done P:4 S:0
	t6 = &t0.sig [#23]                                               *int32
	t7 = *t6                                                          int32
	t8 = signame(t7)                                                  *byte
	t9 = gostringnocopy(t8)                                          string
	t10 = changetype errorString <- string (t9)                 errorString
	t11 = make interface{} <- errorString (t10)                 interface{}
	panic t11
4:                                                          switch.body P:1 S:2
	t12 = &t0.sigcode0 [#25]                                       *uintptr
	t13 = *t12                                                      uintptr
	t14 = t13 == 2:uintptr                                             bool
	if t14 goto 10 else 9
5:                                                          switch.body P:1 S:2
	t15 = &t0.sigcode0 [#25]                                       *uintptr
	t16 = *t15                                                      uintptr
	t17 = t16 == 0:uintptr                                             bool
	if t17 goto 16 else 18
6:                                                          switch.next P:1 S:2
	t18 = t4 == 11:int32                                               bool
	if t18 goto 5 else 12
7:                                                              if.then P:2 S:1
	t19 = panicmem()                                                     ()
	jump 8
8:                                                              if.done P:2 S:1
	t20 = &t0.sigcode1 [#26]                                       *uintptr
	t21 = *t20                                                      uintptr
	t22 = convert hex <- uintptr (t21)                                  hex
	t23 = print("unexpected fault ...":string, t22, "\n":string)         ()
	t24 = gothrow("fault":string)                                        ()
	jump 3
9:                                                           cond.false P:2 S:2
	t25 = &t0.paniconfault [#16]                                      *bool
	t26 = *t25                                                         bool
	if t26 goto 7 else 8
10:                                                           cond.true P:1 S:2
	t27 = &t0.sigcode1 [#26]                                       *uintptr
	t28 = *t27                                                      uintptr
	t29 = t28 < 4096:uintptr                                           bool
	if t29 goto 7 else 9
11:                                                         switch.body P:1 S:2
	t30 = &t0.sigcode0 [#25]                                       *uintptr
	t31 = *t30                                                      uintptr
	t32 = t31 == 7:uintptr                                             bool
	if t32 goto 20 else 22
12:                                                         switch.next P:1 S:2
	t33 = t4 == 8:int32                                                bool
	if t33 goto 11 else 3
13:                                                             if.then P:2 S:1
	t34 = panicmem()                                                     ()
	jump 14
14:                                                             if.done P:2 S:1
	t35 = &t0.sigcode1 [#26]                                       *uintptr
	t36 = *t35                                                      uintptr
	t37 = convert hex <- uintptr (t36)                                  hex
	t38 = print("unexpected fault ...":string, t37, "\n":string)         ()
	t39 = gothrow("fault":string)                                        ()
	jump 3
15:                                                          cond.false P:2 S:2
	t40 = &t0.paniconfault [#16]                                      *bool
	t41 = *t40                                                         bool
	if t41 goto 13 else 14
16:                                                           cond.true P:3 S:2
	t42 = &t0.sigcode1 [#26]                                       *uintptr
	t43 = *t42                                                      uintptr
	t44 = t43 < 4096:uintptr                                           bool
	if t44 goto 13 else 15
17:                                                          cond.false P:1 S:2
	t45 = &t0.sigcode0 [#25]                                       *uintptr
	t46 = *t45                                                      uintptr
	t47 = t46 == 2:uintptr                                             bool
	if t47 goto 16 else 15
18:                                                          cond.false P:1 S:2
	t48 = &t0.sigcode0 [#25]                                       *uintptr
	t49 = *t48                                                      uintptr
	t50 = t49 == 1:uintptr                                             bool
	if t50 goto 16 else 17
19:                                                         switch.done P:3 S:1
	t51 = panicfloat()                                                   ()
	jump 3
20:                                                         switch.body P:1 S:1
	t52 = panicdivide()                                                  ()
	jump 19
21:                                                         switch.body P:1 S:1
	t53 = panicoverflow()                                                ()
	jump 19
22:                                                         switch.next P:1 S:2
	t54 = t31 == 8:uintptr                                             bool
	if t54 goto 21 else 19

# Name: runtime.sigsend
# Package: runtime
# Location: /usr/local/go/src/runtime/sigqueue.go:48:6
func sigsend(s int32) bool:
0:                                                                entry P:0 S:2
	t0 = s & 31:int32                                                 int32
	t1 = convert uint <- int32 (t0)                                    uint
	t2 = 1:uint32 << t1                                              uint32
	t3 = &sig.inuse [#5]                                              *bool
	t4 = *t3                                                           bool
	if t4 goto 4 else 1
1:                                                              if.then P:4 S:0
	return false:bool
2:                                                           cond.false P:1 S:2
	t5 = &sig.wanted [#2]                                        *[1]uint32
	t6 = s / 32:int32                                                 int32
	t7 = convert int <- int32 (t6)                                      int
	t8 = &t5[t7]                                                    *uint32
	t9 = *t8                                                         uint32
	t10 = t9 & t2                                                    uint32
	t11 = t10 == 0:uint32                                              bool
	if t11 goto 1 else 5
3:                                                           cond.false P:1 S:2
	t12 = convert int <- int32 (s)                                      int
	t13 = t12 >= 32:int                                                bool
	if t13 goto 1 else 2
4:                                                           cond.false P:1 S:2
	t14 = s < 0:int32                                                  bool
	if t14 goto 1 else 3
5:                                                             for.body P:2 S:2
	t15 = &sig.mask [#1]                                         *[1]uint32
	t16 = s / 32:int32                                                int32
	t17 = convert int <- int32 (t16)                                    int
	t18 = &t15[t17]                                                 *uint32
	t19 = *t18                                                       uint32
	t20 = t19 & t2                                                   uint32
	t21 = t20 != 0:uint32                                              bool
	if t21 goto 6 else 7
6:                                                              if.then P:1 S:0
	return true:bool
7:                                                              if.done P:1 S:2
	t22 = &sig.mask [#1]                                         *[1]uint32
	t23 = s / 32:int32                                                int32
	t24 = convert int <- int32 (t23)                                    int
	t25 = &t22[t24]                                                 *uint32
	t26 = t19 | t2                                                   uint32
	t27 = cas(t25, t19, t26)                                           bool
	if t27 goto 8 else 5
8:                                                             for.body P:4 S:2
	t28 = &sig.state [#4]                                           *uint32
	t29 = atomicload(t28)                                            uint32
	t30 = t29 == 0:uint32                                              bool
	if t30 goto 10 else 11
9:                                                             for.done P:3 S:0
	return true:bool
10:                                                         switch.body P:1 S:2
	t31 = &sig.state [#4]                                           *uint32
	t32 = cas(t31, 0:uint32, 2:uint32)                                 bool
	if t32 goto 9 else 8
11:                                                         switch.next P:1 S:2
	t33 = t29 == 2:uint32                                              bool
	if t33 goto 9 else 13
12:                                                         switch.body P:1 S:2
	t34 = &sig.state [#4]                                           *uint32
	t35 = cas(t34, 1:uint32, 0:uint32)                                 bool
	if t35 goto 15 else 8
13:                                                         switch.next P:1 S:2
	t36 = t29 == 1:uint32                                              bool
	if t36 goto 12 else 14
14:                                                         switch.next P:1 S:1
	t37 = gothrow("sigsend: inconsis...":string)                         ()
	jump 8
15:                                                             if.then P:1 S:1
	t38 = &sig.note [#0]                                              *note
	t39 = notewakeup(t38)                                                ()
	jump 9

# Name: runtime.signal_recv
# Package: runtime
# Location: /usr/local/go/src/runtime/sigqueue.go:91:6
func signal_recv() uint32:
0:                                                                entry P:0 S:1
	jump 1
1:                                                             for.body P:2 S:1
	jump 3
2:                                                             for.body P:1 S:2
	t0 = &sig.recv [#3]                                          *[1]uint32
	t1 = t9 / 32:uint32                                              uint32
	t2 = convert int <- uint32 (t1)                                     int
	t3 = &t0[t2]                                                    *uint32
	t4 = *t3                                                         uint32
	t5 = t9 & 31:uint32                                              uint32
	t6 = 1:uint32 << t5                                              uint32
	t7 = t4 & t6                                                     uint32
	t8 = t7 != 0:uint32                                                bool
	if t8 goto 4 else 5
3:                                                             for.loop P:2 S:2
	t9 = phi [1: 0:uint32, 5: t19] #i                                uint32
	t10 = t9 < 32:uint32                                               bool
	if t10 goto 2 else 6
4:                                                              if.then P:1 S:0
	t11 = &sig.recv [#3]                                         *[1]uint32
	t12 = t9 / 32:uint32                                             uint32
	t13 = convert int <- uint32 (t12)                                   int
	t14 = &t11[t13]                                                 *uint32
	t15 = t9 & 31:uint32                                             uint32
	t16 = 1:uint32 << t15                                            uint32
	t17 = *t14                                                       uint32
	t18 = t17 &^ t16                                                 uint32
	*t14 = t18
	return t9
5:                                                              if.done P:1 S:1
	t19 = t9 + 1:uint32                                              uint32
	jump 3
6:                                                             for.body P:4 S:2
	t20 = &sig.state [#4]                                           *uint32
	t21 = atomicload(t20)                                            uint32
	t22 = t21 == 0:uint32                                              bool
	if t22 goto 8 else 10
7:                                                             for.done P:2 S:1
	t23 = &sig.mask [#1]                                         *[1]uint32
	t24 = *t23                                                    [1]uint32
	jump 13
8:                                                          switch.body P:1 S:2
	t25 = &sig.state [#4]                                           *uint32
	t26 = cas(t25, 0:uint32, 1:uint32)                                 bool
	if t26 goto 11 else 6
9:                                                          switch.body P:1 S:2
	t27 = &sig.state [#4]                                           *uint32
	t28 = cas(t27, 2:uint32, 0:uint32)                                 bool
	if t28 goto 7 else 6
10:                                                         switch.next P:1 S:2
	t29 = t21 == 2:uint32                                              bool
	if t29 goto 9 else 12
11:                                                             if.then P:1 S:1
	t30 = &sig.note [#0]                                              *note
	t31 = notetsleepg(t30, -1:int64)                                   bool
	t32 = &sig.note [#0]                                              *note
	t33 = noteclear(t32)                                                 ()
	jump 7
12:                                                         switch.next P:1 S:1
	t34 = gothrow("signal_recv: inco...":string)                         ()
	jump 6
13:                                                     rangeindex.loop P:2 S:2
	t35 = phi [7: -1:int, 14: t36]                                      int
	t36 = t35 + 1:int                                                   int
	t37 = t36 < 1:int                                                  bool
	if t37 goto 14 else 1
14:                                                     rangeindex.body P:1 S:1
	t38 = &sig.recv [#3]                                         *[1]uint32
	t39 = &t38[t36]                                                 *uint32
	t40 = &sig.mask [#1]                                         *[1]uint32
	t41 = &t40[t36]                                                 *uint32
	t42 = xchg(t41, 0:uint32)                                        uint32
	*t39 = t42
	jump 13

# Name: runtime.signal_enable
# Package: runtime
# Location: /usr/local/go/src/runtime/sigqueue.go:128:6
func signal_enable(s uint32):
0:                                                                entry P:0 S:2
	t0 = &sig.inuse [#5]                                              *bool
	t1 = *t0                                                           bool
	if t1 goto 2 else 1
1:                                                              if.then P:1 S:0
	t2 = &sig.inuse [#5]                                              *bool
	*t2 = true:bool
	t3 = &sig.note [#0]                                               *note
	t4 = noteclear(t3)                                                   ()
	return
2:                                                              if.done P:1 S:2
	t5 = convert int <- uint32 (s)                                      int
	t6 = t5 >= 32:int                                                  bool
	if t6 goto 3 else 4
3:                                                              if.then P:1 S:0
	return
4:                                                              if.done P:1 S:0
	t7 = &sig.wanted [#2]                                        *[1]uint32
	t8 = s / 32:uint32                                               uint32
	t9 = convert int <- uint32 (t8)                                     int
	t10 = &t7[t9]                                                   *uint32
	t11 = s & 31:uint32                                              uint32
	t12 = 1:uint32 << t11                                            uint32
	t13 = *t10                                                       uint32
	t14 = t13 | t12                                                  uint32
	*t10 = t14
	t15 = sigenable_go(s)                                                ()
	return

# Name: runtime.signal_disable
# Package: runtime
# Location: /usr/local/go/src/runtime/sigqueue.go:146:6
func signal_disable(s uint32):
0:                                                                entry P:0 S:2
	t0 = convert int <- uint32 (s)                                      int
	t1 = t0 >= 32:int                                                  bool
	if t1 goto 1 else 2
1:                                                              if.then P:1 S:0
	return
2:                                                              if.done P:1 S:0
	t2 = &sig.wanted [#2]                                        *[1]uint32
	t3 = s / 32:uint32                                               uint32
	t4 = convert int <- uint32 (t3)                                     int
	t5 = &t2[t4]                                                    *uint32
	t6 = s & 31:uint32                                               uint32
	t7 = 1:uint32 << t6                                              uint32
	t8 = *t5                                                         uint32
	t9 = t8 &^ t7                                                    uint32
	*t5 = t9
	t10 = sigdisable_go(s)                                               ()
	return

# Name: runtime.badsignal
# Package: runtime
# Location: /usr/local/go/src/runtime/sigqueue.go:156:6
func badsignal(sig uintptr):
0:                                                                entry P:0 S:2
	t0 = new uintptr (sig)                                         *uintptr
	*t0 = sig
	if true:untyped bool goto 4 else 2
1:                                                              if.then P:1 S:0
	return
2:                                                              if.done P:3 S:0
	t1 = make interface{} <- func(s int32) bool (sigsend)       interface{}
	t2 = funcPC(t1)                                                 uintptr
	t3 = convert unsafe.Pointer <- uintptr (t2)              unsafe.Pointer
	t4 = convert unsafe.Pointer <- *uintptr (t0)             unsafe.Pointer
	t5 = noescape(t4)                                        unsafe.Pointer
	t6 = cgocallback(t3, t5, 8:uintptr)                                  ()
	return
3:                                                            cond.true P:1 S:2
	t7 = *needextram                                                 uint32
	t8 = t7 != 0:uint32                                                bool
	if t8 goto 1 else 2
4:                                                            cond.true P:1 S:2
	t9 = *t0                                                        uintptr
	t10 = t9 == 27:uintptr                                             bool
	if t10 goto 3 else 2

# Name: runtime.sigenable_go
# Package: runtime
# Location: /usr/local/go/src/runtime/sigqueue.go:172:6
func sigenable_go(s uint32):
0:                                                                entry P:0 S:0
	t0 = getg()                                                          *g
	t1 = &t0.m [#21]                                                    **m
	t2 = *t1                                                             *m
	t3 = &t2.scalararg [#45]                                    *[4]uintptr
	t4 = &t3[0:int]                                                *uintptr
	t5 = convert uintptr <- uint32 (s)                              uintptr
	*t4 = t5
	t6 = onM(sigenable_m)                                                ()
	return

# Name: runtime.sigdisable_go
# Package: runtime
# Location: /usr/local/go/src/runtime/sigqueue.go:178:6
func sigdisable_go(s uint32):
0:                                                                entry P:0 S:0
	t0 = getg()                                                          *g
	t1 = &t0.m [#21]                                                    **m
	t2 = *t1                                                             *m
	t3 = &t2.scalararg [#45]                                    *[4]uintptr
	t4 = &t3[0:int]                                                *uintptr
	t5 = convert uintptr <- uint32 (s)                              uintptr
	*t4 = t5
	t6 = onM(sigdisable_m)                                               ()
	return

# Name: runtime.makeslice
# Package: runtime
# Location: /usr/local/go/src/runtime/slice.go:18:6
# Locals:
#   0:	t25 sliceStruct
func makeslice(t *slicetype, len64 int64, cap64 int64) sliceStruct:
0:                                                                entry P:0 S:2
	t0 = convert int <- int64 (len64)                                   int
	t1 = len64 < 0:int64                                               bool
	if t1 goto 1 else 4
1:                                                              if.then P:3 S:0
	t2 = make interface{} <- errorString ("makeslice: len ou...":errorString) interface{}
	panic t2
2:                                                              if.done P:2 S:2
	t3 = convert int <- int64 (cap64)                                   int
	t4 = t3 < t0                                                       bool
	if t4 goto 6 else 9
3:                                                           cond.false P:1 S:2
	t5 = &t.elem [#1]                                               **_type
	t6 = *t5                                                         *_type
	t7 = &t6.size [#0]                                             *uintptr
	t8 = *t7                                                        uintptr
	t9 = t8 > 0:uintptr                                                bool
	if t9 goto 5 else 2
4:                                                           cond.false P:1 S:2
	t10 = convert int64 <- int (t0)                                   int64
	t11 = t10 != len64                                                 bool
	if t11 goto 1 else 3
5:                                                            cond.true P:1 S:2
	t12 = convert uintptr <- int (t0)                               uintptr
	t13 = *maxmem                                                   uintptr
	t14 = &t.elem [#1]                                              **_type
	t15 = *t14                                                       *_type
	t16 = &t15.size [#0]                                           *uintptr
	t17 = *t16                                                      uintptr
	t18 = t13 / t17                                                 uintptr
	t19 = t12 > t18                                                    bool
	if t19 goto 1 else 2
6:                                                              if.then P:3 S:0
	t20 = make interface{} <- errorString ("makeslice: cap ou...":errorString) interface{}
	panic t20
7:                                                              if.done P:2 S:0
	t21 = &t.elem [#1]                                              **_type
	t22 = *t21                                                       *_type
	t23 = convert uintptr <- int (t3)                               uintptr
	t24 = newarray(t22, t23)                                 unsafe.Pointer
	t25 = local sliceStruct (complit)                          *sliceStruct
	t26 = &t25.array [#0]                                   *unsafe.Pointer
	t27 = &t25.len [#1]                                                *int
	t28 = &t25.cap [#2]                                                *int
	*t26 = t24
	*t27 = t0
	*t28 = t3
	t29 = *t25                                                  sliceStruct
	return t29
8:                                                           cond.false P:1 S:2
	t30 = &t.elem [#1]                                              **_type
	t31 = *t30                                                       *_type
	t32 = &t31.size [#0]                                           *uintptr
	t33 = *t32                                                      uintptr
	t34 = t33 > 0:uintptr                                              bool
	if t34 goto 10 else 7
9:                                                           cond.false P:1 S:2
	t35 = convert int64 <- int (t3)                                   int64
	t36 = t35 != cap64                                                 bool
	if t36 goto 6 else 8
10:                                                           cond.true P:1 S:2
	t37 = convert uintptr <- int (t3)                               uintptr
	t38 = *maxmem                                                   uintptr
	t39 = &t.elem [#1]                                              **_type
	t40 = *t39                                                       *_type
	t41 = &t40.size [#0]                                           *uintptr
	t42 = *t41                                                      uintptr
	t43 = t38 / t42                                                 uintptr
	t44 = t37 > t43                                                    bool
	if t44 goto 6 else 7

# Name: runtime.growslice
# Package: runtime
# Location: /usr/local/go/src/runtime/slice.go:37:6
# Locals:
#   0:	t1 sliceStruct
#   1:	t53 sliceStruct
#   2:	t110 sliceStruct
func growslice(t *slicetype, old sliceStruct, n int64) sliceStruct:
0:                                                                entry P:0 S:2
	t0 = new *slicetype (t)                                     **slicetype
	*t0 = t
	t1 = local sliceStruct (old)                               *sliceStruct
	*t1 = old
	t2 = n < 1:int64                                                   bool
	if t2 goto 1 else 2
1:                                                              if.then P:1 S:0
	t3 = make interface{} <- errorString ("growslice: invalid n":errorString) interface{}
	panic t3
2:                                                              if.done P:1 S:2
	t4 = &t1.cap [#2]                                                  *int
	t5 = *t4                                                            int
	t6 = convert int64 <- int (t5)                                    int64
	t7 = t6 + n                                                       int64
	t8 = convert int <- int64 (t7)                                      int
	t9 = convert int64 <- int (t8)                                    int64
	t10 = t9 != t7                                                     bool
	if t10 goto 3 else 6
3:                                                              if.then P:3 S:0
	t11 = make interface{} <- errorString ("growslice: cap ou...":errorString) interface{}
	panic t11
4:                                                              if.done P:2 S:2
	if false:untyped bool goto 8 else 9
5:                                                           cond.false P:1 S:2
	t12 = *t0                                                    *slicetype
	t13 = &t12.elem [#1]                                            **_type
	t14 = *t13                                                       *_type
	t15 = &t14.size [#0]                                           *uintptr
	t16 = *t15                                                      uintptr
	t17 = t16 > 0:uintptr                                              bool
	if t17 goto 7 else 4
6:                                                           cond.false P:1 S:2
	t18 = &t1.cap [#2]                                                 *int
	t19 = *t18                                                          int
	t20 = t8 < t19                                                     bool
	if t20 goto 3 else 5
7:                                                            cond.true P:1 S:2
	t21 = convert uintptr <- int (t8)                               uintptr
	t22 = *maxmem                                                   uintptr
	t23 = *t0                                                    *slicetype
	t24 = &t23.elem [#1]                                            **_type
	t25 = *t24                                                       *_type
	t26 = &t25.size [#0]                                           *uintptr
	t27 = *t26                                                      uintptr
	t28 = t22 / t27                                                 uintptr
	t29 = t21 > t28                                                    bool
	if t29 goto 3 else 4
8:                                                              if.then P:1 S:1
	t30 = convert unsafe.Pointer <- **slicetype (t0)         unsafe.Pointer
	t31 = getcallerpc(t30)                                          uintptr
	t32 = &t1.array [#0]                                    *unsafe.Pointer
	t33 = *t32                                               unsafe.Pointer
	t34 = &t1.len [#1]                                                 *int
	t35 = *t34                                                          int
	t36 = *t0                                                    *slicetype
	t37 = &t36.elem [#1]                                            **_type
	t38 = *t37                                                       *_type
	t39 = &t38.size [#0]                                           *uintptr
	t40 = *t39                                                      uintptr
	t41 = convert int <- uintptr (t40)                                  int
	t42 = t35 * t41                                                     int
	t43 = convert uintptr <- int (t42)                              uintptr
	t44 = make interface{} <- func(t *slicetype, old sliceStruct, n int64) sliceStruct (growslice) interface{}
	t45 = funcPC(t44)                                               uintptr
	t46 = racereadrangepc(t33, t43, t31, t45)                            ()
	jump 9
9:                                                              if.done P:2 S:2
	t47 = *t0                                                    *slicetype
	t48 = &t47.elem [#1]                                            **_type
	t49 = *t48                                                       *_type
	t50 = &t49.size [#0]                                           *uintptr
	t51 = *t50                                                      uintptr
	t52 = t51 == 0:uintptr                                             bool
	if t52 goto 10 else 11
10:                                                             if.then P:1 S:0
	t53 = local sliceStruct (complit)                          *sliceStruct
	t54 = &t53.array [#0]                                   *unsafe.Pointer
	t55 = &t1.array [#0]                                    *unsafe.Pointer
	t56 = *t55                                               unsafe.Pointer
	t57 = &t53.len [#1]                                                *int
	t58 = &t1.len [#1]                                                 *int
	t59 = *t58                                                          int
	t60 = &t53.cap [#2]                                                *int
	*t54 = t56
	*t57 = t59
	*t60 = t8
	t61 = *t53                                                  sliceStruct
	return t61
11:                                                             if.done P:1 S:2
	t62 = &t1.cap [#2]                                                 *int
	t63 = *t62                                                          int
	t64 = t63 + t63                                                     int
	t65 = t64 < t8                                                     bool
	if t65 goto 12 else 14
12:                                                             if.then P:1 S:1
	jump 13
13:                                                             if.done P:2 S:2
	t66 = phi [12: t8, 16: t78] #newcap                                 int
	t67 = convert uintptr <- int (t66)                              uintptr
	t68 = *maxmem                                                   uintptr
	t69 = &t49.size [#0]                                           *uintptr
	t70 = *t69                                                      uintptr
	t71 = t68 / t70                                                 uintptr
	t72 = t67 >= t71                                                   bool
	if t72 goto 18 else 19
14:                                                            for.body P:2 S:2
	t73 = phi [11: t63, 16: t78] #newcap                                int
	t74 = &t1.len [#1]                                                 *int
	t75 = *t74                                                          int
	t76 = t75 < 1024:int                                               bool
	if t76 goto 15 else 17
15:                                                             if.then P:1 S:1
	t77 = t73 + t73                                                     int
	jump 16
16:                                                             if.done P:2 S:2
	t78 = phi [15: t77, 17: t81] #newcap                                int
	t79 = t78 >= t8                                                    bool
	if t79 goto 13 else 14
17:                                                             if.else P:1 S:1
	t80 = t73 / 4:int                                                   int
	t81 = t73 + t80                                                     int
	jump 16
18:                                                             if.then P:1 S:0
	t82 = make interface{} <- errorString ("growslice: cap ou...":errorString) interface{}
	panic t82
19:                                                             if.done P:1 S:2
	t83 = &t1.len [#1]                                                 *int
	t84 = *t83                                                          int
	t85 = convert uintptr <- int (t84)                              uintptr
	t86 = &t49.size [#0]                                           *uintptr
	t87 = *t86                                                      uintptr
	t88 = t85 * t87                                                 uintptr
	t89 = convert uintptr <- int (t66)                              uintptr
	t90 = &t49.size [#0]                                           *uintptr
	t91 = *t90                                                      uintptr
	t92 = t89 * t91                                                 uintptr
	t93 = goroundupsize(t92)                                        uintptr
	t94 = &t49.size [#0]                                           *uintptr
	t95 = *t94                                                      uintptr
	t96 = t93 / t95                                                 uintptr
	t97 = convert int <- uintptr (t96)                                  int
	t98 = &t49.kind [#5]                                             *uint8
	t99 = *t98                                                        uint8
	t100 = t99 & 128:uint8                                            uint8
	t101 = t100 != 0:uint8                                             bool
	if t101 goto 20 else 22
20:                                                             if.then P:1 S:1
	t102 = rawmem(t93)                                       unsafe.Pointer
	t103 = add(t102, t88)                                    unsafe.Pointer
	t104 = t93 - t88                                                uintptr
	t105 = memclr(t103, t104)                                            ()
	jump 21
21:                                                             if.done P:2 S:0
	t106 = phi [20: t102, 22: t118] #p                       unsafe.Pointer
	t107 = &t1.array [#0]                                   *unsafe.Pointer
	t108 = *t107                                             unsafe.Pointer
	t109 = memmove(t106, t108, t88)                                      ()
	t110 = local sliceStruct (complit)                         *sliceStruct
	t111 = &t110.array [#0]                                 *unsafe.Pointer
	t112 = &t110.len [#1]                                              *int
	t113 = &t1.len [#1]                                                *int
	t114 = *t113                                                        int
	t115 = &t110.cap [#2]                                              *int
	*t111 = t106
	*t112 = t114
	*t115 = t97
	t116 = *t110                                                sliceStruct
	return t116
22:                                                             if.else P:1 S:1
	t117 = convert uintptr <- int (t97)                             uintptr
	t118 = newarray(t49, t117)                               unsafe.Pointer
	jump 21

# Name: runtime.slicecopy
# Package: runtime
# Location: /usr/local/go/src/runtime/slice.go:94:6
# Locals:
#   0:	t1 sliceStruct
func slicecopy(to sliceStruct, fm sliceStruct, width uintptr) int:
0:                                                                entry P:0 S:2
	t0 = new sliceStruct (to)                                  *sliceStruct
	*t0 = to
	t1 = local sliceStruct (fm)                                *sliceStruct
	*t1 = fm
	t2 = &t1.len [#1]                                                  *int
	t3 = *t2                                                            int
	t4 = t3 == 0:int                                                   bool
	if t4 goto 1 else 4
1:                                                              if.then P:3 S:0
	return 0:int
2:                                                              if.done P:1 S:2
	t5 = &t1.len [#1]                                                  *int
	t6 = *t5                                                            int
	t7 = &t0.len [#1]                                                  *int
	t8 = *t7                                                            int
	t9 = t8 < t6                                                       bool
	if t9 goto 5 else 6
3:                                                           cond.false P:1 S:2
	t10 = width == 0:uintptr                                           bool
	if t10 goto 1 else 2
4:                                                           cond.false P:1 S:2
	t11 = &t0.len [#1]                                                 *int
	t12 = *t11                                                          int
	t13 = t12 == 0:int                                                 bool
	if t13 goto 1 else 3
5:                                                              if.then P:1 S:1
	t14 = &t0.len [#1]                                                 *int
	t15 = *t14                                                          int
	jump 6
6:                                                              if.done P:2 S:2
	t16 = phi [2: t6, 5: t15] #n                                        int
	if false:untyped bool goto 7 else 8
7:                                                              if.then P:1 S:1
	t17 = convert unsafe.Pointer <- *sliceStruct (t0)        unsafe.Pointer
	t18 = getcallerpc(t17)                                          uintptr
	t19 = make interface{} <- func(to sliceStruct, fm sliceStruct, width uintptr) int (slicecopy) interface{}
	t20 = funcPC(t19)                                               uintptr
	t21 = &t0.array [#0]                                    *unsafe.Pointer
	t22 = *t21                                               unsafe.Pointer
	t23 = convert int <- uintptr (width)                                int
	t24 = t16 * t23                                                     int
	t25 = convert uintptr <- int (t24)                              uintptr
	t26 = racewriterangepc(t22, t25, t18, t20)                           ()
	t27 = &t1.array [#0]                                    *unsafe.Pointer
	t28 = *t27                                               unsafe.Pointer
	t29 = convert int <- uintptr (width)                                int
	t30 = t16 * t29                                                     int
	t31 = convert uintptr <- int (t30)                              uintptr
	t32 = racereadrangepc(t28, t31, t18, t20)                            ()
	jump 8
8:                                                              if.done P:2 S:2
	t33 = convert uintptr <- int (t16)                              uintptr
	t34 = t33 * width                                               uintptr
	t35 = t34 == 1:uintptr                                             bool
	if t35 goto 9 else 11
9:                                                              if.then P:1 S:1
	t36 = &t0.array [#0]                                    *unsafe.Pointer
	t37 = *t36                                               unsafe.Pointer
	t38 = convert *byte <- unsafe.Pointer (t37)                       *byte
	t39 = &t1.array [#0]                                    *unsafe.Pointer
	t40 = *t39                                               unsafe.Pointer
	t41 = convert *byte <- unsafe.Pointer (t40)                       *byte
	t42 = *t41                                                         byte
	*t38 = t42
	jump 10
10:                                                             if.done P:2 S:0
	return t16
11:                                                             if.else P:1 S:1
	t43 = &t0.array [#0]                                    *unsafe.Pointer
	t44 = *t43                                               unsafe.Pointer
	t45 = &t1.array [#0]                                    *unsafe.Pointer
	t46 = *t45                                               unsafe.Pointer
	t47 = memmove(t44, t46, t34)                                         ()
	jump 10

# Name: runtime.slicestringcopy
# Package: runtime
# Location: /usr/local/go/src/runtime/slice.go:121:6
func slicestringcopy(to []byte, fm string) int:
0:                                                                entry P:0 S:2
	t0 = new []byte (to)                                            *[]byte
	*t0 = to
	t1 = new string (fm)                                            *string
	*t1 = fm
	t2 = *t1                                                         string
	t3 = len(t2)                                                        int
	t4 = t3 == 0:int                                                   bool
	if t4 goto 1 else 3
1:                                                              if.then P:2 S:0
	return 0:int
2:                                                              if.done P:1 S:2
	t5 = *t1                                                         string
	t6 = len(t5)                                                        int
	t7 = *t0                                                         []byte
	t8 = len(t7)                                                        int
	t9 = t8 < t6                                                       bool
	if t9 goto 4 else 5
3:                                                           cond.false P:1 S:2
	t10 = *t0                                                        []byte
	t11 = len(t10)                                                      int
	t12 = t11 == 0:int                                                 bool
	if t12 goto 1 else 2
4:                                                              if.then P:1 S:1
	t13 = *t0                                                        []byte
	t14 = len(t13)                                                      int
	jump 5
5:                                                              if.done P:2 S:2
	t15 = phi [2: t6, 4: t14] #n                                        int
	if false:untyped bool goto 6 else 7
6:                                                              if.then P:1 S:1
	t16 = convert unsafe.Pointer <- *[]byte (t0)             unsafe.Pointer
	t17 = getcallerpc(t16)                                          uintptr
	t18 = make interface{} <- func(to []byte, fm string) int (slicestringcopy) interface{}
	t19 = funcPC(t18)                                               uintptr
	t20 = *t0                                                        []byte
	t21 = &t20[0:int]                                                 *byte
	t22 = convert unsafe.Pointer <- *byte (t21)              unsafe.Pointer
	t23 = convert uintptr <- int (t15)                              uintptr
	t24 = racewriterangepc(t22, t23, t17, t19)                           ()
	jump 7
7:                                                              if.done P:2 S:0
	t25 = *t0                                                        []byte
	t26 = &t25[0:int]                                                 *byte
	t27 = convert unsafe.Pointer <- *byte (t26)              unsafe.Pointer
	t28 = convert unsafe.Pointer <- *string (t1)             unsafe.Pointer
	t29 = convert *stringStruct <- unsafe.Pointer (t28)       *stringStruct
	t30 = &t29.str [#0]                                     *unsafe.Pointer
	t31 = *t30                                               unsafe.Pointer
	t32 = convert uintptr <- int (t15)                              uintptr
	t33 = memmove(t27, t31, t32)                                         ()
	return t15

# Name: runtime.funpack64
# Package: runtime
# Location: /usr/local/go/src/runtime/softfloat64.go:29:6
func funpack64(f uint64) (sign uint64, mant uint64, exp int, inf bool, nan bool):
0:                                                                entry P:0 S:2
	t0 = f & 9223372036854775808:uint64                              uint64
	t1 = f & 4503599627370495:uint64                                 uint64
	t2 = f >> 52:uint                                                uint64
	t3 = convert int <- uint64 (t2)                                     int
	t4 = t3 & 2047:int                                                  int
	t5 = t4 == 2047:int                                                bool
	if t5 goto 2 else 4
1:                                                          switch.done P:3 S:0
	t6 = phi [3: t1, 7: t11, 10: t16] #mant                          uint64
	t7 = phi [3: t4, 7: t12, 10: t17] #exp                              int
	return t0, t6, t7, false:bool, false:bool
2:                                                          switch.body P:1 S:2
	t8 = t1 != 0:uint64                                                bool
	if t8 goto 5 else 6
3:                                                          switch.body P:1 S:2
	t9 = t1 != 0:uint64                                                bool
	if t9 goto 8 else 1
4:                                                          switch.next P:1 S:2
	t10 = t4 == 0:int                                                  bool
	if t10 goto 3 else 7
5:                                                              if.then P:1 S:0
	return t0, t1, t4, false:bool, true:bool
6:                                                              if.done P:1 S:0
	return t0, t1, t4, true:bool, false:bool
7:                                                          switch.next P:1 S:1
	t11 = t1 | 4503599627370496:uint64                               uint64
	t12 = t4 + -1023:int                                                int
	jump 1
8:                                                              if.then P:1 S:1
	t13 = t4 + -1022:int                                                int
	jump 10
9:                                                             for.body P:1 S:1
	t14 = t16 << 1:uint64                                            uint64
	t15 = t17 - 1:int                                                   int
	jump 10
10:                                                            for.loop P:2 S:2
	t16 = phi [8: t1, 9: t14] #mant                                  uint64
	t17 = phi [8: t13, 9: t15] #exp                                     int
	t18 = t16 < 4503599627370496:uint64                                bool
	if t18 goto 9 else 1

# Name: runtime.funpack32
# Package: runtime
# Location: /usr/local/go/src/runtime/softfloat64.go:61:6
func funpack32(f uint32) (sign uint32, mant uint32, exp int, inf bool, nan bool):
0:                                                                entry P:0 S:2
	t0 = f & 2147483648:uint32                                       uint32
	t1 = f & 8388607:uint32                                          uint32
	t2 = f >> 23:uint                                                uint32
	t3 = convert int <- uint32 (t2)                                     int
	t4 = t3 & 255:int                                                   int
	t5 = t4 == 255:int                                                 bool
	if t5 goto 2 else 4
1:                                                          switch.done P:3 S:0
	t6 = phi [3: t1, 7: t11, 10: t16] #mant                          uint32
	t7 = phi [3: t4, 7: t12, 10: t17] #exp                              int
	return t0, t6, t7, false:bool, false:bool
2:                                                          switch.body P:1 S:2
	t8 = t1 != 0:uint32                                                bool
	if t8 goto 5 else 6
3:                                                          switch.body P:1 S:2
	t9 = t1 != 0:uint32                                                bool
	if t9 goto 8 else 1
4:                                                          switch.next P:1 S:2
	t10 = t4 == 0:int                                                  bool
	if t10 goto 3 else 7
5:                                                              if.then P:1 S:0
	return t0, t1, t4, false:bool, true:bool
6:                                                              if.done P:1 S:0
	return t0, t1, t4, true:bool, false:bool
7:                                                          switch.next P:1 S:1
	t11 = t1 | 8388608:uint32                                        uint32
	t12 = t4 + -127:int                                                 int
	jump 1
8:                                                              if.then P:1 S:1
	t13 = t4 + -126:int                                                 int
	jump 10
9:                                                             for.body P:1 S:1
	t14 = t16 << 1:uint32                                            uint32
	t15 = t17 - 1:int                                                   int
	jump 10
10:                                                            for.loop P:2 S:2
	t16 = phi [8: t1, 9: t14] #mant                                  uint32
	t17 = phi [8: t13, 9: t15] #exp                                     int
	t18 = t16 < 8388608:uint32                                         bool
	if t18 goto 9 else 1

# Name: runtime.fpack64
# Package: runtime
# Location: /usr/local/go/src/runtime/softfloat64.go:93:6
func fpack64(sign uint64, mant uint64, exp int, trunc uint64) uint64:
0:                                                                entry P:0 S:2
	t0 = mant == 0:uint64                                              bool
	if t0 goto 1 else 3
1:                                                              if.then P:1 S:0
	return sign
2:                                                             for.body P:1 S:1
	t1 = t3 << 1:uint64                                              uint64
	t2 = t4 - 1:int                                                     int
	jump 3
3:                                                             for.loop P:2 S:2
	t3 = phi [0: mant, 2: t1] #mant                                  uint64
	t4 = phi [0: exp, 2: t2] #exp                                       int
	t5 = t3 < 4503599627370496:uint64                                  bool
	if t5 goto 2 else 6
4:                                                             for.body P:1 S:1
	t6 = t11 & 1:uint64                                              uint64
	t7 = t13 | t6                                                    uint64
	t8 = t11 >> 1:uint64                                             uint64
	t9 = t12 + 1:int                                                    int
	jump 6
5:                                                             for.done P:1 S:2
	t10 = t11 >= 9007199254740992:uint64                               bool
	if t10 goto 7 else 8
6:                                                             for.loop P:2 S:2
	t11 = phi [3: t3, 4: t8] #mant                                   uint64
	t12 = phi [3: t4, 4: t9] #exp                                       int
	t13 = phi [3: trunc, 4: t7] #trunc                               uint64
	t14 = t11 >= 18014398509481984:uint64                              bool
	if t14 goto 4 else 5
7:                                                              if.then P:1 S:2
	t15 = t11 & 1:uint64                                             uint64
	t16 = t15 != 0:uint64                                              bool
	if t16 goto 11 else 10
8:                                                              if.done P:2 S:2
	t17 = phi [5: t11, 10: t24] #mant                                uint64
	t18 = phi [5: t12, 10: t25] #exp                                    int
	t19 = t18 >= 1024:int                                              bool
	if t19 goto 14 else 15
9:                                                              if.then P:2 S:2
	t20 = t11 + 1:uint64                                             uint64
	t21 = t20 >= 18014398509481984:uint64                              bool
	if t21 goto 13 else 10
10:                                                             if.done P:4 S:1
	t22 = phi [7: t11, 12: t11, 9: t20, 13: t29] #mant               uint64
	t23 = phi [7: t12, 12: t12, 9: t12, 13: t30] #exp                   int
	t24 = t22 >> 1:uint64                                            uint64
	t25 = t23 + 1:int                                                   int
	jump 8
11:                                                           cond.true P:1 S:2
	t26 = t13 != 0:uint64                                              bool
	if t26 goto 9 else 12
12:                                                          cond.false P:1 S:2
	t27 = t11 & 2:uint64                                             uint64
	t28 = t27 != 0:uint64                                              bool
	if t28 goto 9 else 10
13:                                                             if.then P:1 S:1
	t29 = t20 >> 1:uint64                                            uint64
	t30 = t12 + 1:int                                                   int
	jump 10
14:                                                             if.then P:1 S:0
	t31 = sign ^ 9218868437227405312:uint64                          uint64
	return t31
15:                                                             if.done P:1 S:2
	t32 = t18 < -1022:int                                              bool
	if t32 goto 16 else 17
16:                                                             if.then P:1 S:2
	t33 = t18 < -1075:int                                              bool
	if t33 goto 18 else 19
17:                                                             if.done P:2 S:0
	t34 = phi [15: t17, 24: t55] #mant                               uint64
	t35 = phi [15: t18, 24: t56] #exp                                   int
	t36 = t35 - -1023:int                                               int
	t37 = convert uint64 <- int (t36)                                uint64
	t38 = t37 << 52:uint                                             uint64
	t39 = sign | t38                                                 uint64
	t40 = t34 & 4503599627370495:uint64                              uint64
	t41 = t39 | t40                                                  uint64
	return t41
18:                                                             if.then P:1 S:0
	t42 = sign | 0:uint64                                            uint64
	return t42
19:                                                             if.done P:1 S:1
	jump 22
20:                                                            for.body P:1 S:1
	t43 = t49 & 1:uint64                                             uint64
	t44 = t51 | t43                                                  uint64
	t45 = t49 >> 1:uint64                                            uint64
	t46 = t50 + 1:int                                                   int
	jump 22
21:                                                            for.done P:1 S:2
	t47 = t49 & 1:uint64                                             uint64
	t48 = t47 != 0:uint64                                              bool
	if t48 goto 25 else 24
22:                                                            for.loop P:2 S:2
	t49 = phi [19: mant, 20: t45] #mant                              uint64
	t50 = phi [19: exp, 20: t46] #exp                                   int
	t51 = phi [19: trunc, 20: t44] #trunc                            uint64
	t52 = t50 < -1023:int                                              bool
	if t52 goto 20 else 21
23:                                                             if.then P:2 S:1
	t53 = t49 + 1:uint64                                             uint64
	jump 24
24:                                                             if.done P:3 S:2
	t54 = phi [21: t49, 26: t49, 23: t53] #mant                      uint64
	t55 = t54 >> 1:uint64                                            uint64
	t56 = t50 + 1:int                                                   int
	t57 = t55 < 4503599627370496:uint64                                bool
	if t57 goto 27 else 17
25:                                                           cond.true P:1 S:2
	t58 = t51 != 0:uint64                                              bool
	if t58 goto 23 else 26
26:                                                          cond.false P:1 S:2
	t59 = t49 & 2:uint64                                             uint64
	t60 = t59 != 0:uint64                                              bool
	if t60 goto 23 else 24
27:                                                             if.then P:1 S:0
	t61 = sign | t55                                                 uint64
	return t61

# Name: runtime.fpack32
# Package: runtime
# Location: /usr/local/go/src/runtime/softfloat64.go:144:6
func fpack32(sign uint32, mant uint32, exp int, trunc uint32) uint32:
0:                                                                entry P:0 S:2
	t0 = mant == 0:uint32                                              bool
	if t0 goto 1 else 3
1:                                                              if.then P:1 S:0
	return sign
2:                                                             for.body P:1 S:1
	t1 = t3 << 1:uint32                                              uint32
	t2 = t4 - 1:int                                                     int
	jump 3
3:                                                             for.loop P:2 S:2
	t3 = phi [0: mant, 2: t1] #mant                                  uint32
	t4 = phi [0: exp, 2: t2] #exp                                       int
	t5 = t3 < 8388608:uint32                                           bool
	if t5 goto 2 else 6
4:                                                             for.body P:1 S:1
	t6 = t11 & 1:uint32                                              uint32
	t7 = t13 | t6                                                    uint32
	t8 = t11 >> 1:uint32                                             uint32
	t9 = t12 + 1:int                                                    int
	jump 6
5:                                                             for.done P:1 S:2
	t10 = t11 >= 16777216:uint32                                       bool
	if t10 goto 7 else 8
6:                                                             for.loop P:2 S:2
	t11 = phi [3: t3, 4: t8] #mant                                   uint32
	t12 = phi [3: t4, 4: t9] #exp                                       int
	t13 = phi [3: trunc, 4: t7] #trunc                               uint32
	t14 = t11 >= 33554432:uint32                                       bool
	if t14 goto 4 else 5
7:                                                              if.then P:1 S:2
	t15 = t11 & 1:uint32                                             uint32
	t16 = t15 != 0:uint32                                              bool
	if t16 goto 11 else 10
8:                                                              if.done P:2 S:2
	t17 = phi [5: t11, 10: t24] #mant                                uint32
	t18 = phi [5: t12, 10: t25] #exp                                    int
	t19 = t18 >= 128:int                                               bool
	if t19 goto 14 else 15
9:                                                              if.then P:2 S:2
	t20 = t11 + 1:uint32                                             uint32
	t21 = t20 >= 33554432:uint32                                       bool
	if t21 goto 13 else 10
10:                                                             if.done P:4 S:1
	t22 = phi [7: t11, 12: t11, 9: t20, 13: t29] #mant               uint32
	t23 = phi [7: t12, 12: t12, 9: t12, 13: t30] #exp                   int
	t24 = t22 >> 1:uint32                                            uint32
	t25 = t23 + 1:int                                                   int
	jump 8
11:                                                           cond.true P:1 S:2
	t26 = t13 != 0:uint32                                              bool
	if t26 goto 9 else 12
12:                                                          cond.false P:1 S:2
	t27 = t11 & 2:uint32                                             uint32
	t28 = t27 != 0:uint32                                              bool
	if t28 goto 9 else 10
13:                                                             if.then P:1 S:1
	t29 = t20 >> 1:uint32                                            uint32
	t30 = t12 + 1:int                                                   int
	jump 10
14:                                                             if.then P:1 S:0
	t31 = sign ^ 2139095040:uint32                                   uint32
	return t31
15:                                                             if.done P:1 S:2
	t32 = t18 < -126:int                                               bool
	if t32 goto 16 else 17
16:                                                             if.then P:1 S:2
	t33 = t18 < -150:int                                               bool
	if t33 goto 18 else 19
17:                                                             if.done P:2 S:0
	t34 = phi [15: t17, 24: t55] #mant                               uint32
	t35 = phi [15: t18, 24: t56] #exp                                   int
	t36 = t35 - -127:int                                                int
	t37 = convert uint32 <- int (t36)                                uint32
	t38 = t37 << 23:uint                                             uint32
	t39 = sign | t38                                                 uint32
	t40 = t34 & 8388607:uint32                                       uint32
	t41 = t39 | t40                                                  uint32
	return t41
18:                                                             if.then P:1 S:0
	t42 = sign | 0:uint32                                            uint32
	return t42
19:                                                             if.done P:1 S:1
	jump 22
20:                                                            for.body P:1 S:1
	t43 = t49 & 1:uint32                                             uint32
	t44 = t51 | t43                                                  uint32
	t45 = t49 >> 1:uint32                                            uint32
	t46 = t50 + 1:int                                                   int
	jump 22
21:                                                            for.done P:1 S:2
	t47 = t49 & 1:uint32                                             uint32
	t48 = t47 != 0:uint32                                              bool
	if t48 goto 25 else 24
22:                                                            for.loop P:2 S:2
	t49 = phi [19: mant, 20: t45] #mant                              uint32
	t50 = phi [19: exp, 20: t46] #exp                                   int
	t51 = phi [19: trunc, 20: t44] #trunc                            uint32
	t52 = t50 < -127:int                                               bool
	if t52 goto 20 else 21
23:                                                             if.then P:2 S:1
	t53 = t49 + 1:uint32                                             uint32
	jump 24
24:                                                             if.done P:3 S:2
	t54 = phi [21: t49, 26: t49, 23: t53] #mant                      uint32
	t55 = t54 >> 1:uint32                                            uint32
	t56 = t50 + 1:int                                                   int
	t57 = t55 < 8388608:uint32                                         bool
	if t57 goto 27 else 17
25:                                                           cond.true P:1 S:2
	t58 = t51 != 0:uint32                                              bool
	if t58 goto 23 else 26
26:                                                          cond.false P:1 S:2
	t59 = t49 & 2:uint32                                             uint32
	t60 = t59 != 0:uint32                                              bool
	if t60 goto 23 else 24
27:                                                             if.then P:1 S:0
	t61 = sign | t55                                                 uint32
	return t61

# Name: runtime.fadd64
# Package: runtime
# Location: /usr/local/go/src/runtime/softfloat64.go:195:6
func fadd64(f uint64, g uint64) uint64:
0:                                                                entry P:0 S:2
	t0 = funpack64(f) (sign uint64, mant uint64, exp int, inf bool, nan bool)
	t1 = extract t0 #0                                               uint64
	t2 = extract t0 #1                                               uint64
	t3 = extract t0 #2                                                  int
	t4 = extract t0 #3                                                 bool
	t5 = extract t0 #4                                                 bool
	t6 = funpack64(g) (sign uint64, mant uint64, exp int, inf bool, nan bool)
	t7 = extract t6 #0                                               uint64
	t8 = extract t6 #1                                               uint64
	t9 = extract t6 #2                                                  int
	t10 = extract t6 #3                                                bool
	t11 = extract t6 #4                                                bool
	if t5 goto 5 else 4
1:                                                          switch.body P:1 S:0
	return 9218868437227405313:uint64
2:                                                          switch.body P:1 S:0
	return 9218868437227405313:uint64
3:                                                          switch.next P:1 S:2
	if t4 goto 10 else 9
4:                                                            binop.rhs P:1 S:1
	jump 5
5:                                                           binop.done P:2 S:2
	t12 = phi [0: true:bool, 4: t11] #||                               bool
	if t12 goto 1 else 3
6:                                                          switch.body P:1 S:0
	return f
7:                                                          switch.next P:1 S:2
	if t4 goto 6 else 12
8:                                                            binop.rhs P:1 S:1
	t13 = t1 != t7                                                     bool
	jump 9
9:                                                           binop.done P:3 S:2
	t14 = phi [3: false:bool, 10: false:bool, 8: t13] #&&              bool
	if t14 goto 2 else 7
10:                                                           cond.true P:1 S:2
	if t10 goto 8 else 9
11:                                                         switch.body P:1 S:0
	return g
12:                                                         switch.next P:1 S:2
	if t10 goto 11 else 14
13:                                                         switch.body P:1 S:0
	return f
14:                                                         switch.next P:1 S:2
	t15 = t2 == 0:uint64                                               bool
	if t15 goto 20 else 18
15:                                                         switch.body P:1 S:2
	t16 = t8 == 0:uint64                                               bool
	if t16 goto 23 else 24
16:                                                         switch.next P:1 S:2
	t17 = t2 == 0:uint64                                               bool
	if t17 goto 15 else 22
17:                                                           binop.rhs P:1 S:1
	t18 = t7 != 0:uint64                                               bool
	jump 18
18:                                                          binop.done P:4 S:2
	t19 = phi [14: false:bool, 20: false:bool, 19: false:bool, 17: t18] #&& bool
	if t19 goto 13 else 16
19:                                                           cond.true P:1 S:2
	t20 = t1 != 0:uint64                                               bool
	if t20 goto 17 else 18
20:                                                           cond.true P:1 S:2
	t21 = t8 == 0:uint64                                               bool
	if t21 goto 19 else 18
21:                                                         switch.body P:1 S:0
	return f
22:                                                         switch.next P:1 S:2
	t22 = t8 == 0:uint64                                               bool
	if t22 goto 21 else 25
23:                                                             if.then P:1 S:1
	t23 = g ^ t7                                                     uint64
	jump 24
24:                                                             if.done P:2 S:0
	t24 = phi [15: g, 23: t23] #g                                    uint64
	return t24
25:                                                         switch.next P:1 S:2
	t25 = t3 < t9                                                      bool
	if t25 goto 26 else 28
26:                                                             if.then P:2 S:1
	jump 27
27:                                                             if.done P:3 S:2
	t26 = phi [28: t1, 29: t1, 26: t7] #fs                           uint64
	t27 = phi [28: t2, 29: t2, 26: t8] #fm                           uint64
	t28 = phi [28: t3, 29: t3, 26: t9] #fe                              int
	t29 = phi [28: t7, 29: t7, 26: t1] #gs                           uint64
	t30 = phi [28: t8, 29: t8, 26: t2] #gm                           uint64
	t31 = phi [28: t9, 29: t9, 26: t3] #ge                              int
	t32 = t28 - t31                                                     int
	t33 = convert uint <- int (t32)                                    uint
	t34 = t27 << 2:uint64                                            uint64
	t35 = t30 << 2:uint64                                            uint64
	t36 = 1:uint64 << t33                                            uint64
	t37 = t36 - 1:uint64                                             uint64
	t38 = t35 & t37                                                  uint64
	t39 = convert uint64 <- uint (t33)                               uint64
	t40 = t35 >> t39                                                 uint64
	t41 = t26 == t29                                                   bool
	if t41 goto 30 else 32
28:                                                          cond.false P:1 S:2
	t42 = t3 == t9                                                     bool
	if t42 goto 29 else 27
29:                                                           cond.true P:1 S:2
	t43 = t2 < t8                                                      bool
	if t43 goto 26 else 27
30:                                                             if.then P:1 S:1
	t44 = t34 + t40                                                  uint64
	jump 31
31:                                                             if.done P:3 S:2
	t45 = phi [30: t44, 32: t47, 33: t49] #fm                        uint64
	t46 = t45 == 0:uint64                                              bool
	if t46 goto 34 else 35
32:                                                             if.else P:1 S:2
	t47 = t34 - t40                                                  uint64
	t48 = t38 != 0:uint64                                              bool
	if t48 goto 33 else 31
33:                                                             if.then P:1 S:1
	t49 = t47 - 1:uint64                                             uint64
	jump 31
34:                                                             if.then P:1 S:1
	jump 35
35:                                                             if.done P:2 S:0
	t50 = phi [31: t26, 34: 0:uint64] #fs                            uint64
	t51 = t28 - 2:int                                                   int
	t52 = fpack64(t50, t45, t51, t38)                                uint64
	return t52

# Name: runtime.fsub64
# Package: runtime
# Location: /usr/local/go/src/runtime/softfloat64.go:250:6
func fsub64(f uint64, g uint64) uint64:
0:                                                                entry P:0 S:0
	t0 = fneg64(g)                                                   uint64
	t1 = fadd64(f, t0)                                               uint64
	return t1

# Name: runtime.fneg64
# Package: runtime
# Location: /usr/local/go/src/runtime/softfloat64.go:254:6
func fneg64(f uint64) uint64:
0:                                                                entry P:0 S:0
	t0 = f ^ 9223372036854775808:uint64                              uint64
	return t0

# Name: runtime.fmul64
# Package: runtime
# Location: /usr/local/go/src/runtime/softfloat64.go:258:6
func fmul64(f uint64, g uint64) uint64:
0:                                                                entry P:0 S:2
	t0 = funpack64(f) (sign uint64, mant uint64, exp int, inf bool, nan bool)
	t1 = extract t0 #0                                               uint64
	t2 = extract t0 #1                                               uint64
	t3 = extract t0 #2                                                  int
	t4 = extract t0 #3                                                 bool
	t5 = extract t0 #4                                                 bool
	t6 = funpack64(g) (sign uint64, mant uint64, exp int, inf bool, nan bool)
	t7 = extract t6 #0                                               uint64
	t8 = extract t6 #1                                               uint64
	t9 = extract t6 #2                                                  int
	t10 = extract t6 #3                                                bool
	t11 = extract t6 #4                                                bool
	if t5 goto 5 else 4
1:                                                          switch.body P:1 S:0
	return 9218868437227405313:uint64
2:                                                          switch.body P:1 S:0
	t12 = f ^ t7                                                     uint64
	return t12
3:                                                          switch.next P:1 S:2
	if t4 goto 8 else 9
4:                                                            binop.rhs P:1 S:1
	jump 5
5:                                                           binop.done P:2 S:2
	t13 = phi [0: true:bool, 4: t11] #||                               bool
	if t13 goto 1 else 3
6:                                                          switch.body P:2 S:0
	return 9218868437227405313:uint64
7:                                                          switch.next P:1 S:2
	if t4 goto 12 else 13
8:                                                            binop.rhs P:1 S:1
	jump 9
9:                                                           binop.done P:2 S:2
	t14 = phi [3: false:bool, 8: t10] #&&                              bool
	if t14 goto 2 else 7
10:                                                         switch.body P:1 S:0
	t15 = f ^ t7                                                     uint64
	return t15
11:                                                         switch.next P:1 S:2
	t16 = t2 == 0:uint64                                               bool
	if t16 goto 15 else 16
12:                                                           binop.rhs P:1 S:1
	t17 = t8 == 0:uint64                                               bool
	jump 13
13:                                                          binop.done P:2 S:2
	t18 = phi [7: false:bool, 12: t17] #&&                             bool
	if t18 goto 6 else 11
14:                                                         switch.next P:1 S:2
	t19 = t2 == 0:uint64                                               bool
	if t19 goto 10 else 18
15:                                                           binop.rhs P:1 S:1
	jump 16
16:                                                          binop.done P:2 S:2
	t20 = phi [11: false:bool, 15: t10] #&&                            bool
	if t20 goto 6 else 14
17:                                                         switch.body P:1 S:0
	t21 = g ^ t1                                                     uint64
	return t21
18:                                                         switch.next P:1 S:2
	t22 = t8 == 0:uint64                                               bool
	if t22 goto 17 else 19
19:                                                         switch.next P:1 S:0
	t23 = mullu(t2, t8)                              (lo uint64, hi uint64)
	t24 = extract t23 #0                                             uint64
	t25 = extract t23 #1                                             uint64
	t26 = 1:uint64 << 51:uint                                        uint64
	t27 = t26 - 1:uint64                                             uint64
	t28 = t24 & t27                                                  uint64
	t29 = 64:uint - 51:uint                                            uint
	t30 = t25 << t29                                                 uint64
	t31 = t24 >> 51:uint                                             uint64
	t32 = t30 | t31                                                  uint64
	t33 = t1 ^ t7                                                    uint64
	t34 = t3 + t9                                                       int
	t35 = t34 - 1:int                                                   int
	t36 = fpack64(t33, t32, t35, t28)                                uint64
	return t36

# Name: runtime.fdiv64
# Package: runtime
# Location: /usr/local/go/src/runtime/softfloat64.go:288:6
func fdiv64(f uint64, g uint64) uint64:
0:                                                                entry P:0 S:2
	t0 = funpack64(f) (sign uint64, mant uint64, exp int, inf bool, nan bool)
	t1 = extract t0 #0                                               uint64
	t2 = extract t0 #1                                               uint64
	t3 = extract t0 #2                                                  int
	t4 = extract t0 #3                                                 bool
	t5 = extract t0 #4                                                 bool
	t6 = funpack64(g) (sign uint64, mant uint64, exp int, inf bool, nan bool)
	t7 = extract t6 #0                                               uint64
	t8 = extract t6 #1                                               uint64
	t9 = extract t6 #2                                                  int
	t10 = extract t6 #3                                                bool
	t11 = extract t6 #4                                                bool
	if t5 goto 5 else 4
1:                                                          switch.body P:1 S:0
	return 9218868437227405313:uint64
2:                                                          switch.body P:1 S:0
	return 9218868437227405313:uint64
3:                                                          switch.next P:1 S:2
	if t4 goto 8 else 9
4:                                                            binop.rhs P:1 S:1
	jump 5
5:                                                           binop.done P:2 S:2
	t12 = phi [0: true:bool, 4: t11] #||                               bool
	if t12 goto 1 else 3
6:                                                          switch.body P:1 S:0
	return 9218868437227405313:uint64
7:                                                          switch.next P:1 S:2
	if t4 goto 13 else 15
8:                                                            binop.rhs P:1 S:1
	jump 9
9:                                                           binop.done P:2 S:2
	t13 = phi [3: false:bool, 8: t10] #&&                              bool
	if t13 goto 2 else 7
10:                                                         switch.body P:2 S:0
	t14 = t1 ^ t7                                                    uint64
	t15 = t14 ^ 9218868437227405312:uint64                           uint64
	return t15
11:                                                         switch.next P:1 S:2
	if t4 goto 10 else 17
12:                                                           binop.rhs P:1 S:1
	t16 = t8 == 0:uint64                                               bool
	jump 13
13:                                                          binop.done P:4 S:2
	t17 = phi [7: false:bool, 15: false:bool, 14: false:bool, 12: t16] #&& bool
	if t17 goto 6 else 11
14:                                                           cond.true P:1 S:2
	t18 = t2 == 0:uint64                                               bool
	if t18 goto 12 else 13
15:                                                           cond.true P:1 S:2
	if t10 goto 13 else 14
16:                                                         switch.body P:2 S:0
	t19 = t1 ^ t7                                                    uint64
	t20 = t19 ^ 0:uint64                                             uint64
	return t20
17:                                                         switch.next P:1 S:2
	if t10 goto 20 else 19
18:                                                         switch.next P:1 S:2
	if t10 goto 16 else 21
19:                                                           binop.rhs P:1 S:1
	t21 = t8 == 0:uint64                                               bool
	jump 20
20:                                                          binop.done P:2 S:2
	t22 = phi [17: false:bool, 19: t21] #&&                            bool
	if t22 goto 10 else 18
21:                                                         switch.next P:1 S:2
	t23 = t2 == 0:uint64                                               bool
	if t23 goto 16 else 22
22:                                                         switch.next P:1 S:0
	t24 = 64:uint - 54:uint                                            uint
	t25 = t2 >> t24                                                  uint64
	t26 = t2 << 54:uint                                              uint64
	t27 = divlu(t25, t26, t8)                          (q uint64, r uint64)
	t28 = extract t27 #0                                             uint64
	t29 = extract t27 #1                                             uint64
	t30 = t1 ^ t7                                                    uint64
	t31 = t3 - t9                                                       int
	t32 = t31 - 2:int                                                   int
	t33 = fpack64(t30, t28, t32, t29)                                uint64
	return t33

# Name: runtime.f64to32
# Package: runtime
# Location: /usr/local/go/src/runtime/softfloat64.go:317:6
func f64to32(f uint64) uint32:
0:                                                                entry P:0 S:2
	t0 = funpack64(f) (sign uint64, mant uint64, exp int, inf bool, nan bool)
	t1 = extract t0 #0                                               uint64
	t2 = extract t0 #1                                               uint64
	t3 = extract t0 #2                                                  int
	t4 = extract t0 #3                                                 bool
	t5 = extract t0 #4                                                 bool
	if t5 goto 1 else 2
1:                                                              if.then P:1 S:0
	return 2139095041:uint32
2:                                                              if.done P:1 S:2
	t6 = t1 >> 32:uint64                                             uint64
	t7 = convert uint32 <- uint64 (t6)                               uint32
	if t4 goto 3 else 4
3:                                                              if.then P:1 S:0
	t8 = t7 ^ 2139095040:uint32                                      uint32
	return t8
4:                                                              if.done P:1 S:0
	t9 = t2 >> 28:uint                                               uint64
	t10 = convert uint32 <- uint64 (t9)                              uint32
	t11 = t3 - 1:int                                                    int
	t12 = t2 & 268435455:uint64                                      uint64
	t13 = convert uint32 <- uint64 (t12)                             uint32
	t14 = fpack32(t7, t10, t11, t13)                                 uint32
	return t14

# Name: runtime.f32to64
# Package: runtime
# Location: /usr/local/go/src/runtime/softfloat64.go:330:6
func f32to64(f uint32) uint64:
0:                                                                entry P:0 S:2
	t0 = funpack32(f) (sign uint32, mant uint32, exp int, inf bool, nan bool)
	t1 = extract t0 #0                                               uint32
	t2 = extract t0 #1                                               uint32
	t3 = extract t0 #2                                                  int
	t4 = extract t0 #3                                                 bool
	t5 = extract t0 #4                                                 bool
	if t5 goto 1 else 2
1:                                                              if.then P:1 S:0
	return 9218868437227405313:uint64
2:                                                              if.done P:1 S:2
	t6 = convert uint64 <- uint32 (t1)                               uint64
	t7 = t6 << 32:uint64                                             uint64
	if t4 goto 3 else 4
3:                                                              if.then P:1 S:0
	t8 = t7 ^ 9218868437227405312:uint64                             uint64
	return t8
4:                                                              if.done P:1 S:0
	t9 = convert uint64 <- uint32 (t2)                               uint64
	t10 = t9 << 29:uint                                              uint64
	t11 = fpack64(t7, t10, t3, 0:uint64)                             uint64
	return t11

# Name: runtime.fcmp64
# Package: runtime
# Location: /usr/local/go/src/runtime/softfloat64.go:343:6
func fcmp64(f uint64, g uint64) (cmp int, isnan bool):
0:                                                                entry P:0 S:2
	t0 = funpack64(f) (sign uint64, mant uint64, exp int, inf bool, nan bool)
	t1 = extract t0 #0                                               uint64
	t2 = extract t0 #1                                               uint64
	t3 = extract t0 #2                                                  int
	t4 = extract t0 #3                                                 bool
	t5 = extract t0 #4                                                 bool
	t6 = funpack64(g) (sign uint64, mant uint64, exp int, inf bool, nan bool)
	t7 = extract t6 #0                                               uint64
	t8 = extract t6 #1                                               uint64
	t9 = extract t6 #2                                                  int
	t10 = extract t6 #3                                                bool
	t11 = extract t6 #4                                                bool
	if t5 goto 1 else 3
1:                                                          switch.body P:2 S:0
	return 0:int, true:bool
2:                                                          switch.body P:1 S:0
	return 0:int, false:bool
3:                                                          switch.next P:1 S:2
	if t11 goto 1 else 4
4:                                                          switch.next P:1 S:2
	if t4 goto 8 else 10
5:                                                          switch.body P:1 S:0
	return -1:int, false:bool
6:                                                          switch.next P:1 S:2
	t12 = t1 > t7                                                      bool
	if t12 goto 5 else 12
7:                                                            binop.rhs P:1 S:1
	t13 = t8 == 0:uint64                                               bool
	jump 8
8:                                                           binop.done P:4 S:2
	t14 = phi [4: false:bool, 10: false:bool, 9: false:bool, 7: t13] #&& bool
	if t14 goto 2 else 6
9:                                                            cond.true P:1 S:2
	t15 = t2 == 0:uint64                                               bool
	if t15 goto 7 else 8
10:                                                           cond.true P:1 S:2
	if t10 goto 8 else 9
11:                                                         switch.body P:1 S:0
	return 1:int, false:bool
12:                                                         switch.next P:1 S:2
	t16 = t1 < t7                                                      bool
	if t16 goto 11 else 14
13:                                                         switch.body P:2 S:0
	return -1:int, false:bool
14:                                                         switch.next P:1 S:2
	t17 = t1 == 0:uint64                                               bool
	if t17 goto 17 else 18
15:                                                         switch.body P:2 S:0
	return 1:int, false:bool
16:                                                         switch.next P:1 S:2
	t18 = t1 != 0:uint64                                               bool
	if t18 goto 20 else 21
17:                                                           binop.rhs P:1 S:1
	t19 = f < g                                                        bool
	jump 18
18:                                                          binop.done P:2 S:2
	t20 = phi [14: false:bool, 17: t19] #&&                            bool
	if t20 goto 13 else 16
19:                                                         switch.next P:1 S:2
	t21 = t1 == 0:uint64                                               bool
	if t21 goto 23 else 24
20:                                                           binop.rhs P:1 S:1
	t22 = f > g                                                        bool
	jump 21
21:                                                          binop.done P:2 S:2
	t23 = phi [16: false:bool, 20: t22] #&&                            bool
	if t23 goto 13 else 19
22:                                                         switch.next P:1 S:2
	t24 = t1 != 0:uint64                                               bool
	if t24 goto 26 else 27
23:                                                           binop.rhs P:1 S:1
	t25 = f > g                                                        bool
	jump 24
24:                                                          binop.done P:2 S:2
	t26 = phi [19: false:bool, 23: t25] #&&                            bool
	if t26 goto 15 else 22
25:                                                         switch.next P:1 S:0
	return 0:int, false:bool
26:                                                           binop.rhs P:1 S:1
	t27 = f < g                                                        bool
	jump 27
27:                                                          binop.done P:2 S:2
	t28 = phi [22: false:bool, 26: t27] #&&                            bool
	if t28 goto 15 else 25

# Name: runtime.f64toint
# Package: runtime
# Location: /usr/local/go/src/runtime/softfloat64.go:374:6
func f64toint(f uint64) (val int64, ok bool):
0:                                                                entry P:0 S:2
	t0 = funpack64(f) (sign uint64, mant uint64, exp int, inf bool, nan bool)
	t1 = extract t0 #0                                               uint64
	t2 = extract t0 #1                                               uint64
	t3 = extract t0 #2                                                  int
	t4 = extract t0 #3                                                 bool
	t5 = extract t0 #4                                                 bool
	if t4 goto 1 else 3
1:                                                          switch.body P:2 S:0
	return 0:int64, false:bool
2:                                                          switch.body P:1 S:0
	return 0:int64, false:bool
3:                                                          switch.next P:1 S:2
	if t5 goto 1 else 4
4:                                                          switch.next P:1 S:2
	t6 = t3 < -1:int                                                   bool
	if t6 goto 2 else 6
5:                                                          switch.body P:1 S:2
	t7 = t1 != 0:uint64                                                bool
	if t7 goto 9 else 8
6:                                                          switch.next P:1 S:2
	t8 = t3 > 63:int                                                   bool
	if t8 goto 5 else 13
7:                                                              if.then P:1 S:0
	return -9223372036854775808:int64, true:bool
8:                                                              if.done P:2 S:2
	t9 = t1 != 0:uint64                                                bool
	if t9 goto 10 else 11
9:                                                            cond.true P:1 S:2
	t10 = t2 == 0:uint64                                               bool
	if t10 goto 7 else 8
10:                                                             if.then P:1 S:0
	return 0:int64, false:bool
11:                                                             if.done P:1 S:0
	return 0:int64, false:bool
12:                                                            for.body P:1 S:1
	t11 = t14 - 1:int                                                   int
	t12 = t13 << 1:uint64                                            uint64
	jump 13
13:                                                            for.loop P:2 S:2
	t13 = phi [6: t2, 12: t12] #fm                                   uint64
	t14 = phi [6: t3, 12: t11] #fe                                      int
	t15 = t14 > 52:int                                                 bool
	if t15 goto 12 else 16
14:                                                            for.body P:1 S:1
	t16 = t21 + 1:int                                                   int
	t17 = t20 >> 1:uint64                                            uint64
	jump 16
15:                                                            for.done P:1 S:2
	t18 = convert int64 <- uint64 (t20)                               int64
	t19 = t1 != 0:uint64                                               bool
	if t19 goto 17 else 18
16:                                                            for.loop P:2 S:2
	t20 = phi [13: t13, 14: t17] #fm                                 uint64
	t21 = phi [13: t14, 14: t16] #fe                                    int
	t22 = t21 < 52:int                                                 bool
	if t22 goto 14 else 15
17:                                                             if.then P:1 S:1
	t23 = -t18                                                        int64
	jump 18
18:                                                             if.done P:2 S:0
	t24 = phi [15: t18, 17: t23] #val                                 int64
	return t24, true:bool

# Name: runtime.fintto64
# Package: runtime
# Location: /usr/local/go/src/runtime/softfloat64.go:409:6
func fintto64(val int64) (f uint64):
0:                                                                entry P:0 S:2
	t0 = convert uint64 <- int64 (val)                               uint64
	t1 = t0 & 9223372036854775808:uint64                             uint64
	t2 = convert uint64 <- int64 (val)                               uint64
	t3 = t1 != 0:uint64                                                bool
	if t3 goto 1 else 2
1:                                                              if.then P:1 S:1
	t4 = -t2                                                         uint64
	jump 2
2:                                                              if.done P:2 S:0
	t5 = phi [0: t2, 1: t4] #mant                                    uint64
	t6 = fpack64(t1, t5, 52:int, 0:uint64)                           uint64
	return t6

# Name: runtime.mullu
# Package: runtime
# Location: /usr/local/go/src/runtime/softfloat64.go:420:6
func mullu(u uint64, v uint64) (lo uint64, hi uint64):
0:                                                                entry P:0 S:0
	t0 = u & 4294967295:uint64                                       uint64
	t1 = u >> 32:uint64                                              uint64
	t2 = v & 4294967295:uint64                                       uint64
	t3 = v >> 32:uint64                                              uint64
	t4 = t0 * t2                                                     uint64
	t5 = t1 * t2                                                     uint64
	t6 = t4 >> 32:uint64                                             uint64
	t7 = t5 + t6                                                     uint64
	t8 = t7 & 4294967295:uint64                                      uint64
	t9 = t7 >> 32:uint64                                             uint64
	t10 = t0 * t3                                                    uint64
	t11 = t8 + t10                                                   uint64
	t12 = u * v                                                      uint64
	t13 = t1 * t3                                                    uint64
	t14 = t13 + t9                                                   uint64
	t15 = t11 >> 32:uint64                                           uint64
	t16 = t14 + t15                                                  uint64
	return t12, t16

# Name: runtime.divlu
# Package: runtime
# Location: /usr/local/go/src/runtime/softfloat64.go:439:6
func divlu(u1 uint64, u0 uint64, v uint64) (q uint64, r uint64):
0:                                                                entry P:0 S:2
	t0 = u1 >= v                                                       bool
	if t0 goto 1 else 2
1:                                                              if.then P:1 S:0
	return 18446744073709551615:uint64, 18446744073709551615:uint64
2:                                                              if.done P:1 S:1
	jump 5
3:                                                             for.body P:1 S:1
	t1 = t16 + 1:uint                                                  uint
	t2 = t15 << 1:uint64                                             uint64
	jump 5
4:                                                             for.done P:1 S:1
	t3 = t15 >> 32:uint64                                            uint64
	t4 = t15 & 4294967295:uint64                                     uint64
	t5 = u1 << t16                                                   uint64
	t6 = 64:uint - t16                                                 uint
	t7 = u0 >> t6                                                    uint64
	t8 = t5 | t7                                                     uint64
	t9 = u0 << t16                                                   uint64
	t10 = t9 >> 32:uint64                                            uint64
	t11 = t9 & 4294967295:uint64                                     uint64
	t12 = t8 / t3                                                    uint64
	t13 = t12 * t3                                                   uint64
	t14 = t8 - t13                                                   uint64
	jump 6
5:                                                             for.loop P:2 S:2
	t15 = phi [2: v, 3: t2] #v                                       uint64
	t16 = phi [2: 0:uint, 3: t1] #s                                    uint
	t17 = t15 & 9223372036854775808:uint64                           uint64
	t18 = t17 == 0:uint64                                              bool
	if t18 goto 3 else 4
6:                                                               again1 P:2 S:2
	t19 = phi [4: t12, 7: t22] #q1                                   uint64
	t20 = phi [4: t14, 7: t23] #rhat                                 uint64
	t21 = t19 >= 4294967296:uint64                                     bool
	if t21 goto 7 else 9
7:                                                              if.then P:2 S:2
	t22 = t19 - 1:uint64                                             uint64
	t23 = t20 + t3                                                   uint64
	t24 = t23 < 4294967296:uint64                                      bool
	if t24 goto 6 else 8
8:                                                              if.done P:2 S:1
	t25 = phi [9: t19, 7: t22] #q1                                   uint64
	t26 = t8 * 4294967296:uint64                                     uint64
	t27 = t26 + t10                                                  uint64
	t28 = t25 * t15                                                  uint64
	t29 = t27 - t28                                                  uint64
	t30 = t29 / t3                                                   uint64
	t31 = t30 * t3                                                   uint64
	t32 = t29 - t31                                                  uint64
	jump 10
9:                                                           cond.false P:1 S:2
	t33 = t19 * t4                                                   uint64
	t34 = 4294967296:uint64 * t20                                    uint64
	t35 = t34 + t10                                                  uint64
	t36 = t33 > t35                                                    bool
	if t36 goto 7 else 8
10:                                                              again2 P:2 S:2
	t37 = phi [8: t32, 11: t41] #rhat                                uint64
	t38 = phi [8: t30, 11: t40] #q0                                  uint64
	t39 = t38 >= 4294967296:uint64                                     bool
	if t39 goto 11 else 13
11:                                                             if.then P:2 S:2
	t40 = t38 - 1:uint64                                             uint64
	t41 = t37 + t3                                                   uint64
	t42 = t41 < 4294967296:uint64                                      bool
	if t42 goto 10 else 12
12:                                                             if.done P:2 S:0
	t43 = phi [13: t38, 11: t40] #q0                                 uint64
	t44 = t25 * 4294967296:uint64                                    uint64
	t45 = t44 + t43                                                  uint64
	t46 = t29 * 4294967296:uint64                                    uint64
	t47 = t46 + t11                                                  uint64
	t48 = t43 * t15                                                  uint64
	t49 = t47 - t48                                                  uint64
	t50 = t49 >> t16                                                 uint64
	return t45, t50
13:                                                          cond.false P:1 S:2
	t51 = t38 * t4                                                   uint64
	t52 = 4294967296:uint64 * t37                                    uint64
	t53 = t52 + t11                                                  uint64
	t54 = t51 > t53                                                    bool
	if t54 goto 11 else 12

# Name: runtime.fadd64c
# Package: runtime
# Location: /usr/local/go/src/runtime/softfloat64.go:489:6
func fadd64c(f uint64, g uint64, ret *uint64):
0:                                                                entry P:0 S:0
	t0 = fadd64(f, g)                                                uint64
	*ret = t0
	return

# Name: runtime.fsub64c
# Package: runtime
# Location: /usr/local/go/src/runtime/softfloat64.go:490:6
func fsub64c(f uint64, g uint64, ret *uint64):
0:                                                                entry P:0 S:0
	t0 = fsub64(f, g)                                                uint64
	*ret = t0
	return

# Name: runtime.fmul64c
# Package: runtime
# Location: /usr/local/go/src/runtime/softfloat64.go:491:6
func fmul64c(f uint64, g uint64, ret *uint64):
0:                                                                entry P:0 S:0
	t0 = fmul64(f, g)                                                uint64
	*ret = t0
	return

# Name: runtime.fdiv64c
# Package: runtime
# Location: /usr/local/go/src/runtime/softfloat64.go:492:6
func fdiv64c(f uint64, g uint64, ret *uint64):
0:                                                                entry P:0 S:0
	t0 = fdiv64(f, g)                                                uint64
	*ret = t0
	return

# Name: runtime.fneg64c
# Package: runtime
# Location: /usr/local/go/src/runtime/softfloat64.go:493:6
func fneg64c(f uint64, ret *uint64):
0:                                                                entry P:0 S:0
	t0 = fneg64(f)                                                   uint64
	*ret = t0
	return

# Name: runtime.f32to64c
# Package: runtime
# Location: /usr/local/go/src/runtime/softfloat64.go:494:6
func f32to64c(f uint32, ret *uint64):
0:                                                                entry P:0 S:0
	t0 = f32to64(f)                                                  uint64
	*ret = t0
	return

# Name: runtime.f64to32c
# Package: runtime
# Location: /usr/local/go/src/runtime/softfloat64.go:495:6
func f64to32c(f uint64, ret *uint32):
0:                                                                entry P:0 S:0
	t0 = f64to32(f)                                                  uint32
	*ret = t0
	return

# Name: runtime.fcmp64c
# Package: runtime
# Location: /usr/local/go/src/runtime/softfloat64.go:496:6
func fcmp64c(f uint64, g uint64, ret *int, retnan *bool):
0:                                                                entry P:0 S:0
	t0 = fcmp64(f, g)                                 (cmp int, isnan bool)
	t1 = extract t0 #0                                                  int
	*ret = t1
	t2 = extract t0 #1                                                 bool
	*retnan = t2
	return

# Name: runtime.fintto64c
# Package: runtime
# Location: /usr/local/go/src/runtime/softfloat64.go:497:6
func fintto64c(val int64, ret *uint64):
0:                                                                entry P:0 S:0
	t0 = fintto64(val)                                               uint64
	*ret = t0
	return

# Name: runtime.f64tointc
# Package: runtime
# Location: /usr/local/go/src/runtime/softfloat64.go:498:6
func f64tointc(f uint64, ret *int64, retok *bool):
0:                                                                entry P:0 S:0
	t0 = f64toint(f)                                   (val int64, ok bool)
	t1 = extract t0 #0                                                int64
	*ret = t1
	t2 = extract t0 #1                                                 bool
	*retok = t2
	return

# Name: runtime.float64bits
# Package: runtime
# Location: /usr/local/go/src/runtime/sqrt.go:98:6
func float64bits(f float64) uint64:
0:                                                                entry P:0 S:0
	t0 = new float64 (f)                                           *float64
	*t0 = f
	t1 = convert unsafe.Pointer <- *float64 (t0)             unsafe.Pointer
	t2 = convert *uint64 <- unsafe.Pointer (t1)                     *uint64
	t3 = *t2                                                         uint64
	return t3

# Name: runtime.float64frombits
# Package: runtime
# Location: /usr/local/go/src/runtime/sqrt.go:99:6
func float64frombits(b uint64) float64:
0:                                                                entry P:0 S:0
	t0 = new uint64 (b)                                             *uint64
	*t0 = b
	t1 = convert unsafe.Pointer <- *uint64 (t0)              unsafe.Pointer
	t2 = convert *float64 <- unsafe.Pointer (t1)                   *float64
	t3 = *t2                                                        float64
	return t3

# Name: runtime.sqrt
# Package: runtime
# Location: /usr/local/go/src/runtime/sqrt.go:101:6
func sqrt(x float64) float64:
0:                                                                entry P:0 S:2
	t0 = x == 0:float64                                                bool
	if t0 goto 5 else 6
1:                                                          switch.body P:1 S:0
	return x
2:                                                          switch.body P:1 S:0
	t1 = *nan                                                       float64
	return t1
3:                                                          switch.next P:1 S:2
	t2 = x < 0:float64                                                 bool
	if t2 goto 2 else 7
4:                                                            binop.rhs P:1 S:1
	t3 = x > 179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368:float64 bool
	jump 5
5:                                                           binop.done P:3 S:2
	t4 = phi [0: true:bool, 6: true:bool, 4: t3] #||                   bool
	if t4 goto 1 else 3
6:                                                           cond.false P:1 S:2
	t5 = x != x                                                        bool
	if t5 goto 5 else 4
7:                                                          switch.next P:1 S:2
	t6 = float64bits(x)                                              uint64
	t7 = t6 >> 52:uint64                                             uint64
	t8 = t7 & 2047:uint64                                            uint64
	t9 = convert int <- uint64 (t8)                                     int
	t10 = t9 == 0:int                                                  bool
	if t10 goto 11 else 8
8:                                                              if.done P:2 S:2
	t11 = phi [7: t6, 10: t21] #ix                                   uint64
	t12 = phi [7: t9, 10: t20] #exp                                     int
	t13 = t12 - 1023:int                                                int
	t14 = t11 &^ 9218868437227405312:uint64                          uint64
	t15 = t14 | 4503599627370496:uint64                              uint64
	t16 = t13 & 1:int                                                   int
	t17 = t16 == 1:int                                                 bool
	if t17 goto 12 else 13
9:                                                             for.body P:1 S:1
	t18 = t21 << 1:uint64                                            uint64
	t19 = t22 - 1:int                                                   int
	jump 11
10:                                                            for.done P:1 S:1
	t20 = t22 + 1:int                                                   int
	jump 8
11:                                                            for.loop P:2 S:2
	t21 = phi [7: t6, 9: t18] #ix                                    uint64
	t22 = phi [7: t9, 9: t19] #exp                                      int
	t23 = t21 & 1:uint64                                             uint64
	t24 = t23 << 52:uint64                                           uint64
	t25 = t24 == 0:uint64                                              bool
	if t25 goto 9 else 10
12:                                                             if.then P:1 S:1
	t26 = t15 << 1:uint64                                            uint64
	jump 13
13:                                                             if.done P:2 S:1
	t27 = phi [8: t15, 12: t26] #ix                                  uint64
	t28 = t13 >> 1:uint64                                               int
	t29 = t27 << 1:uint64                                            uint64
	jump 16
14:                                                            for.body P:1 S:2
	t30 = t35 + t36                                                  uint64
	t31 = t30 <= t33                                                   bool
	if t31 goto 17 else 18
15:                                                            for.done P:1 S:2
	t32 = t33 != 0:uint64                                              bool
	if t32 goto 19 else 20
16:                                                            for.loop P:2 S:2
	t33 = phi [13: t29, 18: t44] #ix                                 uint64
	t34 = phi [13: 0:uint64, 18: t42] #q                             uint64
	t35 = phi [13: 0:uint64, 18: t43] #s                             uint64
	t36 = phi [13: 9007199254740992:uint64, 18: t45] #r              uint64
	t37 = t36 != 0:uint64                                              bool
	if t37 goto 14 else 15
17:                                                             if.then P:1 S:1
	t38 = t30 + t36                                                  uint64
	t39 = t33 - t30                                                  uint64
	t40 = t34 + t36                                                  uint64
	jump 18
18:                                                             if.done P:2 S:1
	t41 = phi [14: t33, 17: t39] #ix                                 uint64
	t42 = phi [14: t34, 17: t40] #q                                  uint64
	t43 = phi [14: t35, 17: t38] #s                                  uint64
	t44 = t41 << 1:uint64                                            uint64
	t45 = t36 >> 1:uint64                                            uint64
	jump 16
19:                                                             if.then P:1 S:1
	t46 = t34 & 1:uint64                                             uint64
	t47 = t34 + t46                                                  uint64
	jump 20
20:                                                             if.done P:2 S:0
	t48 = phi [15: t34, 19: t47] #q                                  uint64
	t49 = t48 >> 1:uint64                                            uint64
	t50 = t28 - 1:int                                                   int
	t51 = t50 + 1023:int                                                int
	t52 = convert uint64 <- int (t51)                                uint64
	t53 = t52 << 52:uint64                                           uint64
	t54 = t49 + t53                                                  uint64
	t55 = float64frombits(t54)                                      float64
	return t55

# Name: runtime.sqrtC
# Package: runtime
# Location: /usr/local/go/src/runtime/sqrt.go:148:6
func sqrtC(f float64, r *float64):
0:                                                                entry P:0 S:0
	t0 = sqrt(f)                                                    float64
	*r = t0
	return

# Name: runtime.concatstrings
# Package: runtime
# Location: /usr/local/go/src/runtime/string.go:11:6
func concatstrings(a []string) string:
0:                                                                entry P:0 S:1
	t0 = len(a)                                                         int
	jump 1
1:                                                      rangeindex.loop P:3 S:2
	t1 = phi [0: 0:int, 2: t1, 6: t5] #idx                              int
	t2 = phi [0: 0:int, 2: t2, 6: t15] #l                               int
	t3 = phi [0: 0:int, 2: t3, 6: t16] #count                           int
	t4 = phi [0: -1:int, 2: t5, 6: t5]                                  int
	t5 = t4 + 1:int                                                     int
	t6 = t5 < t0                                                       bool
	if t6 goto 2 else 3
2:                                                      rangeindex.body P:1 S:2
	t7 = &a[t5]                                                     *string
	t8 = *t7                                                         string
	t9 = len(t8)                                                        int
	t10 = t9 == 0:int                                                  bool
	if t10 goto 1 else 4
3:                                                      rangeindex.done P:1 S:2
	t11 = t3 == 0:int                                                  bool
	if t11 goto 7 else 8
4:                                                              if.done P:1 S:2
	t12 = t2 + t9                                                       int
	t13 = t12 < t2                                                     bool
	if t13 goto 5 else 6
5:                                                              if.then P:1 S:1
	t14 = gothrow("string concatenat...":string)                         ()
	jump 6
6:                                                              if.done P:2 S:1
	t15 = t2 + t9                                                       int
	t16 = t3 + 1:int                                                    int
	jump 1
7:                                                              if.then P:1 S:0
	return "":string
8:                                                              if.done P:1 S:2
	t17 = t3 == 1:int                                                  bool
	if t17 goto 9 else 10
9:                                                              if.then P:1 S:0
	t18 = &a[t1]                                                    *string
	t19 = *t18                                                       string
	return t19
10:                                                             if.done P:1 S:1
	t20 = rawstring(t2)                                (s string, b []byte)
	t21 = extract t20 #0                                             string
	t22 = extract t20 #1                                             []byte
	t23 = len(a)                                                        int
	jump 11
11:                                                     rangeindex.loop P:2 S:2
	t24 = phi [10: 0:int, 12: t33] #l                                   int
	t25 = phi [10: -1:int, 12: t26]                                     int
	t26 = t25 + 1:int                                                   int
	t27 = t26 < t23                                                    bool
	if t27 goto 12 else 13
12:                                                     rangeindex.body P:1 S:1
	t28 = &a[t26]                                                   *string
	t29 = *t28                                                       string
	t30 = slice t22[t24:]                                            []byte
	t31 = copy(t30, t29)                                                int
	t32 = len(t29)                                                      int
	t33 = t24 + t32                                                     int
	jump 11
13:                                                     rangeindex.done P:1 S:0
	return t21

# Name: runtime.concatstring2
# Package: runtime
# Location: /usr/local/go/src/runtime/string.go:43:6
func concatstring2(a [2]string) string:
0:                                                                entry P:0 S:0
	t0 = new [2]string (a)                                       *[2]string
	*t0 = a
	t1 = slice t0[:]                                               []string
	t2 = concatstrings(t1)                                           string
	return t2

# Name: runtime.concatstring3
# Package: runtime
# Location: /usr/local/go/src/runtime/string.go:48:6
func concatstring3(a [3]string) string:
0:                                                                entry P:0 S:0
	t0 = new [3]string (a)                                       *[3]string
	*t0 = a
	t1 = slice t0[:]                                               []string
	t2 = concatstrings(t1)                                           string
	return t2

# Name: runtime.concatstring4
# Package: runtime
# Location: /usr/local/go/src/runtime/string.go:53:6
func concatstring4(a [4]string) string:
0:                                                                entry P:0 S:0
	t0 = new [4]string (a)                                       *[4]string
	*t0 = a
	t1 = slice t0[:]                                               []string
	t2 = concatstrings(t1)                                           string
	return t2

# Name: runtime.concatstring5
# Package: runtime
# Location: /usr/local/go/src/runtime/string.go:58:6
func concatstring5(a [5]string) string:
0:                                                                entry P:0 S:0
	t0 = new [5]string (a)                                       *[5]string
	*t0 = a
	t1 = slice t0[:]                                               []string
	t2 = concatstrings(t1)                                           string
	return t2

# Name: runtime.slicebytetostring
# Package: runtime
# Location: /usr/local/go/src/runtime/string.go:62:6
func slicebytetostring(b []byte) string:
0:                                                                entry P:0 S:2
	t0 = new []byte (b)                                             *[]byte
	*t0 = b
	if false:untyped bool goto 3 else 2
1:                                                              if.then P:1 S:1
	t1 = *t0                                                         []byte
	t2 = &t1[0:int]                                                   *byte
	t3 = convert unsafe.Pointer <- *byte (t2)                unsafe.Pointer
	t4 = *t0                                                         []byte
	t5 = len(t4)                                                        int
	t6 = convert uintptr <- int (t5)                                uintptr
	t7 = convert unsafe.Pointer <- *[]byte (t0)              unsafe.Pointer
	t8 = getcallerpc(t7)                                            uintptr
	t9 = make interface{} <- func(b []byte) string (slicebytetostring) interface{}
	t10 = funcPC(t9)                                                uintptr
	t11 = racereadrangepc(t3, t6, t8, t10)                               ()
	jump 2
2:                                                              if.done P:3 S:0
	t12 = *t0                                                        []byte
	t13 = len(t12)                                                      int
	t14 = rawstring(t13)                               (s string, b []byte)
	t15 = extract t14 #0                                             string
	t16 = extract t14 #1                                             []byte
	t17 = *t0                                                        []byte
	t18 = copy(t16, t17)                                                int
	return t15
3:                                                            cond.true P:1 S:2
	t19 = *t0                                                        []byte
	t20 = len(t19)                                                      int
	t21 = t20 > 0:int                                                  bool
	if t21 goto 1 else 2

# Name: runtime.slicebytetostringtmp
# Package: runtime
# Location: /usr/local/go/src/runtime/string.go:74:6
func slicebytetostringtmp(b []byte) string:
0:                                                                entry P:0 S:2
	t0 = new []byte (b)                                             *[]byte
	*t0 = b
	if false:untyped bool goto 3 else 2
1:                                                              if.then P:1 S:1
	t1 = *t0                                                         []byte
	t2 = &t1[0:int]                                                   *byte
	t3 = convert unsafe.Pointer <- *byte (t2)                unsafe.Pointer
	t4 = *t0                                                         []byte
	t5 = len(t4)                                                        int
	t6 = convert uintptr <- int (t5)                                uintptr
	t7 = convert unsafe.Pointer <- *[]byte (t0)              unsafe.Pointer
	t8 = getcallerpc(t7)                                            uintptr
	t9 = make interface{} <- func(b []byte) string (slicebytetostringtmp) interface{}
	t10 = funcPC(t9)                                                uintptr
	t11 = racereadrangepc(t3, t6, t8, t10)                               ()
	jump 2
2:                                                              if.done P:3 S:0
	t12 = convert unsafe.Pointer <- *[]byte (t0)             unsafe.Pointer
	t13 = convert *string <- unsafe.Pointer (t12)                   *string
	t14 = *t13                                                       string
	return t14
3:                                                            cond.true P:1 S:2
	t15 = *t0                                                        []byte
	t16 = len(t15)                                                      int
	t17 = t16 > 0:int                                                  bool
	if t17 goto 1 else 2

# Name: runtime.stringtoslicebyte
# Package: runtime
# Location: /usr/local/go/src/runtime/string.go:92:6
func stringtoslicebyte(s string) []byte:
0:                                                                entry P:0 S:0
	t0 = len(s)                                                         int
	t1 = rawbyteslice(t0)                                            []byte
	t2 = copy(t1, s)                                                    int
	return t1

# Name: runtime.stringtoslicerune
# Package: runtime
# Location: /usr/local/go/src/runtime/string.go:98:6
func stringtoslicerune(s string) []rune:
0:                                                                entry P:0 S:1
	jump 3
1:                                                             for.body P:1 S:1
	t0 = charntorune(t6)                                        (rune, int)
	t1 = extract t0 #0                                                 rune
	t2 = extract t0 #1                                                  int
	t3 = slice t6[t2:]                                               string
	t4 = t7 + 1:int                                                     int
	jump 3
2:                                                             for.done P:1 S:1
	t5 = rawruneslice(t7)                                            []rune
	jump 6
3:                                                             for.loop P:2 S:2
	t6 = phi [0: s, 1: t3] #s                                        string
	t7 = phi [0: 0:int, 1: t4] #n                                       int
	t8 = len(t6)                                                        int
	t9 = t8 > 0:int                                                    bool
	if t9 goto 1 else 2
4:                                                             for.body P:1 S:1
	t10 = charntorune(t17)                                      (rune, int)
	t11 = extract t10 #0                                               rune
	t12 = extract t10 #1                                                int
	t13 = slice t17[t12:]                                            string
	t14 = &t5[t16]                                                    *rune
	*t14 = t11
	t15 = t16 + 1:int                                                   int
	jump 6
5:                                                             for.done P:1 S:0
	return t5
6:                                                             for.loop P:2 S:2
	t16 = phi [2: 0:int, 4: t15] #n                                     int
	t17 = phi [2: s, 4: t13] #t                                      string
	t18 = len(t17)                                                      int
	t19 = t18 > 0:int                                                  bool
	if t19 goto 4 else 5

# Name: runtime.slicerunetostring
# Package: runtime
# Location: /usr/local/go/src/runtime/string.go:119:6
func slicerunetostring(a []rune) string:
0:                                                                entry P:0 S:2
	t0 = new []rune (a)                                             *[]rune
	*t0 = a
	if false:untyped bool goto 3 else 2
1:                                                              if.then P:1 S:1
	t1 = *t0                                                         []rune
	t2 = &t1[0:int]                                                   *rune
	t3 = convert unsafe.Pointer <- *rune (t2)                unsafe.Pointer
	t4 = *t0                                                         []rune
	t5 = len(t4)                                                        int
	t6 = convert uintptr <- int (t5)                                uintptr
	t7 = t6 * 4:uintptr                                             uintptr
	t8 = convert unsafe.Pointer <- *[]rune (t0)              unsafe.Pointer
	t9 = getcallerpc(t8)                                            uintptr
	t10 = make interface{} <- func(a []rune) string (slicerunetostring) interface{}
	t11 = funcPC(t10)                                               uintptr
	t12 = racereadrangepc(t3, t7, t9, t11)                               ()
	jump 2
2:                                                              if.done P:3 S:1
	t13 = new [4]byte (dum)                                        *[4]byte
	t14 = *t0                                                        []rune
	t15 = len(t14)                                                      int
	jump 4
3:                                                            cond.true P:1 S:2
	t16 = *t0                                                        []rune
	t17 = len(t16)                                                      int
	t18 = t17 > 0:int                                                  bool
	if t18 goto 1 else 2
4:                                                      rangeindex.loop P:2 S:2
	t19 = phi [2: 0:int, 5: t27] #size1                                 int
	t20 = phi [2: -1:int, 5: t21]                                       int
	t21 = t20 + 1:int                                                   int
	t22 = t21 < t15                                                    bool
	if t22 goto 5 else 6
5:                                                      rangeindex.body P:1 S:1
	t23 = &t14[t21]                                                   *rune
	t24 = *t23                                                         rune
	t25 = slice t13[:]                                               []byte
	t26 = runetochar(t25, t24)                                          int
	t27 = t19 + t26                                                     int
	jump 4
6:                                                      rangeindex.done P:1 S:1
	t28 = t19 + 3:int                                                   int
	t29 = rawstring(t28)                               (s string, b []byte)
	t30 = extract t29 #0                                             string
	t31 = extract t29 #1                                             []byte
	t32 = *t0                                                        []rune
	t33 = len(t32)                                                      int
	jump 7
7:                                                      rangeindex.loop P:2 S:2
	t34 = phi [6: 0:int, 10: t45] #size2                                int
	t35 = phi [6: 0:rune, 10: t40] #r                                  rune
	t36 = phi [6: -1:int, 10: t37]                                      int
	t37 = t36 + 1:int                                                   int
	t38 = t37 < t33                                                    bool
	if t38 goto 8 else 9
8:                                                      rangeindex.body P:1 S:2
	t39 = &t32[t37]                                                   *rune
	t40 = *t39                                                         rune
	t41 = t34 >= t19                                                   bool
	if t41 goto 9 else 10
9:                                                      rangeindex.done P:2 S:0
	t42 = slice t30[:t34]                                            string
	return t42
10:                                                             if.done P:1 S:1
	t43 = slice t31[t34:]                                            []byte
	t44 = runetochar(t43, t40)                                          int
	t45 = t34 + t44                                                     int
	jump 7

# Name: runtime.intstring
# Package: runtime
# Location: /usr/local/go/src/runtime/string.go:148:6
func intstring(v int64) string:
0:                                                                entry P:0 S:0
	t0 = rawstring(4:int)                              (s string, b []byte)
	t1 = extract t0 #0                                               string
	t2 = extract t0 #1                                               []byte
	t3 = convert rune <- int64 (v)                                     rune
	t4 = runetochar(t2, t3)                                             int
	t5 = slice t1[:t4]                                               string
	return t5

# Name: runtime.stringiter
# Package: runtime
# Location: /usr/local/go/src/runtime/string.go:156:6
func stringiter(s string, k int) int:
0:                                                                entry P:0 S:2
	t0 = len(s)                                                         int
	t1 = k >= t0                                                       bool
	if t1 goto 1 else 2
1:                                                              if.then P:1 S:0
	return 0:int
2:                                                              if.done P:1 S:2
	t2 = s[k]                                                         uint8
	t3 = t2 < 128:byte                                                 bool
	if t3 goto 3 else 4
3:                                                              if.then P:1 S:0
	t4 = k + 1:int                                                      int
	return t4
4:                                                              if.done P:1 S:0
	t5 = slice s[k:]                                                 string
	t6 = charntorune(t5)                                        (rune, int)
	t7 = extract t6 #0                                                 rune
	t8 = extract t6 #1                                                  int
	t9 = k + t8                                                         int
	return t9

# Name: runtime.stringiter2
# Package: runtime
# Location: /usr/local/go/src/runtime/string.go:174:6
func stringiter2(s string, k int) (int, rune):
0:                                                                entry P:0 S:2
	t0 = len(s)                                                         int
	t1 = k >= t0                                                       bool
	if t1 goto 1 else 2
1:                                                              if.then P:1 S:0
	return 0:int, 0:rune
2:                                                              if.done P:1 S:2
	t2 = s[k]                                                         uint8
	t3 = t2 < 128:byte                                                 bool
	if t3 goto 3 else 4
3:                                                              if.then P:1 S:0
	t4 = k + 1:int                                                      int
	t5 = convert rune <- uint8 (t2)                                    rune
	return t4, t5
4:                                                              if.done P:1 S:0
	t6 = slice s[k:]                                                 string
	t7 = charntorune(t6)                                        (rune, int)
	t8 = extract t7 #0                                                 rune
	t9 = extract t7 #1                                                  int
	t10 = k + t9                                                        int
	return t10, t8

# Name: runtime.rawstring
# Package: runtime
# Location: /usr/local/go/src/runtime/string.go:194:6
func rawstring(size int) (s string, b []byte):
0:                                                                entry P:0 S:1
	t0 = new string (s)                                             *string
	t1 = new []byte (b)                                             *[]byte
	t2 = convert uintptr <- int (size)                              uintptr
	t3 = mallocgc(t2, nil:*_type, 3:uint32)                  unsafe.Pointer
	t4 = convert unsafe.Pointer <- *string (t0)              unsafe.Pointer
	t5 = convert *stringStruct <- unsafe.Pointer (t4)         *stringStruct
	t6 = &t5.str [#0]                                       *unsafe.Pointer
	*t6 = t3
	t7 = convert unsafe.Pointer <- *string (t0)              unsafe.Pointer
	t8 = convert *stringStruct <- unsafe.Pointer (t7)         *stringStruct
	t9 = &t8.len [#1]                                                  *int
	*t9 = size
	t10 = convert unsafe.Pointer <- *[]byte (t1)             unsafe.Pointer
	t11 = convert *slice <- unsafe.Pointer (t10)                     *slice
	t12 = &t11.array [#0]                                            **byte
	t13 = convert *uint8 <- unsafe.Pointer (t3)                      *uint8
	*t12 = t13
	t14 = convert unsafe.Pointer <- *[]byte (t1)             unsafe.Pointer
	t15 = convert *slice <- unsafe.Pointer (t14)                     *slice
	t16 = &t15.len [#1]                                               *uint
	t17 = convert uint <- int (size)                                   uint
	*t16 = t17
	t18 = convert unsafe.Pointer <- *[]byte (t1)             unsafe.Pointer
	t19 = convert *slice <- unsafe.Pointer (t18)                     *slice
	t20 = &t19.cap [#2]                                               *uint
	t21 = convert uint <- int (size)                                   uint
	*t20 = t21
	jump 1
1:                                                             for.body P:2 S:2
	t22 = *maxstring                                                uintptr
	t23 = convert uintptr <- int (size)                             uintptr
	t24 = t23 <= t22                                                   bool
	if t24 goto 2 else 3
2:                                                              if.then P:2 S:0
	t25 = *t0                                                        string
	t26 = *t1                                                        []byte
	return t25, t26
3:                                                           cond.false P:1 S:2
	t27 = convert unsafe.Pointer <- *uintptr (maxstring)     unsafe.Pointer
	t28 = convert *uintptr <- unsafe.Pointer (t27)                 *uintptr
	t29 = convert uintptr <- int (size)                             uintptr
	t30 = casuintptr(t28, t22, t29)                                    bool
	if t30 goto 2 else 1

# Name: runtime.rawbyteslice
# Package: runtime
# Location: /usr/local/go/src/runtime/string.go:213:6
func rawbyteslice(size int) (b []byte):
0:                                                                entry P:0 S:2
	t0 = new []byte (b)                                             *[]byte
	t1 = convert uintptr <- int (size)                              uintptr
	t2 = goroundupsize(t1)                                          uintptr
	t3 = mallocgc(t2, nil:*_type, 3:uint32)                  unsafe.Pointer
	t4 = convert uintptr <- int (size)                              uintptr
	t5 = t2 != t4                                                      bool
	if t5 goto 1 else 2
1:                                                              if.then P:1 S:1
	t6 = convert uintptr <- int (size)                              uintptr
	t7 = add(t3, t6)                                         unsafe.Pointer
	t8 = convert uintptr <- int (size)                              uintptr
	t9 = t2 - t8                                                    uintptr
	t10 = memclr(t7, t9)                                                 ()
	jump 2
2:                                                              if.done P:2 S:0
	t11 = convert unsafe.Pointer <- *[]byte (t0)             unsafe.Pointer
	t12 = convert *slice <- unsafe.Pointer (t11)                     *slice
	t13 = &t12.array [#0]                                            **byte
	t14 = convert *uint8 <- unsafe.Pointer (t3)                      *uint8
	*t13 = t14
	t15 = convert unsafe.Pointer <- *[]byte (t0)             unsafe.Pointer
	t16 = convert *slice <- unsafe.Pointer (t15)                     *slice
	t17 = &t16.len [#1]                                               *uint
	t18 = convert uint <- int (size)                                   uint
	*t17 = t18
	t19 = convert unsafe.Pointer <- *[]byte (t0)             unsafe.Pointer
	t20 = convert *slice <- unsafe.Pointer (t19)                     *slice
	t21 = &t20.cap [#2]                                               *uint
	t22 = convert uint <- uintptr (t2)                                 uint
	*t21 = t22
	t23 = *t0                                                        []byte
	return t23

# Name: runtime.rawruneslice
# Package: runtime
# Location: /usr/local/go/src/runtime/string.go:227:6
func rawruneslice(size int) (b []rune):
0:                                                                entry P:0 S:2
	t0 = new []rune (b)                                             *[]rune
	t1 = convert uintptr <- int (size)                              uintptr
	t2 = *maxmem                                                    uintptr
	t3 = t2 / 4:uintptr                                             uintptr
	t4 = t1 > t3                                                       bool
	if t4 goto 1 else 2
1:                                                              if.then P:1 S:1
	t5 = gothrow("out of memory":string)                                 ()
	jump 2
2:                                                              if.done P:2 S:2
	t6 = convert uintptr <- int (size)                              uintptr
	t7 = t6 * 4:uintptr                                             uintptr
	t8 = goroundupsize(t7)                                          uintptr
	t9 = mallocgc(t8, nil:*_type, 3:uint32)                  unsafe.Pointer
	t10 = convert uintptr <- int (size)                             uintptr
	t11 = t10 * 4:uintptr                                           uintptr
	t12 = t8 != t11                                                    bool
	if t12 goto 3 else 4
3:                                                              if.then P:1 S:1
	t13 = convert uintptr <- int (size)                             uintptr
	t14 = t13 * 4:uintptr                                           uintptr
	t15 = add(t9, t14)                                       unsafe.Pointer
	t16 = convert uintptr <- int (size)                             uintptr
	t17 = t16 * 4:uintptr                                           uintptr
	t18 = t8 - t17                                                  uintptr
	t19 = memclr(t15, t18)                                               ()
	jump 4
4:                                                              if.done P:2 S:0
	t20 = convert unsafe.Pointer <- *[]rune (t0)             unsafe.Pointer
	t21 = convert *slice <- unsafe.Pointer (t20)                     *slice
	t22 = &t21.array [#0]                                            **byte
	t23 = convert *uint8 <- unsafe.Pointer (t9)                      *uint8
	*t22 = t23
	t24 = convert unsafe.Pointer <- *[]rune (t0)             unsafe.Pointer
	t25 = convert *slice <- unsafe.Pointer (t24)                     *slice
	t26 = &t25.len [#1]                                               *uint
	t27 = convert uint <- int (size)                                   uint
	*t26 = t27
	t28 = convert unsafe.Pointer <- *[]rune (t0)             unsafe.Pointer
	t29 = convert *slice <- unsafe.Pointer (t28)                     *slice
	t30 = &t29.cap [#2]                                               *uint
	t31 = t8 / 4:uintptr                                            uintptr
	t32 = convert uint <- uintptr (t31)                                uint
	*t30 = t32
	t33 = *t0                                                        []rune
	return t33

# Name: runtime.gobytes
# Package: runtime
# Location: /usr/local/go/src/runtime/string.go:244:6
func gobytes(p *byte, n int) []byte:
0:                                                                entry P:0 S:2
	t0 = n == 0:int                                                    bool
	if t0 goto 1 else 2
1:                                                              if.then P:1 S:0
	t1 = new [0]byte (makeslice)                                   *[0]byte
	t2 = slice t1[:0:int]                                            []byte
	return t2
2:                                                              if.done P:1 S:0
	t3 = make []byte n n                                             []byte
	t4 = &t3[0:int]                                                   *byte
	t5 = convert unsafe.Pointer <- *byte (t4)                unsafe.Pointer
	t6 = convert unsafe.Pointer <- *byte (p)                 unsafe.Pointer
	t7 = convert uintptr <- int (n)                                 uintptr
	t8 = memmove(t5, t6, t7)                                             ()
	return t3

# Name: runtime.gostringsize
# Package: runtime
# Location: /usr/local/go/src/runtime/string.go:253:6
func gostringsize(n int) string:
0:                                                                entry P:0 S:0
	t0 = rawstring(n)                                  (s string, b []byte)
	t1 = extract t0 #0                                               string
	t2 = extract t0 #1                                               []byte
	return t1

# Name: runtime.gostring
# Package: runtime
# Location: /usr/local/go/src/runtime/string.go:261:6
func gostring(p *byte) string:
0:                                                                entry P:0 S:2
	t0 = findnull(p)                                                    int
	t1 = t0 == 0:int                                                   bool
	if t1 goto 1 else 2
1:                                                              if.then P:1 S:0
	return "":string
2:                                                              if.done P:1 S:0
	t2 = rawstring(t0)                                 (s string, b []byte)
	t3 = extract t2 #0                                               string
	t4 = extract t2 #1                                               []byte
	t5 = &t4[0:int]                                                   *byte
	t6 = convert unsafe.Pointer <- *byte (t5)                unsafe.Pointer
	t7 = convert unsafe.Pointer <- *byte (p)                 unsafe.Pointer
	t8 = convert uintptr <- int (t0)                                uintptr
	t9 = memmove(t6, t7, t8)                                             ()
	return t3

# Name: runtime.gostringn
# Package: runtime
# Location: /usr/local/go/src/runtime/string.go:271:6
func gostringn(p *byte, l int) string:
0:                                                                entry P:0 S:2
	t0 = l == 0:int                                                    bool
	if t0 goto 1 else 2
1:                                                              if.then P:1 S:0
	return "":string
2:                                                              if.done P:1 S:0
	t1 = rawstring(l)                                  (s string, b []byte)
	t2 = extract t1 #0                                               string
	t3 = extract t1 #1                                               []byte
	t4 = &t3[0:int]                                                   *byte
	t5 = convert unsafe.Pointer <- *byte (t4)                unsafe.Pointer
	t6 = convert unsafe.Pointer <- *byte (p)                 unsafe.Pointer
	t7 = convert uintptr <- int (l)                                 uintptr
	t8 = memmove(t5, t6, t7)                                             ()
	return t2

# Name: runtime.index
# Package: runtime
# Location: /usr/local/go/src/runtime/string.go:280:6
func index(s string, t string) int:
0:                                                                entry P:0 S:2
	t0 = len(t)                                                         int
	t1 = t0 == 0:int                                                   bool
	if t1 goto 1 else 2
1:                                                              if.then P:1 S:0
	return 0:int
2:                                                              if.done P:1 S:1
	jump 5
3:                                                             for.body P:1 S:2
	t2 = s[t5]                                                        uint8
	t3 = t[0:int]                                                     uint8
	t4 = t2 == t3                                                      bool
	if t4 goto 8 else 7
4:                                                             for.done P:1 S:0
	return -1:int
5:                                                             for.loop P:2 S:2
	t5 = phi [2: 0:int, 7: t8] #i                                       int
	t6 = len(s)                                                         int
	t7 = t5 < t6                                                       bool
	if t7 goto 3 else 4
6:                                                              if.then P:1 S:0
	return t5
7:                                                              if.done P:2 S:1
	t8 = t5 + 1:int                                                     int
	jump 5
8:                                                            cond.true P:1 S:2
	t9 = slice s[t5:]                                                string
	t10 = hasprefix(t9, t)                                             bool
	if t10 goto 6 else 7

# Name: runtime.contains
# Package: runtime
# Location: /usr/local/go/src/runtime/string.go:292:6
func contains(s string, t string) bool:
0:                                                                entry P:0 S:0
	t0 = index(s, t)                                                    int
	t1 = t0 >= 0:int                                                   bool
	return t1

# Name: runtime.hasprefix
# Package: runtime
# Location: /usr/local/go/src/runtime/string.go:296:6
func hasprefix(s string, t string) bool:
0:                                                                entry P:0 S:2
	t0 = len(s)                                                         int
	t1 = len(t)                                                         int
	t2 = t0 >= t1                                                      bool
	if t2 goto 1 else 2
1:                                                            binop.rhs P:1 S:1
	t3 = len(t)                                                         int
	t4 = slice s[:t3]                                                string
	t5 = t4 == t                                                       bool
	jump 2
2:                                                           binop.done P:2 S:0
	t6 = phi [0: false:bool, 1: t5] #&&                                bool
	return t6

# Name: runtime.add
# Package: runtime
# Location: /usr/local/go/src/runtime/stubs.go:16:6
func add(p unsafe.Pointer, x uintptr) unsafe.Pointer:
0:                                                                entry P:0 S:0
	t0 = convert uintptr <- unsafe.Pointer (p)                      uintptr
	t1 = t0 + x                                                     uintptr
	t2 = convert unsafe.Pointer <- uintptr (t1)              unsafe.Pointer
	return t2

# Name: runtime.roundup
# Package: runtime
# Location: /usr/local/go/src/runtime/stubs.go:21:6
func roundup(p unsafe.Pointer, n uintptr) unsafe.Pointer:
0:                                                                entry P:0 S:0
	t0 = convert uintptr <- unsafe.Pointer (p)                      uintptr
	t1 = -t0                                                        uintptr
	t2 = n - 1:uintptr                                              uintptr
	t3 = t1 & t2                                                    uintptr
	t4 = convert uintptr <- unsafe.Pointer (p)                      uintptr
	t5 = t4 + t3                                                    uintptr
	t6 = convert unsafe.Pointer <- uintptr (t5)              unsafe.Pointer
	return t6

# Name: runtime.badonm
# Package: runtime
# Location: /usr/local/go/src/runtime/stubs.go:94:6
func badonm():
0:                                                                entry P:0 S:0
	t0 = gothrow("onM called from s...":string)                          ()
	return

# Name: runtime.noescape
# Package: runtime
# Location: /usr/local/go/src/runtime/stubs.go:157:6
func noescape(p unsafe.Pointer) unsafe.Pointer:
0:                                                                entry P:0 S:0
	t0 = convert uintptr <- unsafe.Pointer (p)                      uintptr
	t1 = t0 ^ 0:uintptr                                             uintptr
	t2 = convert unsafe.Pointer <- uintptr (t1)              unsafe.Pointer
	return t2

# Name: (*runtime.Func).raw
# Package: runtime
# Location: /usr/local/go/src/runtime/symtab.go:19:16
func (f *Func) raw() *_func:
0:                                                                entry P:0 S:0
	t0 = convert unsafe.Pointer <- *Func (f)                 unsafe.Pointer
	t1 = convert *_func <- unsafe.Pointer (t0)                       *_func
	return t1

# Name: runtime.symtabinit
# Package: runtime
# Location: /usr/local/go/src/runtime/symtab.go:46:6
func symtabinit():
0:                                                                entry P:0 S:2
	t0 = convert unsafe.Pointer <- *struct{} (pclntab)       unsafe.Pointer
	t1 = convert *[8]byte <- unsafe.Pointer (t0)                   *[8]byte
	t2 = convert unsafe.Pointer <- *struct{} (pclntab)       unsafe.Pointer
	t3 = convert *[2]uint32 <- unsafe.Pointer (t2)               *[2]uint32
	t4 = &t3[0:int]                                                 *uint32
	t5 = *t4                                                         uint32
	t6 = t5 != 4294967291:uint32                                       bool
	if t6 goto 1 else 6
1:                                                              if.then P:5 S:1
	t7 = &t3[0:int]                                                 *uint32
	t8 = *t7                                                         uint32
	t9 = convert hex <- uint32 (t8)                                     hex
	t10 = &t1[4:int]                                                  *byte
	t11 = *t10                                                         byte
	t12 = convert hex <- byte (t11)                                     hex
	t13 = &t1[5:int]                                                  *byte
	t14 = *t13                                                         byte
	t15 = convert hex <- byte (t14)                                     hex
	t16 = &t1[6:int]                                                  *byte
	t17 = *t16                                                         byte
	t18 = convert hex <- byte (t17)                                     hex
	t19 = &t1[7:int]                                                  *byte
	t20 = *t19                                                         byte
	t21 = convert hex <- byte (t20)                                     hex
	t22 = println("runtime: function...":string, t9, t12, t15, t18, t21) ()
	t23 = gothrow("invalid function ...":string)                         ()
	jump 2
2:                                                              if.done P:2 S:1
	t24 = convert unsafe.Pointer <- *[]byte (pclntable)      unsafe.Pointer
	t25 = convert *sliceStruct <- unsafe.Pointer (t24)         *sliceStruct
	t26 = &t25.array [#0]                                   *unsafe.Pointer
	t27 = convert unsafe.Pointer <- *struct{} (pclntab)      unsafe.Pointer
	*t26 = t27
	t28 = &t25.len [#1]                                                *int
	t29 = convert unsafe.Pointer <- *struct{} (epclntab)     unsafe.Pointer
	t30 = convert uintptr <- unsafe.Pointer (t29)                   uintptr
	t31 = convert unsafe.Pointer <- *struct{} (pclntab)      unsafe.Pointer
	t32 = convert uintptr <- unsafe.Pointer (t31)                   uintptr
	t33 = t30 - t32                                                 uintptr
	t34 = convert int <- uintptr (t33)                                  int
	*t28 = t34
	t35 = &t25.cap [#2]                                                *int
	t36 = &t25.len [#1]                                                *int
	t37 = *t36                                                          int
	*t35 = t37
	t38 = convert unsafe.Pointer <- *[8]byte (t1)            unsafe.Pointer
	t39 = add(t38, 8:uintptr)                                unsafe.Pointer
	t40 = convert *uintptr <- unsafe.Pointer (t39)                 *uintptr
	t41 = *t40                                                      uintptr
	t42 = convert int <- uintptr (t41)                                  int
	t43 = convert unsafe.Pointer <- *[8]byte (t1)            unsafe.Pointer
	t44 = add(t43, 16:uintptr)                               unsafe.Pointer
	t45 = convert unsafe.Pointer <- *[]functab (ftab)        unsafe.Pointer
	t46 = convert *sliceStruct <- unsafe.Pointer (t45)         *sliceStruct
	t47 = &t46.array [#0]                                   *unsafe.Pointer
	*t47 = t44
	t48 = &t46.len [#1]                                                *int
	t49 = t42 + 1:int                                                   int
	*t48 = t49
	t50 = &t46.cap [#2]                                                *int
	t51 = &t46.len [#1]                                                *int
	t52 = *t51                                                          int
	*t50 = t52
	jump 9
3:                                                           cond.false P:1 S:2
	t53 = &t1[7:int]                                                  *byte
	t54 = *t53                                                         byte
	t55 = t54 != 8:byte                                                bool
	if t55 goto 1 else 2
4:                                                           cond.false P:1 S:2
	t56 = &t1[6:int]                                                  *byte
	t57 = *t56                                                         byte
	t58 = t57 != 1:byte                                                bool
	if t58 goto 1 else 3
5:                                                           cond.false P:1 S:2
	t59 = &t1[5:int]                                                  *byte
	t60 = *t59                                                         byte
	t61 = t60 != 0:byte                                                bool
	if t61 goto 1 else 4
6:                                                           cond.false P:1 S:2
	t62 = &t1[4:int]                                                  *byte
	t63 = *t62                                                         byte
	t64 = t63 != 0:byte                                                bool
	if t64 goto 1 else 5
7:                                                             for.body P:1 S:2
	t65 = *ftab                                                   []functab
	t66 = &t65[t98]                                                *functab
	t67 = &t66.entry [#0]                                          *uintptr
	t68 = *t67                                                      uintptr
	t69 = *ftab                                                   []functab
	t70 = t98 + 1:int                                                   int
	t71 = &t69[t70]                                                *functab
	t72 = &t71.entry [#0]                                          *uintptr
	t73 = *t72                                                      uintptr
	t74 = t68 > t73                                                    bool
	if t74 goto 10 else 11
8:                                                             for.done P:1 S:0
	t75 = convert unsafe.Pointer <- *[]uint32 (filetab)      unsafe.Pointer
	t76 = convert *sliceStruct <- unsafe.Pointer (t75)         *sliceStruct
	t77 = *ftab                                                   []functab
	t78 = &t77[t42]                                                *functab
	t79 = &t78.funcoff [#1]                                        *uintptr
	t80 = convert unsafe.Pointer <- *uintptr (t79)           unsafe.Pointer
	t81 = convert *uint32 <- unsafe.Pointer (t80)                   *uint32
	t82 = *t81                                                       uint32
	t83 = &t76.array [#0]                                   *unsafe.Pointer
	t84 = *pclntable                                                 []byte
	t85 = convert int <- uint32 (t82)                                   int
	t86 = &t84[t85]                                                   *byte
	t87 = convert unsafe.Pointer <- *byte (t86)              unsafe.Pointer
	*t83 = t87
	t88 = &t76.len [#1]                                                *int
	*t88 = 1:int
	t89 = &t76.cap [#2]                                                *int
	*t89 = 1:int
	t90 = &t76.len [#1]                                                *int
	t91 = *filetab                                                 []uint32
	t92 = &t91[0:int]                                               *uint32
	t93 = *t92                                                       uint32
	t94 = convert int <- uint32 (t93)                                   int
	*t90 = t94
	t95 = &t76.cap [#2]                                                *int
	t96 = &t76.len [#1]                                                *int
	t97 = *t96                                                          int
	*t95 = t97
	return
9:                                                             for.loop P:2 S:2
	t98 = phi [2: 0:int, 11: t129] #i                                   int
	t99 = phi [2: nil:*_func, 11: t125] #f1                          *_func
	t100 = phi [2: nil:*_func, 11: t126] #f2                         *_func
	t101 = phi [2: "":string, 11: t127] #f2name                      string
	t102 = phi [2: 0:int, 11: t128] #j                                  int
	t103 = t98 < t42                                                   bool
	if t103 goto 7 else 8
10:                                                             if.then P:1 S:2
	t104 = *pclntable                                                []byte
	t105 = *ftab                                                  []functab
	t106 = &t105[t98]                                              *functab
	t107 = &t106.funcoff [#1]                                      *uintptr
	t108 = *t107                                                    uintptr
	t109 = convert int <- uintptr (t108)                                int
	t110 = &t104[t109]                                                *byte
	t111 = convert unsafe.Pointer <- *byte (t110)            unsafe.Pointer
	t112 = convert *_func <- unsafe.Pointer (t111)                   *_func
	t113 = *pclntable                                                []byte
	t114 = *ftab                                                  []functab
	t115 = t98 + 1:int                                                  int
	t116 = &t114[t115]                                             *functab
	t117 = &t116.funcoff [#1]                                      *uintptr
	t118 = *t117                                                    uintptr
	t119 = convert int <- uintptr (t118)                                int
	t120 = &t113[t119]                                                *byte
	t121 = convert unsafe.Pointer <- *byte (t120)            unsafe.Pointer
	t122 = convert *_func <- unsafe.Pointer (t121)                   *_func
	t123 = t98 + 1:int                                                  int
	t124 = t123 < t42                                                  bool
	if t124 goto 12 else 13
11:                                                             if.done P:2 S:1
	t125 = phi [7: t99, 15: t112] #f1                                *_func
	t126 = phi [7: t100, 15: t122] #f2                               *_func
	t127 = phi [7: t101, 15: t131] #f2name                           string
	t128 = phi [7: t102, 15: t163] #j                                   int
	t129 = t98 + 1:int                                                  int
	jump 9
12:                                                             if.then P:1 S:1
	t130 = gofuncname(t122)                                          string
	jump 13
13:                                                             if.done P:2 S:1
	t131 = phi [10: "end":string, 12: t130] #f2name                  string
	t132 = *ftab                                                  []functab
	t133 = &t132[t98]                                              *functab
	t134 = &t133.entry [#0]                                        *uintptr
	t135 = *t134                                                    uintptr
	t136 = convert hex <- uintptr (t135)                                hex
	t137 = gofuncname(t112)                                          string
	t138 = *ftab                                                  []functab
	t139 = t98 + 1:int                                                  int
	t140 = &t138[t139]                                             *functab
	t141 = &t140.entry [#0]                                        *uintptr
	t142 = *t141                                                    uintptr
	t143 = convert hex <- uintptr (t142)                                hex
	t144 = println("function symbol t...":string, t136, t137, ">":string, t143, t131) ()
	jump 16
14:                                                            for.body P:1 S:1
	t145 = *ftab                                                  []functab
	t146 = &t145[t163]                                             *functab
	t147 = &t146.entry [#0]                                        *uintptr
	t148 = *t147                                                    uintptr
	t149 = convert hex <- uintptr (t148)                                hex
	t150 = *pclntable                                                []byte
	t151 = *ftab                                                  []functab
	t152 = &t151[t163]                                             *functab
	t153 = &t152.funcoff [#1]                                      *uintptr
	t154 = *t153                                                    uintptr
	t155 = convert int <- uintptr (t154)                                int
	t156 = &t150[t155]                                                *byte
	t157 = convert unsafe.Pointer <- *byte (t156)            unsafe.Pointer
	t158 = convert *_func <- unsafe.Pointer (t157)                   *_func
	t159 = gofuncname(t158)                                          string
	t160 = print("\t":string, t149, " ":string, t159)                    ()
	t161 = t163 + 1:int                                                 int
	jump 16
15:                                                            for.done P:1 S:1
	t162 = gothrow("invalid runtime s...":string)                        ()
	jump 11
16:                                                            for.loop P:2 S:2
	t163 = phi [13: 0:int, 14: t161] #j                                 int
	t164 = t163 <= t98                                                 bool
	if t164 goto 14 else 15

# Name: runtime.FuncForPC
# Package: runtime
# Location: /usr/local/go/src/runtime/symtab.go:104:6
func FuncForPC(pc uintptr) *Func:
0:                                                                entry P:0 S:0
	t0 = findfunc(pc)                                                *_func
	t1 = convert unsafe.Pointer <- *_func (t0)               unsafe.Pointer
	t2 = convert *Func <- unsafe.Pointer (t1)                         *Func
	return t2

# Name: (*runtime.Func).Name
# Package: runtime
# Location: /usr/local/go/src/runtime/symtab.go:109:16
func (f *Func) Name() string:
0:                                                                entry P:0 S:0
	t0 = (*Func).raw(f)                                              *_func
	t1 = gofuncname(t0)                                              string
	return t1

# Name: (*runtime.Func).Entry
# Package: runtime
# Location: /usr/local/go/src/runtime/symtab.go:114:16
func (f *Func) Entry() uintptr:
0:                                                                entry P:0 S:0
	t0 = (*Func).raw(f)                                              *_func
	t1 = &t0.entry [#0]                                            *uintptr
	t2 = *t1                                                        uintptr
	return t2

# Name: (*runtime.Func).FileLine
# Package: runtime
# Location: /usr/local/go/src/runtime/symtab.go:122:16
func (f *Func) FileLine(pc uintptr) (file string, line int):
0:                                                                entry P:0 S:0
	t0 = new string (file)                                          *string
	t1 = (*Func).raw(f)                                              *_func
	t2 = funcline1(t1, pc, t0, false:bool)                            int32
	t3 = convert int <- int32 (t2)                                      int
	t4 = *t0                                                         string
	*t0 = t4
	t5 = *t0                                                         string
	return t5, t3

# Name: runtime.findfunc
# Package: runtime
# Location: /usr/local/go/src/runtime/symtab.go:129:6
func findfunc(pc uintptr) *_func:
0:                                                                entry P:0 S:2
	t0 = *ftab                                                    []functab
	t1 = len(t0)                                                        int
	t2 = t1 == 0:int                                                   bool
	if t2 goto 1 else 2
1:                                                              if.then P:1 S:0
	return nil:*_func
2:                                                              if.done P:1 S:2
	t3 = *ftab                                                    []functab
	t4 = &t3[0:int]                                                *functab
	t5 = &t4.entry [#0]                                            *uintptr
	t6 = *t5                                                        uintptr
	t7 = pc < t6                                                       bool
	if t7 goto 3 else 5
3:                                                              if.then P:2 S:0
	return nil:*_func
4:                                                              if.done P:1 S:1
	t8 = *ftab                                                    []functab
	t9 = len(t8)                                                        int
	t10 = t9 - 1:int                                                    int
	jump 8
5:                                                           cond.false P:1 S:2
	t11 = *ftab                                                   []functab
	t12 = *ftab                                                   []functab
	t13 = len(t12)                                                      int
	t14 = t13 - 1:int                                                   int
	t15 = &t11[t14]                                                *functab
	t16 = &t15.entry [#0]                                          *uintptr
	t17 = *t16                                                      uintptr
	t18 = pc >= t17                                                    bool
	if t18 goto 3 else 4
6:                                                             for.body P:1 S:2
	t19 = t28 / 2:int                                                   int
	t20 = *ftab                                                   []functab
	t21 = t27 + t19                                                     int
	t22 = &t20[t21]                                                *functab
	t23 = &t22.entry [#0]                                          *uintptr
	t24 = *t23                                                      uintptr
	t25 = t24 <= pc                                                    bool
	if t25 goto 11 else 10
7:                                                             for.done P:1 S:0
	t26 = gothrow("findfunc: binary ...":string)                         ()
	return nil:*_func
8:                                                             for.loop P:3 S:2
	t27 = phi [4: 0:int, 12: t27, 13: t48] #lo                          int
	t28 = phi [4: t10, 12: t19, 13: t50] #nf                            int
	t29 = t28 > 0:int                                                  bool
	if t29 goto 6 else 7
9:                                                              if.then P:1 S:0
	t30 = *pclntable                                                 []byte
	t31 = &t22.funcoff [#1]                                        *uintptr
	t32 = *t31                                                      uintptr
	t33 = convert int <- uintptr (t32)                                  int
	t34 = &t30[t33]                                                   *byte
	t35 = convert unsafe.Pointer <- *byte (t34)              unsafe.Pointer
	t36 = convert *_func <- unsafe.Pointer (t35)                     *_func
	return t36
10:                                                             if.else P:2 S:2
	t37 = &t22.entry [#0]                                          *uintptr
	t38 = *t37                                                      uintptr
	t39 = pc < t38                                                     bool
	if t39 goto 12 else 13
11:                                                           cond.true P:1 S:2
	t40 = *ftab                                                   []functab
	t41 = t27 + t19                                                     int
	t42 = t41 + 1:int                                                   int
	t43 = &t40[t42]                                                *functab
	t44 = &t43.entry [#0]                                          *uintptr
	t45 = *t44                                                      uintptr
	t46 = pc < t45                                                     bool
	if t46 goto 9 else 10
12:                                                             if.then P:1 S:1
	jump 8
13:                                                             if.else P:1 S:1
	t47 = t19 + 1:int                                                   int
	t48 = t27 + t47                                                     int
	t49 = t19 + 1:int                                                   int
	t50 = t28 - t49                                                     int
	jump 8

# Name: runtime.pcvalue
# Package: runtime
# Location: /usr/local/go/src/runtime/symtab.go:158:6
func pcvalue(f *_func, off int32, targetpc uintptr, strict bool) int32:
0:                                                                entry P:0 S:2
	t0 = off == 0:int32                                                bool
	if t0 goto 1 else 2
1:                                                              if.then P:1 S:0
	return -1:int32
2:                                                              if.done P:1 S:1
	t1 = *pclntable                                                  []byte
	t2 = slice t1[off:]                                              []byte
	t3 = new uintptr (pc)                                          *uintptr
	t4 = &f.entry [#0]                                             *uintptr
	t5 = *t4                                                        uintptr
	*t3 = t5
	t6 = new int32 (val)                                             *int32
	*t6 = -1:int32
	jump 3
3:                                                             for.body P:2 S:2
	t7 = phi [2: t2, 5: t13] #p                                      []byte
	t8 = *t3                                                        uintptr
	t9 = &f.entry [#0]                                             *uintptr
	t10 = *t9                                                       uintptr
	t11 = t8 == t10                                                    bool
	t12 = step(t7, t3, t6, t11)                      (newp []byte, ok bool)
	t13 = extract t12 #0                                             []byte
	t14 = extract t12 #1                                               bool
	if t14 goto 5 else 4
4:                                                              if.then P:1 S:2
	t15 = *panicking                                                 uint32
	t16 = t15 != 0:uint32                                              bool
	if t16 goto 7 else 9
5:                                                              if.done P:1 S:2
	t17 = *t3                                                       uintptr
	t18 = targetpc < t17                                               bool
	if t18 goto 6 else 3
6:                                                              if.then P:1 S:0
	t19 = *t6                                                         int32
	return t19
7:                                                              if.then P:2 S:0
	return -1:int32
8:                                                              if.done P:1 S:1
	t20 = gofuncname(f)                                              string
	t21 = *t3                                                       uintptr
	t22 = convert hex <- uintptr (t21)                                  hex
	t23 = convert hex <- uintptr (targetpc)                             hex
	t24 = print("runtime: invalid ...":string, t20, " pc=":string, t22, " targetpc=":string, t23, " tab=":string, t13, "\n":string) ()
	t25 = *pclntable                                                 []byte
	t26 = slice t25[off:]                                            []byte
	t27 = &f.entry [#0]                                            *uintptr
	t28 = *t27                                                      uintptr
	*t3 = t28
	*t6 = -1:int32
	jump 10
9:                                                           cond.false P:1 S:2
	if strict goto 8 else 7
10:                                                            for.body P:2 S:2
	t29 = phi [8: t26, 12: t35] #p                                   []byte
	t30 = *t3                                                       uintptr
	t31 = &f.entry [#0]                                            *uintptr
	t32 = *t31                                                      uintptr
	t33 = t30 == t32                                                   bool
	t34 = step(t29, t3, t6, t33)                     (newp []byte, ok bool)
	t35 = extract t34 #0                                             []byte
	t36 = extract t34 #1                                               bool
	if t36 goto 12 else 11
11:                                                             if.then P:1 S:0
	t37 = gothrow("invalid runtime s...":string)                         ()
	return -1:int32
12:                                                             if.done P:1 S:1
	t38 = *t6                                                         int32
	t39 = *t3                                                       uintptr
	t40 = convert hex <- uintptr (t39)                                  hex
	t41 = print("\tvalue=":string, t38, " until pc=":string, t40, "\n":string) ()
	jump 10

# Name: runtime.funcname
# Package: runtime
# Location: /usr/local/go/src/runtime/symtab.go:200:6
func funcname(f *_func) *byte:
0:                                                                entry P:0 S:2
	t0 = f == nil:*_func                                               bool
	if t0 goto 1 else 3
1:                                                              if.then P:2 S:0
	return nil:*byte
2:                                                              if.done P:1 S:0
	t1 = *pclntable                                                  []byte
	t2 = &f.nameoff [#1]                                             *int32
	t3 = *t2                                                          int32
	t4 = convert int <- int32 (t3)                                      int
	t5 = &t1[t4]                                                      *byte
	t6 = convert unsafe.Pointer <- *byte (t5)                unsafe.Pointer
	t7 = convert *byte <- unsafe.Pointer (t6)                         *byte
	return t7
3:                                                           cond.false P:1 S:2
	t8 = &f.nameoff [#1]                                             *int32
	t9 = *t8                                                          int32
	t10 = t9 == 0:int32                                                bool
	if t10 goto 1 else 2

# Name: runtime.gofuncname
# Package: runtime
# Location: /usr/local/go/src/runtime/symtab.go:207:6
func gofuncname(f *_func) string:
0:                                                                entry P:0 S:0
	t0 = funcname(f)                                                  *byte
	t1 = gostringnocopy(t0)                                          string
	return t1

# Name: runtime.funcline1
# Package: runtime
# Location: /usr/local/go/src/runtime/symtab.go:211:6
func funcline1(f *_func, targetpc uintptr, file *string, strict bool) int32:
0:                                                                entry P:0 S:2
	*file = "?":string
	t0 = &f.pcfile [#5]                                              *int32
	t1 = *t0                                                          int32
	t2 = pcvalue(f, t1, targetpc, strict)                             int32
	t3 = convert int <- int32 (t2)                                      int
	t4 = &f.pcln [#6]                                                *int32
	t5 = *t4                                                          int32
	t6 = pcvalue(f, t5, targetpc, strict)                             int32
	t7 = t3 == -1:int                                                  bool
	if t7 goto 1 else 4
1:                                                              if.then P:3 S:0
	return 0:int32
2:                                                              if.done P:1 S:0
	t8 = *pclntable                                                  []byte
	t9 = *filetab                                                  []uint32
	t10 = &t9[t3]                                                   *uint32
	t11 = *t10                                                       uint32
	t12 = convert int <- uint32 (t11)                                   int
	t13 = &t8[t12]                                                    *byte
	t14 = gostringnocopy(t13)                                        string
	*file = t14
	return t6
3:                                                           cond.false P:1 S:2
	t15 = *filetab                                                 []uint32
	t16 = len(t15)                                                      int
	t17 = t3 >= t16                                                    bool
	if t17 goto 1 else 2
4:                                                           cond.false P:1 S:2
	t18 = t6 == -1:int32                                               bool
	if t18 goto 1 else 3

# Name: runtime.funcline
# Package: runtime
# Location: /usr/local/go/src/runtime/symtab.go:223:6
func funcline(f *_func, targetpc uintptr, file *string) int32:
0:                                                                entry P:0 S:0
	t0 = funcline1(f, targetpc, file, true:bool)                      int32
	return t0

# Name: runtime.funcspdelta
# Package: runtime
# Location: /usr/local/go/src/runtime/symtab.go:227:6
func funcspdelta(f *_func, targetpc uintptr) int32:
0:                                                                entry P:0 S:2
	t0 = &f.pcsp [#4]                                                *int32
	t1 = *t0                                                          int32
	t2 = pcvalue(f, t1, targetpc, true:bool)                          int32
	t3 = t2 & 7:int32                                                 int32
	t4 = t3 != 0:int32                                                 bool
	if t4 goto 1 else 2
1:                                                              if.then P:1 S:1
	t5 = &f.entry [#0]                                             *uintptr
	t6 = *t5                                                        uintptr
	t7 = convert hex <- uintptr (t6)                                    hex
	t8 = convert hex <- uintptr (targetpc)                              hex
	t9 = &f.pcsp [#4]                                                *int32
	t10 = *t9                                                         int32
	t11 = convert hex <- int32 (t10)                                    hex
	t12 = print("invalid spdelta ":string, t7, " ":string, t8, " ":string, t11, " ":string, t2, "\n":string) ()
	jump 2
2:                                                              if.done P:2 S:0
	return t2

# Name: runtime.pcdatavalue
# Package: runtime
# Location: /usr/local/go/src/runtime/symtab.go:235:6
func pcdatavalue(f *_func, table int32, targetpc uintptr) int32:
0:                                                                entry P:0 S:2
	t0 = table < 0:int32                                               bool
	if t0 goto 1 else 3
1:                                                              if.then P:2 S:0
	return -1:int32
2:                                                              if.done P:1 S:0
	t1 = &f.nfuncdata [#8]                                           *int32
	t2 = convert unsafe.Pointer <- *int32 (t1)               unsafe.Pointer
	t3 = convert uintptr <- int32 (table)                           uintptr
	t4 = t3 * 4:uintptr                                             uintptr
	t5 = 4:uintptr + t4                                             uintptr
	t6 = add(t2, t5)                                         unsafe.Pointer
	t7 = convert *int32 <- unsafe.Pointer (t6)                       *int32
	t8 = *t7                                                          int32
	t9 = pcvalue(f, t8, targetpc, true:bool)                          int32
	return t9
3:                                                           cond.false P:1 S:2
	t10 = &f.npcdata [#7]                                            *int32
	t11 = *t10                                                        int32
	t12 = table >= t11                                                 bool
	if t12 goto 1 else 2

# Name: runtime.funcdata
# Package: runtime
# Location: /usr/local/go/src/runtime/symtab.go:243:6
func funcdata(f *_func, i int32) unsafe.Pointer:
0:                                                                entry P:0 S:2
	t0 = i < 0:int32                                                   bool
	if t0 goto 1 else 3
1:                                                              if.then P:2 S:0
	return nil:unsafe.Pointer
2:                                                              if.done P:1 S:2
	t1 = &f.nfuncdata [#8]                                           *int32
	t2 = convert unsafe.Pointer <- *int32 (t1)               unsafe.Pointer
	t3 = &f.npcdata [#7]                                             *int32
	t4 = *t3                                                          int32
	t5 = convert uintptr <- int32 (t4)                              uintptr
	t6 = t5 * 4:uintptr                                             uintptr
	t7 = 4:uintptr + t6                                             uintptr
	t8 = add(t2, t7)                                         unsafe.Pointer
	if true:untyped bool goto 6 else 5
3:                                                           cond.false P:1 S:2
	t9 = &f.nfuncdata [#8]                                           *int32
	t10 = *t9                                                         int32
	t11 = i >= t10                                                     bool
	if t11 goto 1 else 2
4:                                                              if.then P:1 S:2
	t12 = convert unsafe.Pointer <- *_func (f)               unsafe.Pointer
	t13 = convert uintptr <- unsafe.Pointer (t12)                   uintptr
	t14 = t13 & 4:uintptr                                           uintptr
	t15 = t14 != 0:uintptr                                             bool
	if t15 goto 7 else 8
5:                                                              if.done P:3 S:0
	t16 = phi [2: t8, 6: t8, 8: t26] #p                      unsafe.Pointer
	t17 = convert uintptr <- int32 (i)                              uintptr
	t18 = t17 * 8:uintptr                                           uintptr
	t19 = add(t16, t18)                                      unsafe.Pointer
	t20 = convert *unsafe.Pointer <- unsafe.Pointer (t19)   *unsafe.Pointer
	t21 = *t20                                               unsafe.Pointer
	return t21
6:                                                            cond.true P:1 S:2
	t22 = convert uintptr <- unsafe.Pointer (t8)                    uintptr
	t23 = t22 & 4:uintptr                                           uintptr
	t24 = t23 != 0:uintptr                                             bool
	if t24 goto 4 else 5
7:                                                              if.then P:1 S:1
	t25 = println("runtime: misalign...":string, f)                      ()
	jump 8
8:                                                              if.done P:2 S:1
	t26 = add(t8, 4:uintptr)                                 unsafe.Pointer
	jump 5

# Name: runtime.step
# Package: runtime
# Location: /usr/local/go/src/runtime/symtab.go:258:6
func step(p []byte, pc *uintptr, val *int32, first bool) (newp []byte, ok bool):
0:                                                                entry P:0 S:2
	t0 = readvarint(p)                            (newp []byte, val uint32)
	t1 = extract t0 #0                                               []byte
	t2 = extract t0 #1                                               uint32
	t3 = t2 == 0:uint32                                                bool
	if t3 goto 3 else 2
1:                                                              if.then P:1 S:0
	return nil:[]byte, false:bool
2:                                                              if.done P:2 S:2
	t4 = t2 & 1:uint32                                               uint32
	t5 = t4 != 0:uint32                                                bool
	if t5 goto 4 else 6
3:                                                            cond.true P:1 S:2
	if first goto 2 else 1
4:                                                              if.then P:1 S:1
	t6 = t2 >> 1:uint64                                              uint32
	t7 = ^t6                                                         uint32
	jump 5
5:                                                              if.done P:2 S:0
	t8 = phi [4: t7, 6: t19] #uvdelta                                uint32
	t9 = convert int32 <- uint32 (t8)                                 int32
	t10 = readvarint(t1)                          (newp []byte, val uint32)
	t11 = extract t10 #0                                             []byte
	t12 = extract t10 #1                                             uint32
	t13 = t12 * 1:uint32                                             uint32
	t14 = convert uintptr <- uint32 (t13)                           uintptr
	t15 = *pc                                                       uintptr
	t16 = t15 + t14                                                 uintptr
	*pc = t16
	t17 = *val                                                        int32
	t18 = t17 + t9                                                    int32
	*val = t18
	return t11, true:bool
6:                                                              if.else P:1 S:1
	t19 = t2 >> 1:uint32                                             uint32
	jump 5

# Name: runtime.readvarint
# Package: runtime
# Location: /usr/local/go/src/runtime/symtab.go:276:6
func readvarint(p []byte) (newp []byte, val uint32):
0:                                                                entry P:0 S:1
	jump 1
1:                                                             for.body P:2 S:2
	t0 = phi [0: p, 3: t5] #p                                        []byte
	t1 = phi [0: 0:uint32, 3: t9] #v                                 uint32
	t2 = phi [0: 0:uint32, 3: t12] #shift                            uint32
	t3 = &t0[0:int]                                                   *byte
	t4 = *t3                                                           byte
	t5 = slice t0[1:int:]                                            []byte
	t6 = convert uint32 <- byte (t4)                                 uint32
	t7 = t6 & 127:uint32                                             uint32
	t8 = t7 << t2                                                    uint32
	t9 = t1 | t8                                                     uint32
	t10 = t4 & 128:byte                                                byte
	t11 = t10 == 0:byte                                                bool
	if t11 goto 2 else 3
2:                                                              if.then P:1 S:0
	return t5, t9
3:                                                              if.done P:1 S:1
	t12 = t2 + 7:uint32                                              uint32
	jump 1

# Name: runtime.timeSleep
# Package: runtime
# Location: /usr/local/go/src/runtime/time.go:47:6
func timeSleep(ns int64):
0:                                                                entry P:0 S:2
	t0 = ns <= 0:int64                                                 bool
	if t0 goto 1 else 2
1:                                                              if.then P:1 S:0
	return
2:                                                              if.done P:1 S:0
	t1 = new timer (new)                                             *timer
	t2 = &t1.when [#1]                                               *int64
	t3 = nanotime()                                                   int64
	t4 = t3 + ns                                                      int64
	*t2 = t4
	t5 = &t1.f [#3]                             *func(interface{}, uintptr)
	*t5 = goroutineReady
	t6 = &t1.arg [#4]                                          *interface{}
	t7 = getg()                                                          *g
	t8 = make interface{} <- *g (t7)                            interface{}
	*t6 = t8
	t9 = &timers.lock [#0]                                           *mutex
	t10 = lock(t9)                                                       ()
	t11 = addtimerLocked(t1)                                             ()
	t12 = &timers.lock [#0]                                          *mutex
	t13 = goparkunlock(t12, "sleep":string)                              ()
	return

# Name: runtime.startTimer
# Package: runtime
# Location: /usr/local/go/src/runtime/time.go:62:6
func startTimer(t *timer):
0:                                                                entry P:0 S:2
	if false:untyped bool goto 1 else 2
1:                                                              if.then P:1 S:1
	t0 = convert unsafe.Pointer <- *timer (t)                unsafe.Pointer
	t1 = racerelease(t0)                                                 ()
	jump 2
2:                                                              if.done P:2 S:0
	t2 = addtimer(t)                                                     ()
	return

# Name: runtime.stopTimer
# Package: runtime
# Location: /usr/local/go/src/runtime/time.go:71:6
func stopTimer(t *timer) bool:
0:                                                                entry P:0 S:0
	t0 = deltimer(t)                                                   bool
	return t0

# Name: runtime.goroutineReady
# Package: runtime
# Location: /usr/local/go/src/runtime/time.go:78:6
func goroutineReady(arg interface{}, seq uintptr):
0:                                                                entry P:0 S:0
	t0 = typeassert arg.(*g)                                             *g
	t1 = goready(t0)                                                     ()
	return

# Name: runtime.addtimer
# Package: runtime
# Location: /usr/local/go/src/runtime/time.go:82:6
func addtimer(t *timer):
0:                                                                entry P:0 S:0
	t0 = &timers.lock [#0]                                           *mutex
	t1 = lock(t0)                                                        ()
	t2 = addtimerLocked(t)                                               ()
	t3 = &timers.lock [#0]                                           *mutex
	t4 = unlock(t3)                                                      ()
	return

# Name: runtime.addtimerLocked
# Package: runtime
# Location: /usr/local/go/src/runtime/time.go:91:6
func addtimerLocked(t *timer):
0:                                                                entry P:0 S:2
	t0 = &t.when [#1]                                                *int64
	t1 = *t0                                                          int64
	t2 = t1 < 0:int64                                                  bool
	if t2 goto 1 else 2
1:                                                              if.then P:1 S:1
	t3 = &t.when [#1]                                                *int64
	*t3 = 9223372036854775807:int64
	jump 2
2:                                                              if.done P:2 S:2
	t4 = &t.i [#0]                                                     *int
	t5 = &timers.t [#6]                                           *[]*timer
	t6 = *t5                                                       []*timer
	t7 = len(t6)                                                        int
	*t4 = t7
	t8 = &timers.t [#6]                                           *[]*timer
	t9 = &timers.t [#6]                                           *[]*timer
	t10 = *t9                                                      []*timer
	t11 = new [1]*timer (varargs)                                *[1]*timer
	t12 = &t11[0:int]                                               **timer
	*t12 = t
	t13 = slice t11[:]                                             []*timer
	t14 = append(t10, t13...)                                      []*timer
	*t8 = t14
	t15 = &t.i [#0]                                                    *int
	t16 = *t15                                                          int
	t17 = siftupTimer(t16)                                               ()
	t18 = &t.i [#0]                                                    *int
	t19 = *t18                                                          int
	t20 = t19 == 0:int                                                 bool
	if t20 goto 3 else 4
3:                                                              if.then P:1 S:2
	t21 = &timers.sleeping [#3]                                       *bool
	t22 = *t21                                                         bool
	if t22 goto 5 else 6
4:                                                              if.done P:3 S:2
	t23 = &timers.created [#2]                                        *bool
	t24 = *t23                                                         bool
	if t24 goto 9 else 8
5:                                                              if.then P:1 S:1
	t25 = &timers.sleeping [#3]                                       *bool
	*t25 = false:bool
	t26 = &timers.waitnote [#5]                                       *note
	t27 = notewakeup(t26)                                                ()
	jump 6
6:                                                              if.done P:2 S:2
	t28 = &timers.rescheduling [#4]                                   *bool
	t29 = *t28                                                         bool
	if t29 goto 7 else 4
7:                                                              if.then P:1 S:1
	t30 = &timers.rescheduling [#4]                                   *bool
	*t30 = false:bool
	t31 = &timers.gp [#1]                                               **g
	t32 = *t31                                                           *g
	t33 = goready(t32)                                                   ()
	jump 4
8:                                                              if.then P:1 S:1
	t34 = &timers.created [#2]                                        *bool
	*t34 = true:bool
	go timerproc()
	jump 9
9:                                                              if.done P:2 S:0
	return

# Name: runtime.deltimer
# Package: runtime
# Location: /usr/local/go/src/runtime/time.go:119:6
func deltimer(t *timer) bool:
0:                                                                entry P:0 S:2
	t0 = &t.i [#0]                                                     *int
	t1 = *t0                                                            int
	t2 = &timers.lock [#0]                                           *mutex
	t3 = lock(t2)                                                        ()
	t4 = &t.i [#0]                                                     *int
	t5 = *t4                                                            int
	t6 = &timers.t [#6]                                           *[]*timer
	t7 = *t6                                                       []*timer
	t8 = len(t7)                                                        int
	t9 = t8 - 1:int                                                     int
	t10 = t5 < 0:int                                                   bool
	if t10 goto 1 else 4
1:                                                              if.then P:3 S:0
	t11 = &timers.lock [#0]                                          *mutex
	t12 = unlock(t11)                                                    ()
	return false:bool
2:                                                              if.done P:1 S:2
	t13 = t5 != t9                                                     bool
	if t13 goto 5 else 6
3:                                                           cond.false P:1 S:2
	t14 = &timers.t [#6]                                          *[]*timer
	t15 = *t14                                                     []*timer
	t16 = &t15[t5]                                                  **timer
	t17 = *t16                                                       *timer
	t18 = t17 != t                                                     bool
	if t18 goto 1 else 2
4:                                                           cond.false P:1 S:2
	t19 = t5 > t9                                                      bool
	if t19 goto 1 else 3
5:                                                              if.then P:1 S:1
	t20 = &timers.t [#6]                                          *[]*timer
	t21 = *t20                                                     []*timer
	t22 = &t21[t5]                                                  **timer
	t23 = &timers.t [#6]                                          *[]*timer
	t24 = *t23                                                     []*timer
	t25 = &t24[t9]                                                  **timer
	t26 = *t25                                                       *timer
	*t22 = t26
	t27 = &timers.t [#6]                                          *[]*timer
	t28 = *t27                                                     []*timer
	t29 = &t28[t5]                                                  **timer
	t30 = *t29                                                       *timer
	t31 = &t30.i [#0]                                                  *int
	*t31 = t5
	jump 6
6:                                                              if.done P:2 S:2
	t32 = &timers.t [#6]                                          *[]*timer
	t33 = *t32                                                     []*timer
	t34 = &t33[t9]                                                  **timer
	*t34 = nil:*timer
	t35 = &timers.t [#6]                                          *[]*timer
	t36 = &timers.t [#6]                                          *[]*timer
	t37 = *t36                                                     []*timer
	t38 = slice t37[:t9]                                           []*timer
	*t35 = t38
	t39 = t5 != t9                                                     bool
	if t39 goto 7 else 8
7:                                                              if.then P:1 S:1
	t40 = siftupTimer(t5)                                                ()
	t41 = siftdownTimer(t5)                                              ()
	jump 8
8:                                                              if.done P:2 S:0
	t42 = &timers.lock [#0]                                          *mutex
	t43 = unlock(t42)                                                    ()
	return true:bool

# Name: runtime.timerproc
# Package: runtime
# Location: /usr/local/go/src/runtime/time.go:151:6
func timerproc():
0:                                                                entry P:0 S:1
	t0 = &timers.gp [#1]                                                **g
	t1 = getg()                                                          *g
	*t0 = t1
	t2 = &timers.gp [#1]                                                **g
	t3 = *t2                                                             *g
	t4 = &t3.issystem [#14]                                           *bool
	*t4 = true:bool
	jump 1
1:                                                             for.body P:3 S:1
	t5 = phi [0: nil:*timer, 16: t24, 17: t24] #t                    *timer
	t6 = phi [0: nil:func(interface{}, uintptr), 16: t15, 17: t15] #f func(interface{}, uintptr)
	t7 = phi [0: nil:interface{}, 16: t16, 17: t16] #arg        interface{}
	t8 = phi [0: 0:uintptr, 16: t17, 17: t17] #seq                  uintptr
	t9 = phi [0: 0:int, 16: t18, 17: t18] #last                         int
	t10 = &timers.lock [#0]                                          *mutex
	t11 = lock(t10)                                                      ()
	t12 = &timers.sleeping [#3]                                       *bool
	*t12 = false:bool
	t13 = nanotime()                                                  int64
	jump 2
2:                                                             for.body P:2 S:2
	t14 = phi [1: t5, 15: t29] #t                                    *timer
	t15 = phi [1: t6, 15: t51] #f                func(interface{}, uintptr)
	t16 = phi [1: t7, 15: t53] #arg                             interface{}
	t17 = phi [1: t8, 15: t55] #seq                                 uintptr
	t18 = phi [1: t9, 15: t49] #last                                    int
	t19 = &timers.t [#6]                                          *[]*timer
	t20 = *t19                                                     []*timer
	t21 = len(t20)                                                      int
	t22 = t21 == 0:int                                                 bool
	if t22 goto 4 else 5
3:                                                             for.done P:2 S:2
	t23 = phi [4: -1:int64, 5: t32] #delta                            int64
	t24 = phi [4: t14, 5: t29] #t                                    *timer
	t25 = t23 < 0:int64                                                bool
	if t25 goto 16 else 18
4:                                                              if.then P:1 S:1
	jump 3
5:                                                              if.done P:1 S:2
	t26 = &timers.t [#6]                                          *[]*timer
	t27 = *t26                                                     []*timer
	t28 = &t27[0:int]                                               **timer
	t29 = *t28                                                       *timer
	t30 = &t29.when [#1]                                             *int64
	t31 = *t30                                                        int64
	t32 = t31 - t13                                                   int64
	t33 = t32 > 0:int64                                                bool
	if t33 goto 3 else 6
6:                                                              if.done P:1 S:2
	t34 = &t29.period [#2]                                           *int64
	t35 = *t34                                                        int64
	t36 = t35 > 0:int64                                                bool
	if t36 goto 7 else 9
7:                                                              if.then P:1 S:1
	t37 = &t29.when [#1]                                             *int64
	t38 = &t29.period [#2]                                           *int64
	t39 = *t38                                                        int64
	t40 = -t32                                                        int64
	t41 = &t29.period [#2]                                           *int64
	t42 = *t41                                                        int64
	t43 = t40 / t42                                                   int64
	t44 = 1:int64 + t43                                               int64
	t45 = t39 * t44                                                   int64
	t46 = *t37                                                        int64
	t47 = t46 + t45                                                   int64
	*t37 = t47
	t48 = siftdownTimer(0:int)                                           ()
	jump 8
8:                                                              if.done P:2 S:2
	t49 = phi [7: t18, 13: t61] #last                                   int
	t50 = &t29.f [#3]                           *func(interface{}, uintptr)
	t51 = *t50                                   func(interface{}, uintptr)
	t52 = &t29.arg [#4]                                        *interface{}
	t53 = *t52                                                  interface{}
	t54 = &t29.seq [#5]                                            *uintptr
	t55 = *t54                                                      uintptr
	t56 = &timers.lock [#0]                                          *mutex
	t57 = unlock(t56)                                                    ()
	if false:untyped bool goto 14 else 15
9:                                                              if.else P:1 S:2
	t58 = &timers.t [#6]                                          *[]*timer
	t59 = *t58                                                     []*timer
	t60 = len(t59)                                                      int
	t61 = t60 - 1:int                                                   int
	t62 = t61 > 0:int                                                  bool
	if t62 goto 10 else 11
10:                                                             if.then P:1 S:1
	t63 = &timers.t [#6]                                          *[]*timer
	t64 = *t63                                                     []*timer
	t65 = &t64[0:int]                                               **timer
	t66 = &timers.t [#6]                                          *[]*timer
	t67 = *t66                                                     []*timer
	t68 = &t67[t61]                                                 **timer
	t69 = *t68                                                       *timer
	*t65 = t69
	t70 = &timers.t [#6]                                          *[]*timer
	t71 = *t70                                                     []*timer
	t72 = &t71[0:int]                                               **timer
	t73 = *t72                                                       *timer
	t74 = &t73.i [#0]                                                  *int
	*t74 = 0:int
	jump 11
11:                                                             if.done P:2 S:2
	t75 = &timers.t [#6]                                          *[]*timer
	t76 = *t75                                                     []*timer
	t77 = &t76[t61]                                                 **timer
	*t77 = nil:*timer
	t78 = &timers.t [#6]                                          *[]*timer
	t79 = &timers.t [#6]                                          *[]*timer
	t80 = *t79                                                     []*timer
	t81 = slice t80[:t61]                                          []*timer
	*t78 = t81
	t82 = t61 > 0:int                                                  bool
	if t82 goto 12 else 13
12:                                                             if.then P:1 S:1
	t83 = siftdownTimer(0:int)                                           ()
	jump 13
13:                                                             if.done P:2 S:1
	t84 = &t29.i [#0]                                                  *int
	*t84 = -1:int
	jump 8
14:                                                             if.then P:1 S:1
	t85 = convert unsafe.Pointer <- *timer (t29)             unsafe.Pointer
	t86 = raceacquire(t85)                                               ()
	jump 15
15:                                                             if.done P:2 S:1
	t87 = t51(t53, t55)                                                  ()
	t88 = &timers.lock [#0]                                          *mutex
	t89 = lock(t88)                                                      ()
	jump 2
16:                                                             if.then P:2 S:1
	t90 = &timers.rescheduling [#4]                                   *bool
	*t90 = true:bool
	t91 = &timers.lock [#0]                                          *mutex
	t92 = goparkunlock(t91, "timer goroutine (...":string)               ()
	jump 1
17:                                                             if.done P:1 S:1
	t93 = &timers.sleeping [#3]                                       *bool
	*t93 = true:bool
	t94 = &timers.waitnote [#5]                                       *note
	t95 = noteclear(t94)                                                 ()
	t96 = &timers.lock [#0]                                          *mutex
	t97 = unlock(t96)                                                    ()
	t98 = &timers.waitnote [#5]                                       *note
	t99 = notetsleepg(t98, t23)                                        bool
	jump 1
18:                                                          cond.false P:1 S:2
	t100 = *faketime                                                  int64
	t101 = t100 > 0:int64                                              bool
	if t101 goto 16 else 17

# Name: runtime.timejump
# Package: runtime
# Location: /usr/local/go/src/runtime/time.go:211:6
func timejump() *g:
0:                                                                entry P:0 S:2
	t0 = *faketime                                                    int64
	t1 = t0 == 0:int64                                                 bool
	if t1 goto 1 else 2
1:                                                              if.then P:1 S:0
	return nil:*g
2:                                                              if.done P:1 S:2
	t2 = &timers.lock [#0]                                           *mutex
	t3 = lock(t2)                                                        ()
	t4 = &timers.created [#2]                                         *bool
	t5 = *t4                                                           bool
	if t5 goto 5 else 3
3:                                                              if.then P:2 S:0
	t6 = &timers.lock [#0]                                           *mutex
	t7 = unlock(t6)                                                      ()
	return nil:*g
4:                                                              if.done P:1 S:2
	t8 = *faketime                                                    int64
	t9 = &timers.t [#6]                                           *[]*timer
	t10 = *t9                                                      []*timer
	t11 = &t10[0:int]                                               **timer
	t12 = *t11                                                       *timer
	t13 = &t12.when [#1]                                             *int64
	t14 = *t13                                                        int64
	t15 = t8 < t14                                                     bool
	if t15 goto 6 else 7
5:                                                           cond.false P:1 S:2
	t16 = &timers.t [#6]                                          *[]*timer
	t17 = *t16                                                     []*timer
	t18 = len(t17)                                                      int
	t19 = t18 == 0:int                                                 bool
	if t19 goto 3 else 4
6:                                                              if.then P:1 S:2
	t20 = &timers.t [#6]                                          *[]*timer
	t21 = *t20                                                     []*timer
	t22 = &t21[0:int]                                               **timer
	t23 = *t22                                                       *timer
	t24 = &t23.when [#1]                                             *int64
	t25 = *t24                                                        int64
	*faketime = t25
	t26 = &timers.rescheduling [#4]                                   *bool
	t27 = *t26                                                         bool
	if t27 goto 8 else 7
7:                                                              if.done P:3 S:0
	t28 = phi [4: nil:*g, 6: nil:*g, 8: t33] #gp                         *g
	t29 = &timers.lock [#0]                                          *mutex
	t30 = unlock(t29)                                                    ()
	return t28
8:                                                              if.then P:1 S:1
	t31 = &timers.rescheduling [#4]                                   *bool
	*t31 = false:bool
	t32 = &timers.gp [#1]                                               **g
	t33 = *t32                                                           *g
	jump 7

# Name: runtime.siftupTimer
# Package: runtime
# Location: /usr/local/go/src/runtime/time.go:236:6
func siftupTimer(i int):
0:                                                                entry P:0 S:1
	t0 = &timers.t [#6]                                           *[]*timer
	t1 = *t0                                                       []*timer
	t2 = &t1[i]                                                     **timer
	t3 = *t2                                                         *timer
	t4 = &t3.when [#1]                                               *int64
	t5 = *t4                                                          int64
	t6 = &t1[i]                                                     **timer
	t7 = *t6                                                         *timer
	jump 3
1:                                                             for.body P:1 S:2
	t8 = t15 - 1:int                                                    int
	t9 = t8 / 4:int                                                     int
	t10 = &t1[t9]                                                   **timer
	t11 = *t10                                                       *timer
	t12 = &t11.when [#1]                                             *int64
	t13 = *t12                                                        int64
	t14 = t5 >= t13                                                    bool
	if t14 goto 2 else 4
2:                                                             for.done P:2 S:0
	return
3:                                                             for.loop P:2 S:2
	t15 = phi [0: i, 4: t9] #i                                          int
	t16 = t15 > 0:int                                                  bool
	if t16 goto 1 else 2
4:                                                              if.done P:1 S:1
	t17 = &t1[t15]                                                  **timer
	t18 = &t1[t9]                                                   **timer
	t19 = *t18                                                       *timer
	*t17 = t19
	t20 = &t1[t15]                                                  **timer
	t21 = *t20                                                       *timer
	t22 = &t21.i [#0]                                                  *int
	*t22 = t15
	t23 = &t1[t9]                                                   **timer
	*t23 = t7
	t24 = &t1[t9]                                                   **timer
	t25 = *t24                                                       *timer
	t26 = &t25.i [#0]                                                  *int
	*t26 = t9
	jump 3

# Name: runtime.siftdownTimer
# Package: runtime
# Location: /usr/local/go/src/runtime/time.go:253:6
func siftdownTimer(i int):
0:                                                                entry P:0 S:1
	t0 = &timers.t [#6]                                           *[]*timer
	t1 = *t0                                                       []*timer
	t2 = len(t1)                                                        int
	t3 = &t1[i]                                                     **timer
	t4 = *t3                                                         *timer
	t5 = &t4.when [#1]                                               *int64
	t6 = *t5                                                          int64
	t7 = &t1[i]                                                     **timer
	t8 = *t7                                                         *timer
	jump 1
1:                                                             for.body P:2 S:2
	t9 = phi [0: i, 13: t43] #i                                         int
	t10 = phi [0: 0:int64, 13: t44] #w                                int64
	t11 = phi [0: 0:int64, 13: t45] #w3                               int64
	t12 = t9 * 4:int                                                    int
	t13 = t12 + 1:int                                                   int
	t14 = t13 + 2:int                                                   int
	t15 = t13 >= t2                                                    bool
	if t15 goto 2 else 3
2:                                                             for.done P:2 S:0
	return
3:                                                              if.done P:1 S:2
	t16 = &t1[t13]                                                  **timer
	t17 = *t16                                                       *timer
	t18 = &t17.when [#1]                                             *int64
	t19 = *t18                                                        int64
	t20 = t13 + 1:int                                                   int
	t21 = t20 < t2                                                     bool
	if t21 goto 6 else 5
4:                                                              if.then P:1 S:1
	t22 = t13 + 1:int                                                   int
	t23 = &t1[t22]                                                  **timer
	t24 = *t23                                                       *timer
	t25 = &t24.when [#1]                                             *int64
	t26 = *t25                                                        int64
	t27 = t13 + 1:int                                                   int
	jump 5
5:                                                              if.done P:3 S:2
	t28 = phi [3: t13, 6: t13, 4: t27] #c                               int
	t29 = phi [3: t19, 6: t19, 4: t26] #w                             int64
	t30 = t14 < t2                                                     bool
	if t30 goto 7 else 8
6:                                                            cond.true P:1 S:2
	t31 = t13 + 1:int                                                   int
	t32 = &t1[t31]                                                  **timer
	t33 = *t32                                                       *timer
	t34 = &t33.when [#1]                                             *int64
	t35 = *t34                                                        int64
	t36 = t35 < t19                                                    bool
	if t36 goto 4 else 5
7:                                                              if.then P:1 S:2
	t37 = &t1[t14]                                                  **timer
	t38 = *t37                                                       *timer
	t39 = &t38.when [#1]                                             *int64
	t40 = *t39                                                        int64
	t41 = t14 + 1:int                                                   int
	t42 = t41 < t2                                                     bool
	if t42 goto 11 else 10
8:                                                              if.done P:3 S:2
	t43 = phi [5: t28, 10: t28, 12: t53] #c                             int
	t44 = phi [5: t29, 10: t29, 12: t54] #w                           int64
	t45 = phi [5: t11, 10: t54, 12: t54] #w3                          int64
	t46 = t44 >= t6                                                    bool
	if t46 goto 2 else 13
9:                                                              if.then P:1 S:1
	t47 = t14 + 1:int                                                   int
	t48 = &t1[t47]                                                  **timer
	t49 = *t48                                                       *timer
	t50 = &t49.when [#1]                                             *int64
	t51 = *t50                                                        int64
	t52 = t14 + 1:int                                                   int
	jump 10
10:                                                             if.done P:3 S:2
	t53 = phi [7: t14, 11: t14, 9: t52] #c3                             int
	t54 = phi [7: t40, 11: t40, 9: t51] #w3                           int64
	t55 = t54 < t29                                                    bool
	if t55 goto 12 else 8
11:                                                           cond.true P:1 S:2
	t56 = t14 + 1:int                                                   int
	t57 = &t1[t56]                                                  **timer
	t58 = *t57                                                       *timer
	t59 = &t58.when [#1]                                             *int64
	t60 = *t59                                                        int64
	t61 = t60 < t40                                                    bool
	if t61 goto 9 else 10
12:                                                             if.then P:1 S:1
	jump 8
13:                                                             if.done P:1 S:1
	t62 = &t1[t9]                                                   **timer
	t63 = &t1[t43]                                                  **timer
	t64 = *t63                                                       *timer
	*t62 = t64
	t65 = &t1[t9]                                                   **timer
	t66 = *t65                                                       *timer
	t67 = &t66.i [#0]                                                  *int
	*t67 = t9
	t68 = &t1[t43]                                                  **timer
	*t68 = t8
	t69 = &t1[t43]                                                  **timer
	t70 = *t69                                                       *timer
	t71 = &t70.i [#0]                                                  *int
	*t71 = t43
	jump 1

# Name: runtime.tracebackinit
# Package: runtime
# Location: /usr/local/go/src/runtime/traceback.go:48:6
func tracebackinit():
0:                                                                entry P:0 S:0
	t0 = make interface{} <- func(siz int32, fn *funcval) (deferproc) interface{}
	t1 = funcPC(t0)                                                 uintptr
	*deferprocPC = t1
	t2 = make interface{} <- func() (goexit)                    interface{}
	t3 = funcPC(t2)                                                 uintptr
	*goexitPC = t3
	t4 = make interface{} <- func(fv *funcval, argp uintptr) (jmpdefer) interface{}
	t5 = funcPC(t4)                                                 uintptr
	*jmpdeferPC = t5
	t6 = make interface{} <- func(fn func(*g)) (mcall)          interface{}
	t7 = funcPC(t6)                                                 uintptr
	*mcallPC = t7
	t8 = make interface{} <- func() (morestack)                 interface{}
	t9 = funcPC(t8)                                                 uintptr
	*morestackPC = t9
	t10 = make interface{} <- func() (mstart)                   interface{}
	t11 = funcPC(t10)                                               uintptr
	*mstartPC = t11
	t12 = make interface{} <- func() (newproc)                  interface{}
	t13 = funcPC(t12)                                               uintptr
	*newprocPC = t13
	t14 = make interface{} <- func() (rt0_go)                   interface{}
	t15 = funcPC(t14)                                               uintptr
	*rt0_goPC = t15
	t16 = make interface{} <- func() (sigpanic)                 interface{}
	t17 = funcPC(t16)                                               uintptr
	*sigpanicPC = t17
	return

# Name: runtime.tracebackdefers
# Package: runtime
# Location: /usr/local/go/src/runtime/traceback.go:66:6
func tracebackdefers(gp *g, callback func(*stkframe, unsafe.Pointer) bool, v unsafe.Pointer):
0:                                                                entry P:0 S:1
	t0 = new stkframe (frame)                                     *stkframe
	t1 = &gp._defer [#4]                                           **_defer
	t2 = *t1                                                        *_defer
	jump 3
1:                                                             for.body P:1 S:2
	t3 = &t6.fn [#4]                                              **funcval
	t4 = *t3                                                       *funcval
	t5 = t4 == nil:*funcval                                            bool
	if t5 goto 4 else 6
2:                                                             for.done P:1 S:0
	return
3:                                                             for.loop P:2 S:2
	t6 = phi [0: t2, 10: t41] #d                                    *_defer
	t7 = phi [0: nil:*_func, 10: t14] #f                             *_func
	t8 = t6 != nil:*_defer                                             bool
	if t8 goto 1 else 2
4:                                                              if.then P:1 S:1
	t9 = &t0.pc [#1]                                               *uintptr
	*t9 = 0:uintptr
	t10 = &t0.fn [#0]                                               **_func
	*t10 = nil:*_func
	t11 = &t0.argp [#7]                                            *uintptr
	*t11 = 0:uintptr
	t12 = &t0.arglen [#8]                                          *uintptr
	*t12 = 0:uintptr
	t13 = &t0.argmap [#9]                                       **bitvector
	*t13 = nil:*bitvector
	jump 5
5:                                                              if.done P:2 S:2
	t14 = phi [4: t7, 8: t28] #f                                     *_func
	t15 = &t0.continpc [#2]                                        *uintptr
	t16 = &t0.pc [#1]                                              *uintptr
	t17 = *t16                                                      uintptr
	*t15 = t17
	t18 = convert unsafe.Pointer <- *stkframe (t0)           unsafe.Pointer
	t19 = noescape(t18)                                      unsafe.Pointer
	t20 = convert *stkframe <- unsafe.Pointer (t19)               *stkframe
	t21 = callback(t20, v)                                             bool
	if t21 goto 10 else 9
6:                                                              if.else P:1 S:2
	t22 = &t0.pc [#1]                                              *uintptr
	t23 = &t4.fn [#0]                                       *unsafe.Pointer
	t24 = *t23                                               unsafe.Pointer
	t25 = convert uintptr <- unsafe.Pointer (t24)                   uintptr
	*t22 = t25
	t26 = &t0.pc [#1]                                              *uintptr
	t27 = *t26                                                      uintptr
	t28 = findfunc(t27)                                              *_func
	t29 = t28 == nil:*_func                                            bool
	if t29 goto 7 else 8
7:                                                              if.then P:1 S:1
	t30 = &t0.pc [#1]                                              *uintptr
	t31 = *t30                                                      uintptr
	t32 = convert hex <- uintptr (t31)                                  hex
	t33 = print("runtime: unknown ...":string, t32, "\n":string)         ()
	t34 = gothrow("unknown pc":string)                                   ()
	jump 8
8:                                                              if.done P:2 S:1
	t35 = &t0.fn [#0]                                               **_func
	*t35 = t28
	t36 = &t0.argp [#7]                                            *uintptr
	t37 = deferArgs(t6)                                      unsafe.Pointer
	t38 = convert uintptr <- unsafe.Pointer (t37)                   uintptr
	*t36 = t38
	t39 = setArgInfo(t0, t28, true:bool)                                 ()
	jump 5
9:                                                              if.then P:1 S:0
	return
10:                                                             if.done P:1 S:1
	t40 = &t6.link [#6]                                            **_defer
	t41 = *t40                                                      *_defer
	jump 3

# Name: runtime.gentraceback
# Package: runtime
# Location: /usr/local/go/src/runtime/traceback.go:99:6
func gentraceback(pc0 uintptr, sp0 uintptr, lr0 uintptr, gp *g, skip int, pcbuf *uintptr, max int, callback func(*stkframe, unsafe.Pointer) bool, v unsafe.Pointer, flags uint) int:
0:                                                                entry P:0 S:2
	t0 = *goexitPC                                                  uintptr
	t1 = t0 == 0:uintptr                                               bool
	if t1 goto 1 else 2
1:                                                              if.then P:1 S:1
	t2 = gothrow("gentraceback befo...":string)                          ()
	jump 2
2:                                                              if.done P:2 S:2
	t3 = getg()                                                          *g
	t4 = t3 == gp                                                      bool
	if t4 goto 5 else 4
3:                                                              if.then P:1 S:1
	t5 = gothrow("gentraceback cann...":string)                          ()
	jump 4
4:                                                              if.done P:3 S:2
	t6 = gotraceback(nil:*bool)                                       int32
	t7 = pc0 == 18446744073709551615:uintptr                           bool
	if t7 goto 8 else 7
5:                                                            cond.true P:1 S:2
	t8 = &t3.m [#21]                                                    **m
	t9 = *t8                                                             *m
	t10 = &t9.curg [#6]                                                 **g
	t11 = *t10                                                           *g
	t12 = t3 == t11                                                    bool
	if t12 goto 3 else 4
6:                                                              if.then P:1 S:2
	t13 = &gp.syscallsp [#6]                                       *uintptr
	t14 = *t13                                                      uintptr
	t15 = t14 != 0:uintptr                                             bool
	if t15 goto 9 else 10
7:                                                              if.done P:6 S:2
	t16 = phi [4: pc0, 8: pc0, 9: t24, 10: t29, 11: t24, 12: t29] #pc0 uintptr
	t17 = phi [4: sp0, 8: sp0, 9: t26, 10: t32, 11: t26, 12: t32] #sp0 uintptr
	t18 = phi [4: lr0, 8: lr0, 9: lr0, 10: lr0, 11: 0:uintptr, 12: t35] #lr0 uintptr
	t19 = new stkframe (frame)                                    *stkframe
	t20 = &t19.pc [#1]                                             *uintptr
	*t20 = t16
	t21 = &t19.sp [#4]                                             *uintptr
	*t21 = t17
	if false:untyped bool goto 13 else 14
8:                                                            cond.true P:1 S:2
	t22 = sp0 == 18446744073709551615:uintptr                          bool
	if t22 goto 6 else 7
9:                                                              if.then P:1 S:2
	t23 = &gp.syscallpc [#7]                                       *uintptr
	t24 = *t23                                                      uintptr
	t25 = &gp.syscallsp [#6]                                       *uintptr
	t26 = *t25                                                      uintptr
	if false:untyped bool goto 11 else 7
10:                                                             if.else P:1 S:2
	t27 = &gp.sched [#5]                                             *gobuf
	t28 = &t27.pc [#1]                                             *uintptr
	t29 = *t28                                                      uintptr
	t30 = &gp.sched [#5]                                             *gobuf
	t31 = &t30.sp [#0]                                             *uintptr
	t32 = *t31                                                      uintptr
	if false:untyped bool goto 12 else 7
11:                                                             if.then P:1 S:1
	jump 7
12:                                                             if.then P:1 S:1
	t33 = &gp.sched [#5]                                             *gobuf
	t34 = &t33.lr [#5]                                             *uintptr
	t35 = *t34                                                      uintptr
	jump 7
13:                                                             if.then P:1 S:1
	t36 = &t19.lr [#3]                                             *uintptr
	*t36 = t18
	jump 14
14:                                                             if.done P:2 S:2
	t37 = pcbuf == nil:*uintptr                                        bool
	if t37 goto 15 else 16
15:                                                           binop.rhs P:1 S:1
	t38 = callback == nil:func(*stkframe, unsafe.Pointer) bool         bool
	jump 16
16:                                                          binop.done P:2 S:1
	t39 = phi [14: false:bool, 15: t38] #&&                            bool
	t40 = &gp._defer [#4]                                          **_defer
	t41 = *t40                                                      *_defer
	jump 19
17:                                                            for.body P:1 S:1
	t42 = &t47.link [#6]                                           **_defer
	t43 = *t42                                                      *_defer
	jump 19
18:                                                            for.done P:2 S:2
	t44 = &t19.pc [#1]                                             *uintptr
	t45 = *t44                                                      uintptr
	t46 = t45 == 0:uintptr                                             bool
	if t46 goto 21 else 22
19:                                                            for.loop P:2 S:2
	t47 = phi [16: t41, 17: t43] #_defer                            *_defer
	t48 = t47 != nil:*_defer                                           bool
	if t48 goto 20 else 18
20:                                                           cond.true P:1 S:2
	t49 = &t47.argp [#2]                                           *uintptr
	t50 = *t49                                                      uintptr
	t51 = t50 == 18446744073709551615:uintptr                          bool
	if t51 goto 17 else 18
21:                                                             if.then P:1 S:2
	if false:untyped bool goto 23 else 24
22:                                                             if.done P:3 S:2
	t52 = &t19.pc [#1]                                             *uintptr
	t53 = *t52                                                      uintptr
	t54 = findfunc(t53)                                              *_func
	t55 = t54 == nil:*_func                                            bool
	if t55 goto 25 else 26
23:                                                             if.then P:1 S:1
	t56 = &t19.pc [#1]                                             *uintptr
	t57 = &t19.sp [#4]                                             *uintptr
	t58 = *t57                                                      uintptr
	t59 = convert unsafe.Pointer <- uintptr (t58)            unsafe.Pointer
	t60 = convert *uintptr <- unsafe.Pointer (t59)                 *uintptr
	t61 = *t60                                                      uintptr
	*t56 = t61
	t62 = &t19.lr [#3]                                             *uintptr
	*t62 = 0:uintptr
	jump 22
24:                                                             if.else P:1 S:1
	t63 = &t19.pc [#1]                                             *uintptr
	t64 = &t19.sp [#4]                                             *uintptr
	t65 = *t64                                                      uintptr
	t66 = convert unsafe.Pointer <- uintptr (t65)            unsafe.Pointer
	t67 = convert *uintreg <- unsafe.Pointer (t66)                 *uintreg
	t68 = *t67                                                      uintreg
	t69 = convert uintptr <- uintreg (t68)                          uintptr
	*t63 = t69
	t70 = &t19.sp [#4]                                             *uintptr
	t71 = *t70                                                      uintptr
	t72 = t71 + 8:uintptr                                           uintptr
	*t70 = t72
	jump 22
25:                                                             if.then P:1 S:2
	t73 = callback != nil:func(*stkframe, unsafe.Pointer) bool         bool
	if t73 goto 27 else 28
26:                                                             if.done P:1 S:1
	t74 = &t19.fn [#0]                                              **_func
	*t74 = t54
	jump 31
27:                                                             if.then P:1 S:1
	t75 = &t19.pc [#1]                                             *uintptr
	t76 = *t75                                                      uintptr
	t77 = convert hex <- uintptr (t76)                                  hex
	t78 = print("runtime: unknown pc ":string, t77, "\n":string)         ()
	t79 = gothrow("unknown pc":string)                                   ()
	jump 28
28:                                                             if.done P:2 S:0
	return 0:int
29:                                                            for.body P:1 S:2
	t80 = &t19.fn [#0]                                              **_func
	t81 = *t80                                                       *_func
	t82 = &t19.fp [#5]                                             *uintptr
	t83 = *t82                                                      uintptr
	t84 = t83 == 0:uintptr                                             bool
	if t84 goto 32 else 33
30:                                                            for.done P:2 S:2
	t85 = phi [31: t90, 105: t211] #nprint                              int
	t86 = phi [31: t93, 105: t200] #_defer                          *_defer
	t87 = phi [31: t94, 105: t212] #n                                   int
	t88 = pcbuf == nil:*uintptr                                        bool
	if t88 goto 114 else 113
31:                                                            for.loop P:6 S:2
	t89 = phi [26: skip, 106: t210, 108: t210, 109: t210, 110: t210, 111: t210] #skip int
	t90 = phi [26: 0:int, 106: t211, 108: t211, 109: t211, 110: t211, 111: t211] #nprint int
	t91 = phi [26: false:bool, 106: t220, 108: t220, 109: t220, 110: t220, 111: t220] #waspanic bool
	t92 = phi [26: false:bool, 106: t318, 108: t318, 109: t318, 110: t318, 111: t318] #wasnewproc bool
	t93 = phi [26: t47, 106: t200, 108: t200, 109: t200, 110: t200, 111: t200] #_defer *_defer
	t94 = phi [26: 0:int, 106: t212, 108: t212, 109: t212, 110: t212, 111: t212] #n int
	t95 = phi [26: 0:uintptr, 106: t213, 108: t213, 109: t213, 110: t213, 111: t213] #tracepc uintptr
	t96 = phi [26: nil:*[100]uintptr, 106: t214, 108: t214, 109: t214, 110: t214, 111: t214] #argp *[100]uintptr
	t97 = phi [26: 0:uintptr, 106: t215, 108: t215, 109: t215, 110: t215, 111: t215] #i uintptr
	t98 = phi [26: 0:int32, 106: t216, 108: t216, 109: t216, 110: t216, 111: t216] #line int32
	t99 = t94 < max                                                    bool
	if t99 goto 29 else 30
32:                                                             if.then P:1 S:2
	t100 = &t19.fp [#5]                                            *uintptr
	t101 = &t19.sp [#4]                                            *uintptr
	t102 = *t101                                                    uintptr
	t103 = &t19.pc [#1]                                            *uintptr
	t104 = *t103                                                    uintptr
	t105 = funcspdelta(t81, t104)                                     int32
	t106 = convert uintptr <- int32 (t105)                          uintptr
	t107 = t102 + t106                                              uintptr
	*t100 = t107
	if false:untyped bool goto 33 else 34
33:                                                             if.done P:3 S:2
	t108 = topofstack(t81)                                             bool
	if t108 goto 35 else 37
34:                                                             if.then P:1 S:1
	t109 = &t19.fp [#5]                                            *uintptr
	t110 = *t109                                                    uintptr
	t111 = t110 + 8:uintptr                                         uintptr
	*t109 = t111
	jump 33
35:                                                             if.then P:1 S:1
	t112 = &t19.lr [#3]                                            *uintptr
	*t112 = 0:uintptr
	jump 36
36:                                                             if.done P:5 S:2
	t113 = phi [35: nil:*_func, 42: nil:*_func, 44: t127, 50: t127, 51: t127] #flr *_func
	t114 = &t19.varp [#6]                                          *uintptr
	t115 = &t19.fp [#5]                                            *uintptr
	t116 = *t115                                                    uintptr
	*t114 = t116
	if false:untyped bool goto 53 else 52
37:                                                             if.else P:1 S:2
	if false:untyped bool goto 40 else 39
38:                                                             if.then P:1 S:2
	t117 = callback != nil:func(*stkframe, unsafe.Pointer) bool        bool
	if t117 goto 41 else 42
39:                                                             if.else P:2 S:2
	if false:untyped bool goto 43 else 45
40:                                                           cond.true P:1 S:2
	t118 = &t81.entry [#0]                                         *uintptr
	t119 = *t118                                                    uintptr
	t120 = *jmpdeferPC                                              uintptr
	t121 = t119 == t120                                                bool
	if t121 goto 38 else 39
41:                                                             if.then P:1 S:1
	t122 = gothrow("traceback_arm: fo...":string)                        ()
	jump 42
42:                                                             if.done P:2 S:1
	t123 = &t19.lr [#3]                                            *uintptr
	*t123 = 0:uintptr
	jump 36
43:                                                             if.then P:1 S:2
	t124 = t94 == 0:int                                                bool
	if t124 goto 48 else 47
44:                                                             if.done P:4 S:2
	t125 = &t19.lr [#3]                                            *uintptr
	t126 = *t125                                                    uintptr
	t127 = findfunc(t126)                                            *_func
	t128 = t127 == nil:*_func                                          bool
	if t128 goto 50 else 36
45:                                                             if.else P:1 S:2
	t129 = &t19.lr [#3]                                            *uintptr
	t130 = *t129                                                    uintptr
	t131 = t130 == 0:uintptr                                           bool
	if t131 goto 49 else 44
46:                                                             if.then P:2 S:1
	t132 = &t19.lr [#3]                                            *uintptr
	t133 = &t19.sp [#4]                                            *uintptr
	t134 = *t133                                                    uintptr
	t135 = convert unsafe.Pointer <- uintptr (t134)          unsafe.Pointer
	t136 = convert *uintptr <- unsafe.Pointer (t135)               *uintptr
	t137 = *t136                                                    uintptr
	*t132 = t137
	jump 44
47:                                                          cond.false P:2 S:2
	t138 = &t19.lr [#3]                                            *uintptr
	t139 = *t138                                                    uintptr
	t140 = t139 == 0:uintptr                                           bool
	if t140 goto 46 else 44
48:                                                           cond.true P:1 S:2
	t141 = &t19.sp [#4]                                            *uintptr
	t142 = *t141                                                    uintptr
	t143 = &t19.fp [#5]                                            *uintptr
	t144 = *t143                                                    uintptr
	t145 = t142 < t144                                                 bool
	if t145 goto 46 else 47
49:                                                             if.then P:1 S:1
	t146 = &t19.lr [#3]                                            *uintptr
	t147 = &t19.fp [#5]                                            *uintptr
	t148 = *t147                                                    uintptr
	t149 = t148 - 8:uintptr                                         uintptr
	t150 = convert unsafe.Pointer <- uintptr (t149)          unsafe.Pointer
	t151 = convert *uintreg <- unsafe.Pointer (t150)               *uintreg
	t152 = *t151                                                    uintreg
	t153 = convert uintptr <- uintreg (t152)                        uintptr
	*t146 = t153
	jump 44
50:                                                             if.then P:1 S:2
	t154 = callback != nil:func(*stkframe, unsafe.Pointer) bool        bool
	if t154 goto 51 else 36
51:                                                             if.then P:1 S:1
	t155 = gofuncname(t81)                                           string
	t156 = &t19.lr [#3]                                            *uintptr
	t157 = *t156                                                    uintptr
	t158 = convert hex <- uintptr (t157)                                hex
	t159 = print("runtime: unexpect...":string, t155, " called from ":string, t158, "\n":string) ()
	t160 = gothrow("unknown caller pc":string)                           ()
	jump 36
52:                                                             if.then P:1 S:1
	t161 = &t19.varp [#6]                                          *uintptr
	t162 = *t161                                                    uintptr
	t163 = t162 - 8:uintptr                                         uintptr
	*t161 = t163
	jump 53
53:                                                             if.done P:2 S:2
	t164 = callback != nil:func(*stkframe, unsafe.Pointer) bool        bool
	if t164 goto 54 else 56
54:                                                             if.then P:2 S:2
	t165 = &t19.argp [#7]                                          *uintptr
	t166 = &t19.fp [#5]                                            *uintptr
	t167 = *t166                                                    uintptr
	*t165 = t167
	if false:untyped bool goto 57 else 58
55:                                                             if.done P:2 S:2
	if false:untyped bool goto 59 else 61
56:                                                          cond.false P:1 S:2
	if t39 goto 54 else 55
57:                                                             if.then P:1 S:1
	t168 = &t19.argp [#7]                                          *uintptr
	t169 = *t168                                                    uintptr
	t170 = t169 + 8:uintptr                                         uintptr
	*t168 = t170
	jump 58
58:                                                             if.done P:2 S:1
	t171 = callback != nil:func(*stkframe, unsafe.Pointer) bool        bool
	t172 = setArgInfo(t19, t81, t171)                                    ()
	jump 55
59:                                                             if.then P:1 S:2
	t173 = &t19.fp [#5]                                            *uintptr
	t174 = *t173                                                    uintptr
	t175 = &t19.sp [#4]                                            *uintptr
	t176 = *t175                                                    uintptr
	t177 = t174 != t176                                                bool
	if t177 goto 62 else 60
60:                                                             if.done P:5 S:2
	t178 = phi [59: 0:uintptr, 61: t183, 62: t186, 63: t187, 64: t188] #sparg uintptr
	t179 = &t19.continpc [#2]                                      *uintptr
	t180 = &t19.pc [#1]                                            *uintptr
	t181 = *t180                                                    uintptr
	*t179 = t181
	if t91 goto 65 else 71
61:                                                             if.else P:1 S:2
	t182 = &t19.sp [#4]                                            *uintptr
	t183 = *t182                                                    uintptr
	if t92 goto 64 else 60
62:                                                             if.then P:1 S:2
	t184 = &t19.sp [#4]                                            *uintptr
	t185 = *t184                                                    uintptr
	t186 = t185 + 8:uintptr                                         uintptr
	if t92 goto 63 else 60
63:                                                             if.then P:1 S:1
	t187 = t186 + 24:uintptr                                        uintptr
	jump 60
64:                                                             if.then P:1 S:1
	t188 = t183 + 16:uintptr                                        uintptr
	jump 60
65:                                                             if.then P:1 S:2
	t189 = t93 != nil:*_defer                                          bool
	if t189 goto 68 else 67
66:                                                             if.then P:1 S:1
	t190 = &t19.continpc [#2]                                      *uintptr
	t191 = &t93.pc [#3]                                            *uintptr
	t192 = *t191                                                    uintptr
	*t190 = t192
	jump 71
67:                                                             if.else P:2 S:1
	t193 = &t19.continpc [#2]                                      *uintptr
	*t193 = 0:uintptr
	jump 71
68:                                                           cond.true P:1 S:2
	t194 = &t93.argp [#2]                                          *uintptr
	t195 = *t194                                                    uintptr
	t196 = t195 == t178                                                bool
	if t196 goto 66 else 67
69:                                                            for.body P:2 S:1
	t197 = &t200.link [#6]                                         **_defer
	t198 = *t197                                                    *_defer
	jump 71
70:                                                            for.done P:2 S:2
	t199 = t89 > 0:int                                                 bool
	if t199 goto 74 else 75
71:                                                            for.loop P:4 S:2
	t200 = phi [60: t93, 69: t198, 66: t93, 67: t93] #_defer        *_defer
	t201 = t200 != nil:*_defer                                         bool
	if t201 goto 72 else 70
72:                                                           cond.true P:1 S:2
	t202 = &t200.argp [#2]                                         *uintptr
	t203 = *t202                                                    uintptr
	t204 = t203 == t178                                                bool
	if t204 goto 69 else 73
73:                                                          cond.false P:1 S:2
	t205 = &t200.argp [#2]                                         *uintptr
	t206 = *t205                                                    uintptr
	t207 = t206 == 18446744073709551615:uintptr                        bool
	if t207 goto 69 else 70
74:                                                             if.then P:1 S:1
	t208 = t89 - 1:int                                                  int
	jump 76
75:                                                             if.done P:1 S:2
	t209 = pcbuf != nil:*uintptr                                       bool
	if t209 goto 77 else 78
76:                                                             skipped P:2 S:2
	t210 = phi [74: t208, 83: t89] #skip                                int
	t211 = phi [74: t90, 83: t237] #nprint                              int
	t212 = phi [74: t94, 83: t242] #n                                   int
	t213 = phi [74: t95, 83: t238] #tracepc                         uintptr
	t214 = phi [74: t96, 83: t239] #argp                      *[100]uintptr
	t215 = phi [74: t97, 83: t240] #i                               uintptr
	t216 = phi [74: t98, 83: t241] #line                              int32
	t217 = &t81.entry [#0]                                         *uintptr
	t218 = *t217                                                    uintptr
	t219 = *sigpanicPC                                              uintptr
	t220 = t218 == t219                                                bool
	t221 = &t81.entry [#0]                                         *uintptr
	t222 = *t221                                                    uintptr
	t223 = *newprocPC                                               uintptr
	t224 = t222 == t223                                                bool
	if t224 goto 105 else 104
77:                                                             if.then P:1 S:1
	t225 = convert unsafe.Pointer <- *uintptr (pcbuf)        unsafe.Pointer
	t226 = convert *[1048576]uintptr <- unsafe.Pointer (t225) *[1048576]uintptr
	t227 = &t226[t94]                                              *uintptr
	t228 = &t19.pc [#1]                                            *uintptr
	t229 = *t228                                                    uintptr
	*t227 = t229
	jump 78
78:                                                             if.done P:2 S:2
	t230 = callback != nil:func(*stkframe, unsafe.Pointer) bool        bool
	if t230 goto 79 else 80
79:                                                             if.then P:1 S:2
	t231 = convert unsafe.Pointer <- *stkframe (t19)         unsafe.Pointer
	t232 = noescape(t231)                                    unsafe.Pointer
	t233 = convert *stkframe <- unsafe.Pointer (t232)             *stkframe
	t234 = callback(t233, v)                                           bool
	if t234 goto 80 else 81
80:                                                             if.done P:2 S:2
	if t39 goto 82 else 83
81:                                                             if.then P:1 S:0
	return t94
82:                                                             if.then P:1 S:2
	t235 = flags & 1:uint                                              uint
	t236 = t235 != 0:uint                                              bool
	if t236 goto 84 else 85
83:                                                             if.done P:3 S:1
	t237 = phi [80: t90, 85: t90, 101: t307] #nprint                    int
	t238 = phi [80: t95, 85: t95, 101: t248] #tracepc               uintptr
	t239 = phi [80: t96, 85: t96, 101: t254] #argp            *[100]uintptr
	t240 = phi [80: t97, 85: t97, 101: t273] #i                     uintptr
	t241 = phi [80: t98, 85: t98, 101: t265] #line                    int32
	t242 = t94 + 1:int                                                  int
	jump 76
84:                                                             if.then P:2 S:2
	t243 = &t19.pc [#1]                                            *uintptr
	t244 = *t243                                                    uintptr
	t245 = t94 > 0:int                                                 bool
	if t245 goto 89 else 90
85:                                                          cond.false P:1 S:2
	t246 = showframe(t81, gp)                                          bool
	if t246 goto 84 else 83
86:                                                             if.then P:1 S:1
	t247 = t244 - 1:uintptr                                         uintptr
	jump 87
87:                                                             if.done P:4 S:1
	t248 = phi [90: t244, 89: t244, 88: t244, 86: t247] #tracepc    uintptr
	t249 = gofuncname(t81)                                           string
	t250 = print(t249, "(":string)                                       ()
	t251 = &t19.argp [#7]                                          *uintptr
	t252 = *t251                                                    uintptr
	t253 = convert unsafe.Pointer <- uintptr (t252)          unsafe.Pointer
	t254 = convert *[100]uintptr <- unsafe.Pointer (t253)     *[100]uintptr
	jump 93
88:                                                           cond.true P:1 S:2
	if t91 goto 87 else 86
89:                                                           cond.true P:2 S:2
	t255 = &t19.pc [#1]                                            *uintptr
	t256 = *t255                                                    uintptr
	t257 = &t81.entry [#0]                                         *uintptr
	t258 = *t257                                                    uintptr
	t259 = t256 > t258                                                 bool
	if t259 goto 88 else 87
90:                                                          cond.false P:1 S:2
	t260 = flags & 2:uint                                              uint
	t261 = t260 == 0:uint                                              bool
	if t261 goto 89 else 87
91:                                                            for.body P:1 S:2
	t262 = t273 >= 10:uintptr                                          bool
	if t262 goto 94 else 95
92:                                                            for.done P:2 S:2
	t263 = print(")\n":string)                                           ()
	t264 = new string (file)                                        *string
	t265 = funcline(t81, t248, t264)                                  int32
	t266 = *t264                                                     string
	t267 = print("\t":string, t266, ":":string, t265)                    ()
	t268 = &t19.pc [#1]                                            *uintptr
	t269 = *t268                                                    uintptr
	t270 = &t81.entry [#0]                                         *uintptr
	t271 = *t270                                                    uintptr
	t272 = t269 > t271                                                 bool
	if t272 goto 98 else 99
93:                                                            for.loop P:2 S:2
	t273 = phi [87: 0:uintptr, 97: t286] #i                         uintptr
	t274 = &t19.arglen [#8]                                        *uintptr
	t275 = *t274                                                    uintptr
	t276 = t275 / 8:uintptr                                         uintptr
	t277 = t273 < t276                                                 bool
	if t277 goto 91 else 92
94:                                                             if.then P:1 S:1
	t278 = print(", ...":string)                                         ()
	jump 92
95:                                                             if.done P:1 S:2
	t279 = t273 != 0:uintptr                                           bool
	if t279 goto 96 else 97
96:                                                             if.then P:1 S:1
	t280 = print(", ":string)                                            ()
	jump 97
97:                                                             if.done P:2 S:1
	t281 = convert int <- uintptr (t273)                                int
	t282 = &t254[t281]                                             *uintptr
	t283 = *t282                                                    uintptr
	t284 = convert hex <- uintptr (t283)                                hex
	t285 = print(t284)                                                   ()
	t286 = t273 + 1:uintptr                                         uintptr
	jump 93
98:                                                             if.then P:1 S:1
	t287 = &t19.pc [#1]                                            *uintptr
	t288 = *t287                                                    uintptr
	t289 = &t81.entry [#0]                                         *uintptr
	t290 = *t289                                                    uintptr
	t291 = t288 - t290                                              uintptr
	t292 = convert hex <- uintptr (t291)                                hex
	t293 = print(" +":string, t292)                                      ()
	jump 99
99:                                                             if.done P:2 S:2
	t294 = &t3.m [#21]                                                  **m
	t295 = *t294                                                         *m
	t296 = &t295.throwing [#12]                                      *int32
	t297 = *t296                                                      int32
	t298 = t297 > 0:int32                                              bool
	if t298 goto 103 else 102
100:                                                            if.then P:2 S:1
	t299 = &t19.fp [#5]                                            *uintptr
	t300 = *t299                                                    uintptr
	t301 = convert hex <- uintptr (t300)                                hex
	t302 = &t19.sp [#4]                                            *uintptr
	t303 = *t302                                                    uintptr
	t304 = convert hex <- uintptr (t303)                                hex
	t305 = print(" fp=":string, t301, " sp=":string, t304)               ()
	jump 101
101:                                                            if.done P:2 S:1
	t306 = print("\n":string)                                            ()
	t307 = t90 + 1:int                                                  int
	jump 83
102:                                                         cond.false P:2 S:2
	t308 = t6 >= 2:int32                                               bool
	if t308 goto 100 else 101
103:                                                          cond.true P:1 S:2
	t309 = &t3.m [#21]                                                  **m
	t310 = *t309                                                         *m
	t311 = &t310.curg [#6]                                              **g
	t312 = *t311                                                         *g
	t313 = gp == t312                                                  bool
	if t313 goto 100 else 102
104:                                                          binop.rhs P:1 S:1
	t314 = &t81.entry [#0]                                         *uintptr
	t315 = *t314                                                    uintptr
	t316 = *deferprocPC                                             uintptr
	t317 = t315 == t316                                                bool
	jump 105
105:                                                         binop.done P:2 S:2
	t318 = phi [76: true:bool, 104: t317] #||                          bool
	t319 = t113 == nil:*_func                                          bool
	if t319 goto 30 else 106
106:                                                            if.done P:1 S:2
	t320 = &t19.fn [#0]                                             **_func
	*t320 = t113
	t321 = &t19.pc [#1]                                            *uintptr
	t322 = &t19.lr [#3]                                            *uintptr
	t323 = *t322                                                    uintptr
	*t321 = t323
	t324 = &t19.lr [#3]                                            *uintptr
	*t324 = 0:uintptr
	t325 = &t19.sp [#4]                                            *uintptr
	t326 = &t19.fp [#5]                                            *uintptr
	t327 = *t326                                                    uintptr
	*t325 = t327
	t328 = &t19.fp [#5]                                            *uintptr
	*t328 = 0:uintptr
	t329 = &t19.argmap [#9]                                     **bitvector
	*t329 = nil:*bitvector
	if false:bool goto 108 else 31
107:                                                            if.then P:1 S:2
	t330 = &t19.sp [#4]                                            *uintptr
	t331 = *t330                                                    uintptr
	t332 = convert unsafe.Pointer <- uintptr (t331)          unsafe.Pointer
	t333 = convert *uintptr <- unsafe.Pointer (t332)               *uintptr
	t334 = *t333                                                    uintptr
	t335 = &t19.sp [#4]                                            *uintptr
	t336 = *t335                                                    uintptr
	t337 = t336 + 8:uintptr                                         uintptr
	*t335 = t337
	t338 = &t19.pc [#1]                                            *uintptr
	t339 = *t338                                                    uintptr
	t340 = findfunc(t339)                                            *_func
	t341 = &t19.fn [#0]                                             **_func
	*t341 = t340
	t342 = t340 == nil:*_func                                          bool
	if t342 goto 109 else 110
108:                                                          cond.true P:1 S:2
	if t220 goto 107 else 31
109:                                                            if.then P:1 S:1
	t343 = &t19.pc [#1]                                            *uintptr
	*t343 = t334
	jump 31
110:                                                            if.else P:1 S:2
	t344 = &t340.frame [#3]                                          *int32
	t345 = *t344                                                      int32
	t346 = t345 == 0:int32                                             bool
	if t346 goto 111 else 31
111:                                                            if.then P:1 S:1
	t347 = &t19.lr [#3]                                            *uintptr
	*t347 = t334
	jump 31
112:                                                            if.then P:1 S:1
	jump 113
113:                                                            if.done P:3 S:2
	t348 = phi [30: t87, 114: t87, 112: t85] #n                         int
	t349 = callback != nil:func(*stkframe, unsafe.Pointer) bool        bool
	if t349 goto 118 else 116
114:                                                          cond.true P:1 S:2
	t350 = callback == nil:func(*stkframe, unsafe.Pointer) bool        bool
	if t350 goto 112 else 113
115:                                                            if.then P:1 S:2
	t351 = t86 != nil:*_defer                                          bool
	if t351 goto 119 else 120
116:                                                            if.done P:4 S:0
	return t348
117:                                                          cond.true P:1 S:2
	t352 = t86 != nil:*_defer                                          bool
	if t352 goto 115 else 116
118:                                                          cond.true P:1 S:2
	t353 = t348 < max                                                  bool
	if t353 goto 117 else 116
119:                                                            if.then P:1 S:1
	t354 = &gp.goid [#10]                                            *int64
	t355 = *t354                                                      int64
	t356 = &t86.argp [#2]                                          *uintptr
	t357 = *t356                                                    uintptr
	t358 = convert hex <- uintptr (t357)                                hex
	t359 = &t86.pc [#3]                                            *uintptr
	t360 = *t359                                                    uintptr
	t361 = convert hex <- uintptr (t360)                                hex
	t362 = print("runtime: g":string, t355, ": leftover defer ...":string, t358, " pc=":string, t361, "\n":string) ()
	jump 120
120:                                                            if.done P:2 S:1
	t363 = &gp._defer [#4]                                         **_defer
	t364 = *t363                                                    *_defer
	jump 123
121:                                                           for.body P:1 S:1
	t365 = &t375.argp [#2]                                         *uintptr
	t366 = *t365                                                    uintptr
	t367 = convert hex <- uintptr (t366)                                hex
	t368 = &t375.pc [#3]                                           *uintptr
	t369 = *t368                                                    uintptr
	t370 = convert hex <- uintptr (t369)                                hex
	t371 = print("\tdefer ":string, t375, " argp=":string, t367, " pc=":string, t370, "\n":string) ()
	t372 = &t375.link [#6]                                         **_defer
	t373 = *t372                                                    *_defer
	jump 123
122:                                                           for.done P:1 S:1
	t374 = gothrow("traceback has lef...":string)                        ()
	jump 116
123:                                                           for.loop P:2 S:2
	t375 = phi [120: t364, 121: t373] #_defer                       *_defer
	t376 = t375 != nil:*_defer                                         bool
	if t376 goto 121 else 122

# Name: runtime.setArgInfo
# Package: runtime
# Location: /usr/local/go/src/runtime/traceback.go:451:6
func setArgInfo(frame *stkframe, f *_func, needArgMap bool):
0:                                                                entry P:0 S:2
	t0 = &frame.arglen [#8]                                        *uintptr
	t1 = &f.args [#2]                                                *int32
	t2 = *t1                                                          int32
	t3 = convert uintptr <- int32 (t2)                              uintptr
	*t0 = t3
	if needArgMap goto 3 else 2
1:                                                              if.then P:1 S:2
	t4 = gofuncname(f)                                               string
	t5 = t4 == "reflect.makeFuncStub":string                           bool
	if t5 goto 4 else 5
2:                                                              if.done P:4 S:0
	return
3:                                                            cond.true P:1 S:2
	t6 = &f.args [#2]                                                *int32
	t7 = *t6                                                          int32
	t8 = t7 == -2147483648:int32                                       bool
	if t8 goto 1 else 2
4:                                                          switch.body P:2 S:2
	t9 = &frame.sp [#4]                                            *uintptr
	t10 = *t9                                                       uintptr
	if false:untyped bool goto 6 else 7
5:                                                          switch.next P:1 S:2
	t11 = t4 == "reflect.methodVal...":string                          bool
	if t11 goto 4 else 2
6:                                                              if.then P:1 S:1
	t12 = t10 + 8:uintptr                                           uintptr
	jump 7
7:                                                              if.done P:2 S:2
	t13 = phi [4: t10, 6: t12] #arg0                                uintptr
	t14 = convert unsafe.Pointer <- uintptr (t13)            unsafe.Pointer
	t15 = convert **[2]uintptr <- unsafe.Pointer (t14)         **[2]uintptr
	t16 = *t15                                                  *[2]uintptr
	t17 = &t16[0:int]                                              *uintptr
	t18 = *t17                                                      uintptr
	t19 = &f.entry [#0]                                            *uintptr
	t20 = *t19                                                      uintptr
	t21 = t18 != t20                                                   bool
	if t21 goto 8 else 9
8:                                                              if.then P:1 S:1
	t22 = gofuncname(f)                                              string
	t23 = print("runtime: confused...":string, t22, "\n":string)         ()
	t24 = gothrow("reflect mismatch":string)                             ()
	jump 9
9:                                                              if.done P:2 S:1
	t25 = &t16[1:int]                                              *uintptr
	t26 = *t25                                                      uintptr
	t27 = convert unsafe.Pointer <- uintptr (t26)            unsafe.Pointer
	t28 = convert *bitvector <- unsafe.Pointer (t27)             *bitvector
	t29 = &frame.arglen [#8]                                       *uintptr
	t30 = &t28.n [#0]                                                *int32
	t31 = *t30                                                        int32
	t32 = t31 / 2:int32                                               int32
	t33 = t32 * 8:int32                                               int32
	t34 = convert uintptr <- int32 (t33)                            uintptr
	*t29 = t34
	t35 = &frame.argmap [#9]                                    **bitvector
	*t35 = t28
	jump 2

# Name: runtime.printcreatedby
# Package: runtime
# Location: /usr/local/go/src/runtime/traceback.go:473:6
func printcreatedby(gp *g):
0:                                                                entry P:0 S:2
	t0 = &gp.gopc [#28]                                            *uintptr
	t1 = *t0                                                        uintptr
	t2 = findfunc(t1)                                                *_func
	t3 = t2 != nil:*_func                                              bool
	if t3 goto 4 else 2
1:                                                              if.then P:1 S:2
	t4 = gofuncname(t2)                                              string
	t5 = print("created by ":string, t4, "\n":string)                    ()
	t6 = &t2.entry [#0]                                            *uintptr
	t7 = *t6                                                        uintptr
	t8 = t1 > t7                                                       bool
	if t8 goto 5 else 6
2:                                                              if.done P:4 S:0
	return
3:                                                            cond.true P:1 S:2
	t9 = &gp.goid [#10]                                              *int64
	t10 = *t9                                                         int64
	t11 = t10 != 1:int64                                               bool
	if t11 goto 1 else 2
4:                                                            cond.true P:1 S:2
	t12 = showframe(t2, gp)                                            bool
	if t12 goto 3 else 2
5:                                                              if.then P:1 S:1
	t13 = t1 - 1:uintptr                                            uintptr
	jump 6
6:                                                              if.done P:2 S:2
	t14 = phi [1: t1, 5: t13] #tracepc                              uintptr
	t15 = new string (file)                                         *string
	t16 = funcline(t2, t14, t15)                                      int32
	t17 = *t15                                                       string
	t18 = print("\t":string, t17, ":":string, t16)                       ()
	t19 = &t2.entry [#0]                                           *uintptr
	t20 = *t19                                                      uintptr
	t21 = t1 > t20                                                     bool
	if t21 goto 7 else 8
7:                                                              if.then P:1 S:1
	t22 = &t2.entry [#0]                                           *uintptr
	t23 = *t22                                                      uintptr
	t24 = t1 - t23                                                  uintptr
	t25 = convert hex <- uintptr (t24)                                  hex
	t26 = print(" +":string, t25)                                        ()
	jump 8
8:                                                              if.done P:2 S:1
	t27 = print("\n":string)                                             ()
	jump 2

# Name: runtime.traceback
# Package: runtime
# Location: /usr/local/go/src/runtime/traceback.go:493:6
func traceback(pc uintptr, sp uintptr, lr uintptr, gp *g):
0:                                                                entry P:0 S:0
	t0 = traceback1(pc, sp, lr, gp, 0:uint)                              ()
	return

# Name: runtime.tracebacktrap
# Package: runtime
# Location: /usr/local/go/src/runtime/traceback.go:503:6
func tracebacktrap(pc uintptr, sp uintptr, lr uintptr, gp *g):
0:                                                                entry P:0 S:0
	t0 = traceback1(pc, sp, lr, gp, 2:uint)                              ()
	return

# Name: runtime.traceback1
# Package: runtime
# Location: /usr/local/go/src/runtime/traceback.go:507:6
func traceback1(pc uintptr, sp uintptr, lr uintptr, gp *g, flags uint):
0:                                                                entry P:0 S:2
	t0 = readgstatus(gp)                                             uint32
	t1 = t0 &^ 4096:uint32                                           uint32
	t2 = t1 == 3:uint32                                                bool
	if t2 goto 1 else 2
1:                                                              if.then P:1 S:1
	t3 = &gp.syscallpc [#7]                                        *uintptr
	t4 = *t3                                                        uintptr
	t5 = &gp.syscallsp [#6]                                        *uintptr
	t6 = *t5                                                        uintptr
	t7 = flags &^ 2:uint                                               uint
	jump 2
2:                                                              if.done P:2 S:2
	t8 = phi [0: pc, 1: t4] #pc                                     uintptr
	t9 = phi [0: sp, 1: t6] #sp                                     uintptr
	t10 = phi [0: flags, 1: t7] #flags                                 uint
	t11 = gentraceback(t8, t9, lr, gp, 0:int, nil:*uintptr, 100:int, nil:func(*stkframe, unsafe.Pointer) bool, nil:unsafe.Pointer, t10) int
	t12 = t11 == 0:int                                                 bool
	if t12 goto 5 else 4
3:                                                              if.then P:1 S:1
	t13 = t10 | 1:uint                                                 uint
	t14 = gentraceback(t8, t9, lr, gp, 0:int, nil:*uintptr, 100:int, nil:func(*stkframe, unsafe.Pointer) bool, nil:unsafe.Pointer, t13) int
	jump 4
4:                                                              if.done P:3 S:2
	t15 = phi [2: t11, 5: t11, 3: t14] #n                               int
	t16 = t15 == 100:int                                               bool
	if t16 goto 6 else 7
5:                                                            cond.true P:1 S:2
	t17 = t10 & 1:uint                                                 uint
	t18 = t17 == 0:uint                                                bool
	if t18 goto 3 else 4
6:                                                              if.then P:1 S:1
	t19 = print("...additional fra...":string)                           ()
	jump 7
7:                                                              if.done P:2 S:0
	t20 = printcreatedby(gp)                                             ()
	return

# Name: runtime.callers$1
# Package: runtime
# Location: /usr/local/go/src/runtime/traceback.go:531:6
# Parent: callers
# Free variables:
#   0:	n *int
#   1:	pc *uintptr
#   2:	sp *uintptr
#   3:	skip *int
#   4:	pcbuf **uintptr
#   5:	m *int
func callers$1():
0:                                                                entry P:0 S:0
	t0 = *pc                                                        uintptr
	t1 = *sp                                                        uintptr
	t2 = getg()                                                          *g
	t3 = *skip                                                          int
	t4 = *pcbuf                                                    *uintptr
	t5 = *m                                                             int
	t6 = gentraceback(t0, t1, 0:uintptr, t2, t3, t4, t5, nil:func(*stkframe, unsafe.Pointer) bool, nil:unsafe.Pointer, 0:uint) int
	*n = t6
	return

# Name: runtime.callers
# Package: runtime
# Location: /usr/local/go/src/runtime/traceback.go:527:6
func callers(skip int, pcbuf *uintptr, m int) int:
0:                                                                entry P:0 S:0
	t0 = new int (skip)                                                *int
	*t0 = skip
	t1 = new *uintptr (pcbuf)                                     **uintptr
	*t1 = pcbuf
	t2 = new int (m)                                                   *int
	*t2 = m
	t3 = new uintptr (sp)                                          *uintptr
	t4 = convert unsafe.Pointer <- *int (t0)                 unsafe.Pointer
	t5 = getcallersp(t4)                                            uintptr
	*t3 = t5
	t6 = new uintptr (pc)                                          *uintptr
	t7 = convert unsafe.Pointer <- *int (t0)                 unsafe.Pointer
	t8 = getcallerpc(t7)                                            uintptr
	*t6 = t8
	t9 = new int (n)                                                   *int
	t10 = make closure callers$1 [t9, t6, t3, t0, t1, t2]            func()
	t11 = onM(t10)                                                       ()
	t12 = *t9                                                           int
	return t12

# Name: runtime.gcallers
# Package: runtime
# Location: /usr/local/go/src/runtime/traceback.go:537:6
func gcallers(gp *g, skip int, pcbuf *uintptr, m int) int:
0:                                                                entry P:0 S:0
	t0 = gentraceback(18446744073709551615:uintptr, 18446744073709551615:uintptr, 0:uintptr, gp, skip, pcbuf, m, nil:func(*stkframe, unsafe.Pointer) bool, nil:unsafe.Pointer, 0:uint) int
	return t0

# Name: runtime.showframe
# Package: runtime
# Location: /usr/local/go/src/runtime/traceback.go:541:6
func showframe(f *_func, gp *g) bool:
0:                                                                entry P:0 S:2
	t0 = getg()                                                          *g
	t1 = &t0.m [#21]                                                    **m
	t2 = *t1                                                             *m
	t3 = &t2.throwing [#12]                                          *int32
	t4 = *t3                                                          int32
	t5 = t4 > 0:int32                                                  bool
	if t5 goto 4 else 2
1:                                                              if.then P:2 S:0
	return true:bool
2:                                                              if.done P:3 S:2
	t6 = gotraceback(nil:*bool)                                       int32
	t7 = funcname(f)                                                  *byte
	t8 = gostringnocopy(t7)                                          string
	t9 = t8 == "runtime.panic":string                                  bool
	if t9 goto 6 else 7
3:                                                            cond.true P:1 S:2
	t10 = &t0.m [#21]                                                   **m
	t11 = *t10                                                           *m
	t12 = &t11.curg [#6]                                                **g
	t13 = *t12                                                           *g
	t14 = gp == t13                                                    bool
	if t14 goto 1 else 5
4:                                                            cond.true P:1 S:2
	t15 = gp != nil:*g                                                 bool
	if t15 goto 3 else 2
5:                                                           cond.false P:1 S:2
	t16 = &t0.m [#21]                                                   **m
	t17 = *t16                                                           *m
	t18 = &t17.caughtsig [#7]                                           **g
	t19 = *t18                                                           *g
	t20 = gp == t19                                                    bool
	if t20 goto 1 else 2
6:                                                              if.then P:1 S:0
	return true:bool
7:                                                              if.done P:1 S:2
	t21 = t6 > 1:int32                                                 bool
	if t21 goto 9 else 8
8:                                                            binop.rhs P:1 S:2
	t22 = f != nil:*_func                                              bool
	if t22 goto 12 else 11
9:                                                           binop.done P:2 S:0
	t23 = phi [7: true:bool, 11: t25] #||                              bool
	return t23
10:                                                           binop.rhs P:1 S:2
	t24 = hasprefix(t8, "runtime.":string)                             bool
	if t24 goto 13 else 14
11:                                                          binop.done P:3 S:1
	t25 = phi [8: false:bool, 12: false:bool, 14: t28] #&&             bool
	jump 9
12:                                                           cond.true P:1 S:2
	t26 = contains(t8, ".":string)                                     bool
	if t26 goto 10 else 11
13:                                                           binop.rhs P:1 S:1
	t27 = isExportedRuntime(t8)                                        bool
	jump 14
14:                                                          binop.done P:2 S:1
	t28 = phi [10: true:bool, 13: t27] #||                             bool
	jump 11

# Name: runtime.isExportedRuntime
# Package: runtime
# Location: /usr/local/go/src/runtime/traceback.go:561:6
func isExportedRuntime(name string) bool:
0:                                                                entry P:0 S:2
	t0 = len(name)                                                      int
	t1 = t0 > 8:int                                                    bool
	if t1 goto 4 else 2
1:                                                            binop.rhs P:1 S:1
	t2 = name[8:int]                                                  uint8
	t3 = t2 <= 90:byte                                                 bool
	jump 2
2:                                                           binop.done P:4 S:0
	t4 = phi [0: false:bool, 4: false:bool, 3: false:bool, 1: t3] #&&  bool
	return t4
3:                                                            cond.true P:1 S:2
	t5 = name[8:int]                                                  uint8
	t6 = 65:byte <= t5                                                 bool
	if t6 goto 1 else 2
4:                                                            cond.true P:1 S:2
	t7 = slice name[:8:int]                                          string
	t8 = t7 == "runtime.":string                                       bool
	if t8 goto 3 else 2

# Name: runtime.goroutineheader
# Package: runtime
# Location: /usr/local/go/src/runtime/traceback.go:587:6
func goroutineheader(gp *g):
0:                                                                entry P:0 S:2
	t0 = readgstatus(gp)                                             uint32
	t1 = 0:uint32 <= t0                                                bool
	if t1 goto 4 else 3
1:                                                              if.then P:1 S:1
	t2 = convert int <- uint32 (t0)                                     int
	t3 = &gStatusStrings[t2]                                        *string
	t4 = *t3                                                         string
	jump 2
2:                                                              if.done P:3 S:2
	t5 = phi [1: t4, 5: t13, 6: "???":string] #status                string
	t6 = t0 == 4:uint32                                                bool
	if t6 goto 11 else 12
3:                                                              if.else P:2 S:2
	t7 = t0 & 4096:uint32                                            uint32
	t8 = t7 != 0:uint32                                                bool
	if t8 goto 8 else 6
4:                                                            cond.true P:1 S:2
	t9 = t0 < 9:uint32                                                 bool
	if t9 goto 1 else 3
5:                                                              if.then P:1 S:1
	t10 = t0 &^ 4096:uint32                                          uint32
	t11 = convert int <- uint32 (t10)                                   int
	t12 = &gStatusStrings[t11]                                      *string
	t13 = *t12                                                       string
	jump 2
6:                                                              if.else P:3 S:1
	jump 2
7:                                                            cond.true P:1 S:2
	t14 = t0 &^ 4096:uint32                                          uint32
	t15 = t14 < 9:uint32                                               bool
	if t15 goto 5 else 6
8:                                                            cond.true P:1 S:2
	t16 = t0 &^ 4096:uint32                                          uint32
	t17 = 0:uint32 <= t16                                              bool
	if t17 goto 7 else 6
9:                                                              if.then P:1 S:1
	t18 = &gp.waitreason [#12]                                      *string
	t19 = *t18                                                       string
	jump 10
10:                                                             if.done P:3 S:2
	t20 = phi [12: t5, 11: t5, 9: t19] #status                       string
	t21 = t0 &^ 4096:uint32                                          uint32
	t22 = t21 == 4:uint32                                              bool
	if t22 goto 15 else 16
11:                                                           cond.true P:2 S:2
	t23 = &gp.waitreason [#12]                                      *string
	t24 = *t23                                                       string
	t25 = t24 != "":string                                             bool
	if t25 goto 9 else 10
12:                                                          cond.false P:1 S:2
	t26 = t0 == 4100:uint32                                            bool
	if t26 goto 11 else 10
13:                                                             if.then P:1 S:1
	t27 = nanotime()                                                  int64
	t28 = &gp.waitsince [#11]                                        *int64
	t29 = *t28                                                        int64
	t30 = t27 - t29                                                   int64
	t31 = t30 / 60000000000:int64                                     int64
	jump 14
14:                                                             if.done P:3 S:2
	t32 = phi [16: 0:int64, 15: 0:int64, 13: t31] #waitfor            int64
	t33 = &gp.goid [#10]                                             *int64
	t34 = *t33                                                        int64
	t35 = print("goroutine ":string, t34, " [":string, t20)              ()
	t36 = t32 >= 1:int64                                               bool
	if t36 goto 17 else 18
15:                                                           cond.true P:2 S:2
	t37 = &gp.waitsince [#11]                                        *int64
	t38 = *t37                                                        int64
	t39 = t38 != 0:int64                                               bool
	if t39 goto 13 else 14
16:                                                          cond.false P:1 S:2
	t40 = t21 == 3:uint32                                              bool
	if t40 goto 15 else 14
17:                                                             if.then P:1 S:1
	t41 = print(", ":string, t32, " minutes":string)                     ()
	jump 18
18:                                                             if.done P:2 S:2
	t42 = &gp.lockedm [#22]                                             **m
	t43 = *t42                                                           *m
	t44 = t43 != nil:*m                                                bool
	if t44 goto 19 else 20
19:                                                             if.then P:1 S:1
	t45 = print(", locked to thread":string)                             ()
	jump 20
20:                                                             if.done P:2 S:0
	t46 = print("]:\n":string)                                           ()
	return

# Name: runtime.tracebackothers
# Package: runtime
# Location: /usr/local/go/src/runtime/traceback.go:621:6
func tracebackothers(me *g):
0:                                                                entry P:0 S:2
	t0 = gotraceback(nil:*bool)                                       int32
	t1 = getg()                                                          *g
	t2 = &t1.m [#21]                                                    **m
	t3 = *t2                                                             *m
	t4 = &t3.curg [#6]                                                  **g
	t5 = *t4                                                             *g
	t6 = t5 != nil:*g                                                  bool
	if t6 goto 3 else 2
1:                                                              if.then P:1 S:1
	t7 = print("\n":string)                                              ()
	t8 = goroutineheader(t5)                                             ()
	t9 = traceback(18446744073709551615:uintptr, 18446744073709551615:uintptr, 0:uintptr, t5) ()
	jump 2
2:                                                              if.done P:3 S:1
	t10 = lock(allglock)                                                 ()
	t11 = *allgs                                                       []*g
	t12 = len(t11)                                                      int
	jump 4
3:                                                            cond.true P:1 S:2
	t13 = t5 != me                                                     bool
	if t13 goto 1 else 2
4:                                                      rangeindex.loop P:7 S:2
	t14 = phi [2: -1:int, 5: t15, 12: t15, 10: t15, 9: t15, 11: t15, 13: t15] int
	t15 = t14 + 1:int                                                   int
	t16 = t15 < t12                                                    bool
	if t16 goto 5 else 6
5:                                                      rangeindex.body P:1 S:2
	t17 = &t11[t15]                                                     **g
	t18 = *t17                                                           *g
	t19 = t18 == me                                                    bool
	if t19 goto 4 else 10
6:                                                      rangeindex.done P:1 S:0
	t20 = unlock(allglock)                                               ()
	return
7:                                                              if.done P:2 S:2
	t21 = print("\n":string)                                             ()
	t22 = goroutineheader(t18)                                           ()
	t23 = readgstatus(t18)                                           uint32
	t24 = t23 &^ 4096:uint32                                         uint32
	t25 = t24 == 2:uint32                                              bool
	if t25 goto 12 else 13
8:                                                           cond.false P:1 S:2
	t26 = &t18.issystem [#14]                                         *bool
	t27 = *t26                                                         bool
	if t27 goto 11 else 7
9:                                                           cond.false P:1 S:2
	t28 = readgstatus(t18)                                           uint32
	t29 = t28 == 6:uint32                                              bool
	if t29 goto 4 else 8
10:                                                          cond.false P:1 S:2
	t30 = &t1.m [#21]                                                   **m
	t31 = *t30                                                           *m
	t32 = &t31.curg [#6]                                                **g
	t33 = *t32                                                           *g
	t34 = t18 == t33                                                   bool
	if t34 goto 4 else 9
11:                                                           cond.true P:1 S:2
	t35 = t0 < 2:int32                                                 bool
	if t35 goto 4 else 7
12:                                                             if.then P:1 S:1
	t36 = print("\tgoroutine runnin...":string)                          ()
	t37 = printcreatedby(t18)                                            ()
	jump 4
13:                                                             if.else P:1 S:1
	t38 = traceback(18446744073709551615:uintptr, 18446744073709551615:uintptr, 0:uintptr, t18) ()
	jump 4

# Name: runtime.topofstack
# Package: runtime
# Location: /usr/local/go/src/runtime/traceback.go:651:6
func topofstack(f *_func) bool:
0:                                                                entry P:0 S:2
	t0 = &f.entry [#0]                                             *uintptr
	t1 = *t0                                                        uintptr
	t2 = *goexitPC                                                  uintptr
	t3 = t1 == t2                                                      bool
	if t3 goto 2 else 6
1:                                                            binop.rhs P:1 S:2
	t4 = *externalthreadhandlerp                                    uintptr
	t5 = t4 != 0:uintptr                                               bool
	if t5 goto 7 else 8
2:                                                           binop.done P:6 S:0
	t6 = phi [0: true:bool, 6: true:bool, 5: true:bool, 4: true:bool, 3: true:bool, 8: t17] #|| bool
	return t6
3:                                                           cond.false P:1 S:2
	t7 = *rt0_goPC                                                  uintptr
	t8 = t1 == t7                                                      bool
	if t8 goto 2 else 1
4:                                                           cond.false P:1 S:2
	t9 = *morestackPC                                               uintptr
	t10 = t1 == t9                                                     bool
	if t10 goto 2 else 3
5:                                                           cond.false P:1 S:2
	t11 = *mcallPC                                                  uintptr
	t12 = t1 == t11                                                    bool
	if t12 goto 2 else 4
6:                                                           cond.false P:1 S:2
	t13 = *mstartPC                                                 uintptr
	t14 = t1 == t13                                                    bool
	if t14 goto 2 else 5
7:                                                            binop.rhs P:1 S:1
	t15 = *externalthreadhandlerp                                   uintptr
	t16 = t1 == t15                                                    bool
	jump 8
8:                                                           binop.done P:2 S:1
	t17 = phi [1: false:bool, 7: t16] #&&                              bool
	jump 2

# Name: runtime.isDirectIface
# Package: runtime
# Location: /usr/local/go/src/runtime/typekind.go:42:6
func isDirectIface(t *_type) bool:
0:                                                                entry P:0 S:0
	t0 = &t.kind [#5]                                                *uint8
	t1 = *t0                                                          uint8
	t2 = t1 & 32:uint8                                                uint8
	t3 = t2 != 0:uint8                                                 bool
	return t3

# Name: runtime.init
# Package: runtime
# Synthetic: package initializer
func init():
0:                                                                entry P:0 S:2
	t0 = *init$guard                                                   bool
	if t0 goto 2 else 1
1:                                                           init.start P:1 S:1
	*init$guard = true:bool
	t1 = &eod[0:int]                                               *uintptr
	t2 = &eod[1:int]                                               *uintptr
	t3 = &eod[2:int]                                               *uintptr
	*t1 = 0:uintptr
	*t2 = 1:uintptr
	*t3 = 0:uintptr
	*MemProfileRate = 524288:int
	*kq = -1:int32
	t4 = make error <- errorString ("index out of range":errorString) error
	*indexError = t4
	t5 = make error <- errorString ("slice bounds out ...":errorString) error
	*sliceError = t5
	t6 = make error <- errorString ("integer divide by...":errorString) error
	*divideError = t6
	t7 = make error <- errorString ("integer overflow":errorString)   error
	*overflowError = t7
	t8 = make error <- errorString ("floating point error":errorString) error
	*floatError = t8
	t9 = make error <- errorString ("invalid memory ad...":errorString) error
	*memoryError = t9
	*hashLoad = 13/2:float64
	t10 = &gScanStatusStrings[0:int]                                *string
	t11 = &gScanStatusStrings[1:int]                                *string
	t12 = &gScanStatusStrings[2:int]                                *string
	t13 = &gScanStatusStrings[3:int]                                *string
	t14 = &gScanStatusStrings[4:int]                                *string
	t15 = &gScanStatusStrings[6:int]                                *string
	t16 = &gScanStatusStrings[7:int]                                *string
	*t10 = "scan":string
	*t11 = "scanrunnable":string
	*t12 = "scanrunning":string
	*t13 = "scansyscall":string
	*t14 = "scanwaiting":string
	*t15 = "scandead":string
	*t16 = "scanenqueue":string
	t17 = &gStatusStrings[0:int]                                    *string
	t18 = &gStatusStrings[1:int]                                    *string
	t19 = &gStatusStrings[2:int]                                    *string
	t20 = &gStatusStrings[3:int]                                    *string
	t21 = &gStatusStrings[4:int]                                    *string
	t22 = &gStatusStrings[6:int]                                    *string
	t23 = &gStatusStrings[7:int]                                    *string
	t24 = &gStatusStrings[8:int]                                    *string
	*t17 = "idle":string
	*t18 = "runnable":string
	*t19 = "running":string
	*t20 = "syscall":string
	*t21 = "waiting":string
	*t22 = "dead":string
	*t23 = "enqueue":string
	*t24 = "copystack":string
	t25 = make interface{} <- func(t *chantype, c *hchan, ep unsafe.Pointer, block bool) (selected bool, received bool) (chanrecv) interface{}
	t26 = funcPC(t25)                                               uintptr
	*chanrecvpc = t26
	t27 = &algarray[0:int]                                         *typeAlg
	t28 = &t27.hash [#0]    *func(unsafe.Pointer, uintptr, uintptr) uintptr
	t29 = &t27.equal [#1] *func(unsafe.Pointer, unsafe.Pointer, uintptr) bool
	t30 = &algarray[1:int]                                         *typeAlg
	t31 = &t30.hash [#0]    *func(unsafe.Pointer, uintptr, uintptr) uintptr
	t32 = &t30.equal [#1] *func(unsafe.Pointer, unsafe.Pointer, uintptr) bool
	t33 = &algarray[2:int]                                         *typeAlg
	t34 = &t33.hash [#0]    *func(unsafe.Pointer, uintptr, uintptr) uintptr
	t35 = &t33.equal [#1] *func(unsafe.Pointer, unsafe.Pointer, uintptr) bool
	t36 = &algarray[3:int]                                         *typeAlg
	t37 = &t36.hash [#0]    *func(unsafe.Pointer, uintptr, uintptr) uintptr
	t38 = &t36.equal [#1] *func(unsafe.Pointer, unsafe.Pointer, uintptr) bool
	t39 = &algarray[4:int]                                         *typeAlg
	t40 = &t39.hash [#0]    *func(unsafe.Pointer, uintptr, uintptr) uintptr
	t41 = &t39.equal [#1] *func(unsafe.Pointer, unsafe.Pointer, uintptr) bool
	t42 = &algarray[5:int]                                         *typeAlg
	t43 = &t42.hash [#0]    *func(unsafe.Pointer, uintptr, uintptr) uintptr
	t44 = &t42.equal [#1] *func(unsafe.Pointer, unsafe.Pointer, uintptr) bool
	t45 = &algarray[6:int]                                         *typeAlg
	t46 = &t45.hash [#0]    *func(unsafe.Pointer, uintptr, uintptr) uintptr
	t47 = &t45.equal [#1] *func(unsafe.Pointer, unsafe.Pointer, uintptr) bool
	t48 = &algarray[7:int]                                         *typeAlg
	t49 = &t48.hash [#0]    *func(unsafe.Pointer, uintptr, uintptr) uintptr
	t50 = &t48.equal [#1] *func(unsafe.Pointer, unsafe.Pointer, uintptr) bool
	t51 = &algarray[8:int]                                         *typeAlg
	t52 = &t51.hash [#0]    *func(unsafe.Pointer, uintptr, uintptr) uintptr
	t53 = &t51.equal [#1] *func(unsafe.Pointer, unsafe.Pointer, uintptr) bool
	t54 = &algarray[9:int]                                         *typeAlg
	t55 = &t54.hash [#0]    *func(unsafe.Pointer, uintptr, uintptr) uintptr
	t56 = &t54.equal [#1] *func(unsafe.Pointer, unsafe.Pointer, uintptr) bool
	t57 = &algarray[10:int]                                        *typeAlg
	t58 = &t57.hash [#0]    *func(unsafe.Pointer, uintptr, uintptr) uintptr
	t59 = &t57.equal [#1] *func(unsafe.Pointer, unsafe.Pointer, uintptr) bool
	t60 = &algarray[11:int]                                        *typeAlg
	t61 = &t60.hash [#0]    *func(unsafe.Pointer, uintptr, uintptr) uintptr
	t62 = &t60.equal [#1] *func(unsafe.Pointer, unsafe.Pointer, uintptr) bool
	t63 = &algarray[12:int]                                        *typeAlg
	t64 = &t63.hash [#0]    *func(unsafe.Pointer, uintptr, uintptr) uintptr
	t65 = &t63.equal [#1] *func(unsafe.Pointer, unsafe.Pointer, uintptr) bool
	t66 = &algarray[13:int]                                        *typeAlg
	t67 = &t66.hash [#0]    *func(unsafe.Pointer, uintptr, uintptr) uintptr
	t68 = &t66.equal [#1] *func(unsafe.Pointer, unsafe.Pointer, uintptr) bool
	t69 = &algarray[14:int]                                        *typeAlg
	t70 = &t69.hash [#0]    *func(unsafe.Pointer, uintptr, uintptr) uintptr
	t71 = &t69.equal [#1] *func(unsafe.Pointer, unsafe.Pointer, uintptr) bool
	t72 = &algarray[15:int]                                        *typeAlg
	t73 = &t72.hash [#0]    *func(unsafe.Pointer, uintptr, uintptr) uintptr
	t74 = &t72.equal [#1] *func(unsafe.Pointer, unsafe.Pointer, uintptr) bool
	t75 = &algarray[16:int]                                        *typeAlg
	t76 = &t75.hash [#0]    *func(unsafe.Pointer, uintptr, uintptr) uintptr
	t77 = &t75.equal [#1] *func(unsafe.Pointer, unsafe.Pointer, uintptr) bool
	t78 = &algarray[17:int]                                        *typeAlg
	t79 = &t78.hash [#0]    *func(unsafe.Pointer, uintptr, uintptr) uintptr
	t80 = &t78.equal [#1] *func(unsafe.Pointer, unsafe.Pointer, uintptr) bool
	t81 = &algarray[18:int]                                        *typeAlg
	t82 = &t81.hash [#0]    *func(unsafe.Pointer, uintptr, uintptr) uintptr
	t83 = &t81.equal [#1] *func(unsafe.Pointer, unsafe.Pointer, uintptr) bool
	t84 = &algarray[19:int]                                        *typeAlg
	t85 = &t84.hash [#0]    *func(unsafe.Pointer, uintptr, uintptr) uintptr
	t86 = &t84.equal [#1] *func(unsafe.Pointer, unsafe.Pointer, uintptr) bool
	t87 = &algarray[20:int]                                        *typeAlg
	t88 = &t87.hash [#0]    *func(unsafe.Pointer, uintptr, uintptr) uintptr
	t89 = &t87.equal [#1] *func(unsafe.Pointer, unsafe.Pointer, uintptr) bool
	t90 = &algarray[21:int]                                        *typeAlg
	t91 = &t90.hash [#0]    *func(unsafe.Pointer, uintptr, uintptr) uintptr
	t92 = &t90.equal [#1] *func(unsafe.Pointer, unsafe.Pointer, uintptr) bool
	*t28 = memhash
	*t29 = memequal
	*t31 = memhash
	*t32 = memequal0
	*t34 = memhash
	*t35 = memequal8
	*t37 = memhash
	*t38 = memequal16
	*t40 = memhash
	*t41 = memequal32
	*t43 = memhash
	*t44 = memequal64
	*t46 = memhash
	*t47 = memequal128
	*t49 = nil:func(unsafe.Pointer, uintptr, uintptr) uintptr
	*t50 = nil:func(unsafe.Pointer, unsafe.Pointer, uintptr) bool
	*t52 = nil:func(unsafe.Pointer, uintptr, uintptr) uintptr
	*t53 = nil:func(unsafe.Pointer, unsafe.Pointer, uintptr) bool
	*t55 = nil:func(unsafe.Pointer, uintptr, uintptr) uintptr
	*t56 = nil:func(unsafe.Pointer, unsafe.Pointer, uintptr) bool
	*t58 = nil:func(unsafe.Pointer, uintptr, uintptr) uintptr
	*t59 = nil:func(unsafe.Pointer, unsafe.Pointer, uintptr) bool
	*t61 = nil:func(unsafe.Pointer, uintptr, uintptr) uintptr
	*t62 = nil:func(unsafe.Pointer, unsafe.Pointer, uintptr) bool
	*t64 = nil:func(unsafe.Pointer, uintptr, uintptr) uintptr
	*t65 = nil:func(unsafe.Pointer, unsafe.Pointer, uintptr) bool
	*t67 = nil:func(unsafe.Pointer, uintptr, uintptr) uintptr
	*t68 = nil:func(unsafe.Pointer, unsafe.Pointer, uintptr) bool
	*t70 = strhash
	*t71 = strequal
	*t73 = interhash
	*t74 = interequal
	*t76 = nilinterhash
	*t77 = nilinterequal
	*t79 = nil:func(unsafe.Pointer, uintptr, uintptr) uintptr
	*t80 = nil:func(unsafe.Pointer, unsafe.Pointer, uintptr) bool
	*t82 = f32hash
	*t83 = f32equal
	*t85 = f64hash
	*t86 = f64equal
	*t88 = c64hash
	*t89 = c64equal
	*t91 = c128hash
	*t92 = c128equal
	*buildVersion = "go1.4.2":string
	t93 = make interface{} <- func(t *chantype, c *hchan, ep unsafe.Pointer, block bool, callerpc uintptr) bool (chansend) interface{}
	t94 = funcPC(t93)                                               uintptr
	*chansendpc = t94
	t95 = init#1()                                                       ()
	t96 = init#2()                                                       ()
	t97 = init#3()                                                       ()
	t98 = init#4()                                                       ()
	jump 2
2:                                                            init.done P:2 S:0
	return

42
